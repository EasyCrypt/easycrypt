% Fill this with latex code
\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{textcomp}

\title{Spec Language Technical Documentation}
\author{Gustavo Delerue}
\date{\today}

\begin{document}
  \maketitle
  \section{Syntax}
  \subsection{Slices}
  A slice is an expression of the form $\mathbf{e[e\_start:e\_times:e\_size]}$
  where $\mathbf{e}$, $\mathbf{e\_start}$, $\mathbf{e\_time}$ and
  $\mathbf{e\_size}$ are expressions.  This slice corresponds to taking
  ($\mathbf{e\_times}$) words of size ($\mathbf{e\_size}$) from word
  ($\mathbf{e}$) starting from offset ($\mathbf{e\_start}$).

  Ideally a slice has constant integer expressions for both
  ($\mathbf{e\_times}$) and ($\mathbf{e\_size}$).  If ($\mathbf{e\_size}$) is
  ommitted, the default value is 1. The other expressions are all mandatory for
  a slice.

  As we treat bit and word arrays as single (bigger) words, $\mathbf{e[\_:a:b]}$
  is equivalent to $\mathbf{e[\_:1:a*b]}$, $\mathbf{e[\_:a*b:1]}$ and
  $\mathbf{e[\_:a*b]}$. The specific usage should be dictated by the semantics
  of the operation.
  
  \subsection{Comments}
  Comments can be added with ``\#'' for single lines, or `` \^\ '' to comment
  until end of file (for debugging purposes, to be removed later and changed for
  multi line comments if necessary).

  \subsection{Combinators}
  Combinators are hardcoded function of the implementation, whose semantics are
  externally defined (in the implementation and in evaluators *TODO*: Check this)
  \begin{itemize}
  \item $add\langle n \rangle$: Addition, inputs and output are $n$ bits (*how is
    overflow handled?*)
  \item $and\langle n \rangle$: Logical and, inputs and output of $n$ bits
  \item $concat\langle n \rangle$: Takes two $n$ bit inputs and concatenates them as bit words
    into a $2n$ bit output
  \item $mult\langle n \rangle$: Multiplication, inputs are $n$ bits, output is
    $2n$ bits
  \item $repeat\langle n \rangle(a, m)$: Takes an $n$ bit input and a fixed
    integer $m$ and returns a repeated m times as a $n*m$ bit word
  \item $or\langle n \rangle$: Logical or, inputs and outputs of $n$ bits
  \item $SatToUW\langle n \rangle(a,m)$: Clamping (or saturation), takes and
    returns $n$ bits clamped to a $m$ bit unsigned range
  \item $SatToSW\langle n \rangle(a,m)$: Clamping (or saturation), takes and
    returns $n$ bits clamped to a $m$ bit signed range
  \item $sla\langle n \rangle(a, b)$: Shift left arithmetic, input and output
    are $n$ bits
  \item $sra\langle n \rangle(a, b)$: Shift right arithmetic, input and output
    are $n$ bits
  \item $srl\langle n \rangle(a, b)$: Shift right logical, input and output are
    $n$ bits
  \item $sub\langle n \rangle(a, b)$: Subtraction, inputs are $n$ bits (* how it
    overflow handled? *)
  \item $map\langle n,m \rangle(f, arg1, arg2, ...)$: Takes as input a function
    f: (args) -> @k and \#(args) arguments of size $nm$, splits them into $m$
    words of $n$ bits and maps f over the collection in the following manner:
    \begin{itemize}
    \item Take the first word from each argument
    \item Pass them as arguments to f and get a $k$ bit word as a result
    \item Do this for each following word in the arguments
    \item Concatenate the results into a $k*m$ bit word and return that as the
      result
    \end{itemize}
    Returns a $km$ bit word
  \end{itemize}
  
  \section{Type System}
  The type system consists of 3 types:
  \begin{itemize}
  \item Words, parameterized by a length $n$ (in bits)
  \item Unsigned (integers)
  \item Signed (integers)
  \end{itemize}
  Conversions from integers to words and the reverse must be explicit.  All
  combinators defined (* so far *) operate on words of a given size and return a
  word of some other size (depending on the parameter in angled brackets), with
  some exceptions for ``compile-time fixed'' integers as arguments.  Top level
  functions are only type checked (?), their types are explicitly declared on
  the spec file (might change later). There are no function types.
  \subsection{Deduction Rules}
  \begin{itemize}
  \item Typecasts: Just convert the type into the new type (* should be checked
    ? *)
  \item Anonymous functions: Typed as the return type, checked if the body
    evaluates to the return type assuming the arguments are the declared types
  \item Variable reference: Typed as variable type 
  \item Let expressions: let $v=e_1$ in $e_2$ has type equal to the type of
    $e_2$ evaluated with $v$ added to the context with type equal to the type of
    $e_1$.
  \item Slice: if expression being sliced has integer type throws an error. All
    types in the slice parameters must be integers and all but the first one
    must be compile time fixed. If all are fixed also checks if input has
    sufficient length (might be extended to require proof that variable inputs
    still allow slice?). Returns Word of size dependent on the paremeters
  \item Combinators: Take words of length depending on the parameter in angled
    brackets and return words (with a few exceptions, listed above in syntax).
  \item Map: Takes as input a function and several words. The number of words of
    input must be the same as the number of parameters of the input
    function. The bit lengths of both the function parameters and the word
    inputs must be consistent with the map angled bracket parameters. Returns a
    Word of bit length dependent on the parameters.
  \end{itemize}
\end{document}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

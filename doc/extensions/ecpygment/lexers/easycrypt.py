# ------------------------------------------------------------------------
import pygments.lexer as pylex
import pygments.token as pytok

import itertools as it

# ------------------------------------------------------------------------
# Generated by `scripts/srctx/keywords -m python < src/ecLexer.mll`
keywords = dict(
    bytac     = ['exact', 'assumption', 'smt', 'coq', 'check', 'edit', 'fix', 'by', 'reflexivity', 'done', 'solve'],
    dangerous = ['admit', 'admitted'],
    global_   = ['axiom', 'axiomatized', 'lemma', 'realize', 'proof', 'qed', 'abort', 'goal', 'end', 'from', 'import', 'export', 'include', 'local', 'global', 'declare', 'hint', 'module', 'of', 'const', 'op', 'pred', 'inductive', 'notation', 'abbrev', 'require', 'theory', 'abstract', 'section', 'subtype', 'type', 'class', 'instance', 'print', 'search', 'locate', 'as', 'Pr', 'clone', 'with', 'rename', 'prover', 'timeout', 'why3', 'dump', 'remove', 'exit', 'Top', 'Self'],
    internal  = ['fail', 'time', 'undo', 'debug', 'pragma'],
    prog      = ['forall', 'exists', 'fun', 'glob', 'let', 'in', 'for', 'var', 'proc', 'if', 'is', 'match', 'then', 'else', 'elif', 'match', 'for', 'while', 'assert', 'return', 'res', 'equiv', 'hoare', 'ehoare', 'phoare', 'islossless', 'async'],
    tactic    = ['beta', 'iota', 'zeta', 'eta', 'logic', 'delta', 'simplify', 'cbv', 'congr', 'change', 'split', 'left', 'right', 'case', 'pose', 'gen', 'have', 'suff', 'elim', 'exlim', 'ecall', 'clear', 'wlog', 'idassign', 'apply', 'rewrite', 'rwnormal', 'subst', 'progress', 'trivial', 'auto', 'idtac', 'move', 'modpath', 'field', 'fieldeq', 'ring', 'ringeq', 'algebra', 'replace', 'transitivity', 'symmetry', 'seq', 'wp', 'sp', 'sim', 'skip', 'call', 'rcondt', 'rcondf', 'swap', 'cfold', 'rnd', 'rndsem', 'pr_bounded', 'bypr', 'byphoare', 'byehoare', 'byequiv', 'byupto', 'fel', 'conseq', 'exfalso', 'inline', 'outline', 'interleave', 'alias', 'weakmem', 'fission', 'fusion', 'unroll', 'splitwhile', 'kill', 'eager'],
    tactical  = ['try', 'first', 'last', 'do', 'expect'],
)

# ------------------------------------------------------------------------
kwclasses = dict(
  bytac     = pytok.Name.Exception,
  dangerous = pytok.Name.Exception,
  global_   = pytok.Keyword.Declaration,
  internal  = pytok.Keyword.Declaration,
  prog      = pytok.Keyword.Reserved,
  tactic    = pytok.Keyword.Reserved,
  tactical  = pytok.Keyword.Pseudo,
)

# ------------------------------------------------------------------------
class EasyCryptLexer(pylex.RegexLexer):
  name      = "EasyCrypt"
  filenames = ["*.ec", "*.eca"]
  mimetypes = ["text/x-easycrypt"]

  tokens = {
    "root": [
      # Whitespace
      (r"[ \t]+", pytok.Whitespace),
      (r"\n+", pytok.Whitespace),

      # Comments
      (r"\(\*", pytok.Comment.Multiline, "comment"),
    ] + [
      # Keywords
      (pylex.words(keywords[ids], suffix=r"\b"), cls)
      for ids, cls in kwclasses.items()
    ] + [
      # Strings (simple single/double quoted)
      (r'"([^"\\]|\\.)*"', pytok.String.Double),

      # Numbers
      (r"\b\d+\b", pytok.Number.Integer),

      # Identifiers
      (r"[A-Za-z_]\w*", pytok.Name),

      # Operators
      (r"[+\-*/%=<>&|!]+", pytok.Operator),

      # Punctuation
      (r"[()\[\]{},.;:]", pytok.Punctuation),

      # Anything else
      (r".", pytok.Text),
    ],

    "comment": [
      (r"\(\*", pytok.Comment.Multiline, "#push"),

      # If we see a closer, pop one nesting level
      (r"\*\)", pytok.Comment.Multiline, "#pop"),

      # Otherwise consume content (keep it as Comment)
      (r"[^()*]+", pytok.Comment.Multiline),
      (r"[()*]", pytok.Comment.Multiline),
    ],
  }

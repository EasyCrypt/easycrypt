% --------------------------------------------------------------------
\begin{tactic}{swap}
All versions of the tactic work for \prhl (an optional side can be given),
\phl and \hl.

\begin{tsyntax}{swap\ $p_1$\ $p_2$\ $p_3$}
  Swaps the code between positions $p_1$ and $p_2$ with the code between 
  positions $p_2$ and $p_3$. That is, assuming that $c_1$ and $c_2$ are 
  syntactically independent, that $c_1$ is between positions $p_1$ and $p_2$ 
  and that $c_2$ is between positions $p_2$ and $p_3$, the tactic implements 
  the following rule:
\begin{mathpar}
\inferrule{\HL{P}{c;c_2;c_1;c_3}{Q}}
          {\HL{P}{c;c_1;c_2;c_3}{Q}}
          [\tct{swap}\ p_1\ p_2\ p_3]
\end{displaymath}
\end{tsyntax}

\begin{tsyntax}{swap\ $k$}
If $k$ is positive (negative) then [\tct{swap} $k$] moves the first
(last) instruction $k$ positions forwards (backwards). 
\end{tsyntax}

\begin{tsyntax}{swap\ $p$\ $k$}
Moves the $p^{th}$ instruction forwards or backwards.
\end{tsyntax}

\begin{tsyntax}{swap\ [$p_1$..$p_2$]\ $k$}
Moves the instructions between positions $p_1$ and $p_2$ forwards or backwards.
\end{tsyntax}









 %%  \begin{tsyntax}[empty]{swap [$p_1$..$p_2$] n }
%%    swap 
%%   \end{tsyntax}
%% \textbf{where:} 
%% \begin{tabular}[t]{l}
%%   \textit{swap\_pos} ::= 
%%   \textit{n} \textit{n} \textit{n} $\mid$ \textit{n} \textit{z} $\mid$ [\textit{n}..\textit{n}] \textit{z}
%%   \\
%%   $n$ a natural number
%%   \\
%%   $z$ an integer number
%% \end{tabular}
  

%% The tactic [\rawec{swap} $p_1$ $p_2$ $p_3$] swaps the code between
%% positions $p_1$ and $p_2$ with the code between positions $p_2$ and
%% $p_3$. That is, assuming that $c_1$ and $c_2$ are syntactically
%% independent, that $c_1$ is between positions $p_1$ and $p_2$ and that
%% $c_2$ is between positions $p_2$ and $p_3$, the tactic implements the
%% following rule:
%% \begin{displaymath}
%% \infrule{
%%   \Hoare{c;c_2;c_1;c_3}{\pre}{\post}
%% }{
%%   \Hoare{c;c_1;c_2;c_3}{\pre}{\post}
%% } [\mathec{swap}\ p_1\ p_2\ p_3]
%% \end{displaymath}

%% If $k$ is positive (negative) then [\rawec{swap} $k$] moves the first
%% (last) instruction $k$ positions forwards (backwards). Similarly,
%% [\rawec{swap} $i$ $k$] moves the $i^{th}$ instruction forwards or
%% backwards, and [\rawec{swap} $[i_1:i_2]$ $k$] moves the instructions
%% between positions $i_1$ and $i_2$.

%%   \fix{Missing description of swap}.
%%   \end{tsyntax}
\end{tactic}

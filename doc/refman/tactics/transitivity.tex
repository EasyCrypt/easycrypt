% --------------------------------------------------------------------
\begin{tactic}{transitivity}
  \begin{tsyntax}{transitivity c ($P_1$ ==> $\ Q_1$) ($P_2$ ==> $\ Q_2$)}
  In \prhl, applies the transitivity of program equivalence using the
  specified program and specifications. When the goal is a judgment on
  procedures, \tct{c} should be a procedure. When the goal is a
  judgment on statements, \tct{c} should be a statement, and the
  tactic then takes a side argument, used to decide the procedure
  context under which local variables from \tct{c} are evaluated.

  \textbf{Examples:}
  \begin{mathpar}
  \inferrule%%
    {\forall \mem{m_1}\ \mem{m_2}.\, P~\mem{m_1}~\mem{m_2} \Rightarrow
        \exists \mem{m}.\,P_1~\mem{m_1}~\mem{m} \wedge P_2~\mem{m}~\mem{m_2} \\%
     \forall \mem{m_1}\ \mem{m}\ \mem{m_2}.\,
        Q1~\mem{m_1}~\mem{m} \Rightarrow
        Q2~\mem{m}~\mem{m_2} \Rightarrow
        Q~\mem{m_1}~\mem{m_2} \\%
     \pRHL{P_1}{f_1}{f}{Q_1} \\%
     \pRHL{P_2}{f}{f_2}{Q_2}}%%
    {\pRHL{P}{f_1}{f_2}{Q}}%%
    \quad\mbox{(\prhl)\quad\parbox{200pt}{\tct{transitivity f ($P_1$ ==> $\ Q_1$) ($P_2$ ==> $\ Q_2$)}}} \\
  \inferrule%%
    {\forall \mem{m_1}\ \mem{m_2}.\, P~\mem{m_1}~\mem{m_2} \Rightarrow
        \exists \mem{m}.\,P_1~\mem{m_1}~\mem{m} \wedge P_2~\mem{m}~\mem{m_2} \\%
     \forall \mem{m_1}\ \mem{m}\ \mem{m_2}.\,
        Q_1~\mem{m_1}~\mem{m} \Rightarrow
        Q_2~\mem{m}~\mem{m_2} \Rightarrow
        Q~\mem{m_1}~\mem{m_2} \\%
     \pRHL{P_1}{s_1}{s}{Q_1} \\%
     \pRHL{P_2}{s}{s_2}{Q_2}}%%
    {\pRHL{P}{s_1}{s_2}{Q}}%%
    \quad\mbox{(\prhl)\quad\parbox{200pt}{\tct{transitivity$\{$1$\}$ $\ \{$ s $\ \}$ ($P_1$ ==> $\ Q_1$) ($P_2$ ==> $\ Q_2$)}}} \\
  \end{mathpar}

  \textbf{Note:} In practice, the existential quantification over
  memory $\mem{m}$ in the first generated subgoal is replaced with an
  existential quantification over the program variables appearing in $P$,
  $P_1$, ot $P_2$.
  \end{tsyntax}
\end{tactic}

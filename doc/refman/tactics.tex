% --------------------------------------------------------------------
\section{Tactics}

\subsection{Ambient logic}

\input{tactics/idtac.tex}
\input{tactics/move.tex}
\input{tactics/clear.tex}
\input{tactics/done.tex}
\input{tactics/apply.tex}
\input{tactics/exact.tex}
\input{tactics/assumption.tex}
\input{tactics/pose.tex}
\input{tactics/cut.tex}

\input{tactics/rewrite.tex}
\input{tactics/rwnormal.tex}
\input{tactics/subst.tex}

\input{tactics/split.tex}
\input{tactics/left.tex}
\input{tactics/right.tex}

\input{tactics/case.tex}
\input{tactics/elim.tex}

\input{tactics/change.tex}
\input{tactics/simplify.tex}
\input{tactics/progress.tex}

\input{tactics/beta.tex}
\input{tactics/delta.tex}
\input{tactics/zeta.tex}
\input{tactics/iota.tex}
\input{tactics/logic.tex}

\input{tactics/reflexivity.tex}

\input{tactics/ringeq.tex}
\input{tactics/fieldeq.tex}
\input{tactics/algebra.tex}
\input{tactics/congr.tex}

\input{tactics/trivial.tex}
\input{tactics/smt.tex}

\input{tactics/admit.tex}

\subsection{Program Logics}

Judgments in the program logics may refer to procedures or
statements. Whenever the context allows both, we use $c$ (or \tct{c})
to denote programs, using $f$ (or \tct{f}) when only judgments on
procedures are allowed by the context, and $s$ (or \tct{s}) when only
judgments on statements are allowed.

\EasyCrypt includes three different program logics:
\begin{itemize}
\item \prhl, or probabilistic relational Hoare logic, with judgments of the form
%%
$$\pRHL{P}{c_1}{c_2}{Q}$$
%%
where $c_1$ and $c_2$ are programs, and $P$ and $Q$
are relations on memories.
\item \phl, or probabilistic Hoare logic, with judgments of the form
%%
$$\pHL{P}{c}{Q}{\diamond}{\delta}$$
%%
where $c$ is a program, $P$ and $Q$ are predicates on memories,
$\diamond\in\{\leq,\geq,=\}$ is a comparison relation and $\delta$ is
a real-valued expression, evaluated in the initial memory.
\item \hl, or (possibilistic) Hoare logic, with judgments of the form
%%
$$\HL{P}{c}{Q}$$
%%
where $c$ is a program, and $P$ and $Q$ are predicates on memories.
\end{itemize}

When $c$ is a procedure, preconditions ($P$ above) operate on memories
extended with a special $\Arg$ location that refers to the procedure's
arguments, and postcondition ($Q$ above) operate on memories extended
with a special $\Res$ location that refers to the procedure's return
value.

In the following, given a relation $R$, we denote with $\invrel{R}$
its inverse relation (that is,
%%
$\Rel{R}{m_1}{m_2} \Leftrightarrow \Rel{\invrel{R}}{m_2}{m_1}$).

We denote with $\diamond^{\uparrow}$ the function defined by
$$
\cdot^{\uparrow} =
\left\{\begin{array}{l @{\quad\mapsto\quad} r}
=    & \Leftrightarrow \\
\leq & \Leftarrow      \\
\geq & \Rightarrow
\end{array}\right.
$$

Given a predicate $P$, we denote with $\inmem{P}{1}$
(resp. $\inmem{P}{2}$) the relation defined by
%%
$\Rel{\inmem{P}{1}}{m_1}{m_2} \Leftrightarrow \Pred{P}{m_1}$
(resp. $\Rel{\inmem{P}{2}}{m_1}{m_2} \Leftrightarrow \Pred{P}{m_2}$).
We lift logical connectors to predicates and relations over memories
in the natural way.

TODO: define \tct{<spec>}, \tct{<lemma>}, \tct{<prhl>}, \tct{<phl>},
\tct{<hl>}.

\paragraph{Reasoning on Specifications}
\input{tactics/symmetry.tex}
\input{tactics/transitivity.tex}
\input{tactics/conseq.tex}
\input{tactics/phoare_split.tex}
\input{tactics/byequiv.tex}
\input{tactics/byphoare.tex}
\input{tactics/hoare.tex}
\input{tactics/bypr.tex}
\input{tactics/exfalso.tex}
%\input{tactics/pr_bounded.tex}

\paragraph{Reasoning on Programs}
Unless specified, the following program logic tactics operate on a
program's last instruction. Although we describe these tactics as if
they operated on single instructions, their practical implementation
automatically and implicitly applies tactic \rtactic{seq} to deal with
context when necessary.

For simple proofs, it is often enough to simply apply the program
tactic corresponding to the last instruction in the program and let
\tct{smt} deal with the verification condition once the program has
been exhausted.

\medskip

\input{tactics/skip.tex}
\input{tactics/seq.tex}
\input{tactics/sp.tex}
\input{tactics/wp.tex}
\input{tactics/rnd.tex}
\input{tactics/if.tex}
\input{tactics/while.tex}
\input{tactics/call.tex}
\input{tactics/proc.tex}


\paragraph{Transforming Programs}
\input{tactics/swap.tex}
\input{tactics/inline.tex}

\input{tactics/rcondf.tex}
\input{tactics/rcondt.tex}

\input{tactics/splitwhile.tex}
\input{tactics/unroll.tex}
\input{tactics/fission.tex}
\input{tactics/fusion.tex}

\input{tactics/alias.tex}
\input{tactics/cfold.tex}
\input{tactics/kill.tex}
\input{tactics/modpath.tex}

\paragraph{Automated Tactics}
\input{tactics/auto.tex}
\input{tactics/sim.tex}

\paragraph{Advanced Tactics}
\input{tactics/eager.tex}
\input{tactics/fel.tex}

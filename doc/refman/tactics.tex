% --------------------------------------------------------------------
\section{Tactics}

\EasyCrypt comes with a proof engine that allows to state and prove properties
about programs written in the various languages.
%
Proofs are built interactively by applying tactics, that transform a
current proof goal into a (possibly empty) set of subgoals such that the
conjunction of the subgoals implies the original goal.
%
This process is repeated, starting from the theorem statement, up to the point
where all the subgoals correspond to general axioms or premises of the theorem.

In this chapter, we describe this proof engine in general before listing and
describing the existing tactics for various fragments of \EasyCrypt's
underlying logic.

\section{The proof engine}

The proof engine deals with judgments or goals of the form
$\epsilon; \Gamma \vdash \phi$ where $\epsilon$ is the (global) environment,
$\Gamma$ is the context (a set of local facts) and $\phi$ is the
formula we want to prove. Here is an example of such a judgment:

\begin{center}
$\mathsf{Int}; x, y , z: \tint, x \le y \vdash x + z \le y + z$.
\end{center}

It states that in the environment ($\mathsf{Int}$) solely composed of the
theory of integers, having three local variables $x, y, z$ of type
$\mathsf{int}$ along with the fact $x \le y$ (the context $\Gamma$), we are
interested in proving $x + z \le y + z$.

\medskip

On top on this, a set of deduction rules is given. They describe how one can
derive a judgment $\epsilon; \Gamma \vdash \phi$ given that a set of prerequisites
(or premises) are fulfilled. The general form of such a rule is given
as follow:

\begin{mathpar}
 \inferrule{A_1 \cdots A_n}{\epsilon; \Gamma \vdash \phi}
\end{mathpar}

It has to be read as: \emph{given that $A_1 \cdots A_n$ are derivable, then
so is $\epsilon, \Gamma \vdash \phi$}. We give three examples of such deduction
rules:

\begin{mathpar}
 \inferrule[left=MP]
         {\epsilon; \Gamma \vdash \phi_1 \quad
          \epsilon; \Gamma \vdash \phi_1 \Rightarrow \phi_2}
         {\epsilon; \Gamma \vdash \phi_2}
 \quad\quad
 \inferrule[left=$\Rightarrow$-I]
         {\epsilon; \Gamma, \phi_1 \vdash \phi_2}
         {\epsilon; \Gamma \vdash \phi_1 \Rightarrow \phi_2}
 \quad\quad
 \inferrule[left=Ax]{ }{\epsilon; \Gamma, \phi, \Delta \vdash \phi}
\end{mathpar}

The first, the \emph{modus ponens}, states that one can derive
$\epsilon; \Gamma \vdash \phi_2$ given that $\epsilon; \Gamma \vdash \phi_1
\Rightarrow \phi_2$ and $\epsilon; \Gamma \vdash \phi_1$ are derivable.
%
The next provides a way for deriving $\phi_1 \Rightarrow \phi_2$ from
a derivation of $\phi_2$, but with a context augmented by $\phi_1$.
%
The last states that $\epsilon; \Gamma, \phi, \Delta \vdash \phi$ is derivable as-is.

Combining these deduction rules, it is possible to build a tree rooted by
a judgment $\epsilon; \Gamma \vdash \phi$ and with leaves composed of deduction
rules with no premises (as the third one in the previous example). Such a
tree forms a proof of $\epsilon; \Gamma \vdash \phi$.
%
For instance, Figure~\ref{fig:LJproof} gives a proof of
%
\[\epsilon; b_1, b_2 : \tbool \vdash (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2\]

\begin{figure}
  \begin{mathpar}
    \inferrule
      {\inferrule{ }{\epsilon; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_1 \Rightarrow b_2} \quad
       \inferrule{ }{\epsilon; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_1}}
      {\inferrule
        {\epsilon; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_2}
        {\inferrule
           {\epsilon; b_1, b_2 : \tbool, b_1 \Rightarrow b_2 \vdash b_1 \Rightarrow b_2}
           {\epsilon; b_1, b_2 : \tbool \vdash (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2}}}
  \end{mathpar}

  \caption{\label{fig:LJproof} Proof tree of
    $\epsilon; b_1, b_2 : \tbool \vdash
        (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2$}
\end{figure}

The \EasyCrypt proof engine helps the user build such proofs. At each step
of the proof building, the system presents to the user the set of goals
that have to be proved. The user can then \emph{apply} a tactic to one of
them, each tactic corresponding to a deduction rule. If the conclusion
of the rule corresponding to the applied tactic matches the goal to which
it is applied, the proof engine replaces it with the set of the
premises of the applied rule - the subgoals. This application may generate
no, one or several subgoals depending on the rule. This process is repeated
iteratively, up to the point where no goals remain.

\subsection{Ambient logic}

\input{tactics/idtac.tex}
\input{tactics/move.tex}
\input{tactics/clear.tex}
\input{tactics/done.tex}
\input{tactics/apply.tex}
\input{tactics/exact.tex}
\input{tactics/assumption.tex}
\input{tactics/pose.tex}
\input{tactics/cut.tex}

\input{tactics/rewrite.tex}
\input{tactics/subst.tex}

\input{tactics/split.tex}
\input{tactics/left.tex}
\input{tactics/right.tex}

\input{tactics/case.tex}
\input{tactics/elim.tex}

\input{tactics/simplify.tex}
\input{tactics/progress.tex}

\input{tactics/reflexivity.tex}
\input{tactics/congr.tex}

\input{tactics/trivial.tex}
\input{tactics/smt.tex}

\input{tactics/admit.tex}

\subsection{Tacticals}

Tactics can be combined together, composed and modified by tacticals. Tacticals do not
correspond to any deduction rule but make the proof process smoother, and sometimes permit
the reuse of proofs with similar patterns, but where the fine minutiae might differ.

\begin{tactic}[t1; t2]{sequence}
  \begin{tsyntax}[empty]{t1; t2}
  Execute \ec{t1} and then \ec{t2} on all the subgoals generated by \ec{t1}.
  \end{tsyntax}
\end{tactic}

\begin{tactic}[try t]{failure recovery}
  \begin{tsyntax}[empty]{try t}
  Execute the tactic \ec{t} if it succeeds; do noting if it fails.

  \paragraph{Remark}
  By default, \EasyCrypt proofs are run in \ec{strict} mode. In this mode,
  \ec{smt} failures cannot be caught using \ec{try}. This allows \EasyCrypt
  to always build the proof tree correctly, even in weak check mode, where
  \ec{smt} calls are assumed to succeed. Inside a strict proof, weak check mode
  can be turned on and off at will, allowing for the fast replay of proof
  sections during development. In any event, we recommend \emph{never} using
  \ec{try smt}: a little thought is much more cost-effective than a bunch of
  \ec{smt}.
  \end{tsyntax}
\end{tactic}

\begin{tactic}[do! t]{tactic repetition}
  \begin{tsyntax}[empty]{do! t}
  Apply \ec{t} to the current goal, then repeatedly apply it to all subgoals,
  stopping only when it fails. An error is produced it \ec{t} does not apply to
  the current goal.
  \end{tsyntax}

  \paragraph{Variants}\strut\\

  \noindent\begin{tabularx}{\textwidth}{@{}ll@{}}
  {\ec{do ?t}} & apply {\ec{t}} 0 or more times, until it fails\\
  {\ec{do n !t}} & apply {\ec{t}} with depth exactly {\ec{n}}\\
  {\ec{do n ?t}} & apply {\ec{t}} with depth at most {\ec{n}}
  \end{tabularx}
\end{tactic}

\begin{tactic}[t1; first t2]{goal selection}
  \begin{tsyntax}[empty]{t1; first t2}
  Apply the tactic \ec{t1}, then apply \ec{t2} on the first subgoal
  generated by \ec{t1}. An error is produced if no subgoals have been
  generated by \ec{t1}.

  \paragraph{Variants}\strut\\

  \noindent\begin{tabularx}{\textwidth}{@{}ll@{}}
  {\ec{t1; first n t2}} & apply {\ec{t2}} on the first {\ec{n}} subgoals
    generated by {\ec{t1}}\\
  {\ec{t1; last t2}} & apply {\ec{t2}} on the last subgoal
    generated by {\ec{t1}}\\
  {\ec{t1; last n t2}} & apply {\ec{t2}} on the last {\ec{n}} subgoals
    generated by {\ec{t1}}\\
  {\ec{t; first n last}} & \parbox{200pt}{reorder the subgoals generated by {\ec{t}}, moving
    the first n to the end of the list}
  \end{tabularx}
  \end{tsyntax}
\end{tactic}

\begin{tactic}[by t]{closing goals}
  \begin{tsyntax}[empty]{by t}
  Apply the tactic \ec{t} and try to close all the generated subgoals using
  \rtactic{trivial}. Fail if not all subgoals can be closed.
  \end{tsyntax}
\end{tactic}

\subsection{Program Logics}

Judgments in the program logics may refer to procedures or
statements. Whenever the context allows both, we use $c$ (or \ec{c})
to denote programs, using $f$ (or \ec{f}) when only judgments on
procedures are allowed by the context, and $s$ (or \ec{s}) when only
judgments on statements are allowed.

\EasyCrypt includes three different program logics:
\begin{itemize}
\item \prhl, or probabilistic relational Hoare logic, with judgments of the form
%%
$$\pRHL{P}{c_1}{c_2}{Q}$$
%%
where $c_1$ and $c_2$ are programs, and $P$ and $Q$
are relations on memories.
\item \phl, or probabilistic Hoare logic, with judgments of the form
%%
$$\pHL{P}{c}{Q}{\diamond}{\delta}$$
%%
where $c$ is a program, $P$ and $Q$ are predicates on memories,
$\diamond\in\{\leq,\geq,=\}$ is a comparison relation and $\delta$ is
a real-valued expression, evaluated in the initial memory.
\item \hl, or (possibilistic) Hoare logic, with judgments of the form
%%
$$\HL{P}{c}{Q}$$
%%
where $c$ is a program, and $P$ and $Q$ are predicates on memories.
\end{itemize}

When $c$ is a procedure, preconditions ($P$ above) operate on memories
extended with a special $\Arg$ location that refers to the procedure's
arguments, and postcondition ($Q$ above) operate on memories extended
with a special $\Res$ location that refers to the procedure's return
value.

In the following, given a relation $R$, we denote with $\invrel{R}$
its inverse relation (that is,
%%
$m_1 \rel{R} m_2 \Leftrightarrow m_2 \rel{R^-1} m_1$).

We denote with $\diamond^{\uparrow}$ the function defined by
$$
\cdot^{\uparrow} =
\left\{\begin{array}{l @{\quad\mapsto\quad} r}
=    & \Leftrightarrow \\
\leq & \Leftarrow      \\
\geq & \Rightarrow
\end{array}\right.
$$

Given a predicate $P$, we denote with $\inmem{P}{1}$
(resp. $\inmem{P}{2}$) the relation defined by
%%
$m_1 \rel{\inmem{P}{1}} m_2 \Leftrightarrow P~m_1$
(resp. $m_1 \rel{\inmem{P}{2}} m_2 \Leftrightarrow P~m_2$).
We lift logical connectors to predicates and relations over memories
in the natural way.

TODO: define \ec{<spec>}, \ec{<lemma>}, \ec{<prhl>}, \ec{<phl>},
\ec{<hl>}.

\paragraph{Reasoning on Specifications}
\input{tactics/symmetry.tex}
\input{tactics/transitivity.tex}
\input{tactics/conseq.tex}
\input{tactics/case_pl.tex}
\input{tactics/phoare_split.tex}
\input{tactics/byequiv.tex}
\input{tactics/byphoare.tex}
\input{tactics/hoare.tex}
\input{tactics/bypr.tex}
\input{tactics/exfalso.tex}
%\input{tactics/pr_bounded.tex}

\paragraph{Reasoning on Programs}
Unless specified, the following program logic tactics operate on a
program's last instruction. Although we describe these tactics as if
they operated on single instructions, their practical implementation
automatically and implicitly applies tactic \rtactic{seq} to deal with
context when necessary.

For simple proofs, it is often enough to simply apply the program
tactic corresponding to the last instruction in the program and let
\ec{smt} deal with the verification condition once the program has
been exhausted.

Most of the program reasoning tactics discussed in this paragraph have
two modes when used on \prhl proof obligations. Their default mode is
to operate on both programs at once. When a side is specified (using
\ec{<tactic>\{1\}} or \ec{<tactic>\{2\}}), a one-sided variant is
used. Apart from the \rtactic{if} tactic, the one-sided variant is in
fact a combination of the \phl tactic and \rtactic{conseq}.

\medskip

\input{tactics/skip.tex}
\input{tactics/seq.tex}
\input{tactics/sp.tex}
\input{tactics/wp.tex}
\input{tactics/rnd.tex}
\input{tactics/if.tex}
\input{tactics/while.tex}
\input{tactics/call.tex}
\input{tactics/proc.tex}


\paragraph{Transforming Programs}
\input{tactics/swap.tex}
\input{tactics/inline.tex}

\input{tactics/rcondf.tex}
\input{tactics/rcondt.tex}

\input{tactics/splitwhile.tex}
\input{tactics/unroll.tex}
\input{tactics/fission.tex}
\input{tactics/fusion.tex}

\input{tactics/alias.tex}
\input{tactics/cfold.tex}
\input{tactics/kill.tex}
\input{tactics/modpath.tex}

\paragraph{Automated Tactics}
\input{tactics/auto.tex}
\input{tactics/sim.tex}

\paragraph{Advanced Tactics}
\input{tactics/eager.tex}
\input{tactics/fel.tex}

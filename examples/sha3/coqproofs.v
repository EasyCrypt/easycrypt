(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ZArith.
Require Import Rbase.
Require Import R_sqrt.
Require Import Rtrigo_def.
Require Import Rpower.
Require Import Rpower.
Require Import Rbasic_fun.
Parameter bitstring_n : Type.

Parameter bitstring_k : Type.

Inductive option (a:Type) :=
  | None : option a
  | Some : a -> option a.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.
Implicit Arguments Some.

Inductive list (a:Type) :=
  | Nil : list a
  | Cons : a -> (list a) -> list a.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.
Implicit Arguments Cons.

Set Implicit Arguments.
Fixpoint infix_plpl (a:Type)(l1:(list a)) (l2:(list a)) {struct l1}: (list
  a) :=
  match l1 with
  | Nil => l2
  | (Cons x1 r1) => (Cons x1 (infix_plpl r1 l2))
  end.
Unset Implicit Arguments.

Axiom Append_assoc : forall (a:Type), forall (l1:(list a)) (l2:(list a))
  (l3:(list a)), ((infix_plpl l1 (infix_plpl l2
  l3)) = (infix_plpl (infix_plpl l1 l2) l3)).

Axiom Append_l_nil : forall (a:Type), forall (l:(list a)), ((infix_plpl l
  (Nil:(list a))) = l).

Set Implicit Arguments.
Fixpoint length (a:Type)(l:(list a)) {struct l}: Z :=
  match l with
  | Nil => 0%Z
  | (Cons _ r) => (1%Z + (length r))%Z
  end.
Unset Implicit Arguments.

Axiom Length_nonnegative : forall (a:Type), forall (l:(list a)),
  (0%Z <= (length l))%Z.

Axiom Length_nil : forall (a:Type), forall (l:(list a)),
  ((length l) = 0%Z) <-> (l = (Nil:(list a))).

Axiom Append_length : forall (a:Type), forall (l1:(list a)) (l2:(list a)),
  ((length (infix_plpl l1 l2)) = ((length l1) + (length l2))%Z).

Set Implicit Arguments.
Fixpoint mem (a:Type)(x:a) (l:(list a)) {struct l}: Prop :=
  match l with
  | Nil => False
  | (Cons y r) => (x = y) \/ (mem x r)
  end.
Unset Implicit Arguments.

Axiom mem_append : forall (a:Type), forall (x:a) (l1:(list a)) (l2:(list a)),
  (mem x (infix_plpl l1 l2)) <-> ((mem x l1) \/ (mem x l2)).

Axiom mem_decomp : forall (a:Type), forall (x:a) (l:(list a)), (mem x l) ->
  exists l1:(list a), exists l2:(list a), (l = (infix_plpl l1 (Cons x l2))).

Definition log2(x:R): R := (Rdiv (ln x) (ln 2%R))%R.

Definition log10(x:R): R := (Rdiv (ln x) (ln 10%R))%R.

Parameter pow: R -> R -> R.


Axiom Pow_zero_y : forall (y:R), (~ (y = 0%R)) -> ((pow 0%R y) = 0%R).

Axiom Pow_x_zero : forall (x:R), (~ (x = 0%R)) -> ((pow x 0%R) = 1%R).

Axiom Pow_x_one : forall (x:R), ((pow x 1%R) = x).

Axiom Pow_one_y : forall (y:R), ((pow 1%R y) = 1%R).

Axiom Pow_x_two : forall (x:R), ((pow x 2%R) = (Rsqr x)).

Axiom Pow_half : forall (x:R), (0%R <= x)%R -> ((pow x
  (05 / 10)%R) = (sqrt x)).

Axiom Pow_exp_log : forall (x:R) (y:R), (0%R <  x)%R -> ((pow x
  y) = (exp (y * (ln x))%R)).

Axiom Abs_le : forall (x:Z) (y:Z), ((Zabs x) <= y)%Z <-> (((-y)%Z <= x)%Z /\
  (x <= y)%Z).

Parameter power: Z -> Z -> Z.


Axiom Power_0 : forall (x:Z), ((power x 0%Z) = 1%Z).

Axiom Power_s : forall (x:Z) (n:Z), (0%Z <= n)%Z -> ((power x
  (n + 1%Z)%Z) = (x * (power x n))%Z).

Axiom Power_1 : forall (x:Z), ((power x 1%Z) = x).

Axiom Power_sum : forall (x:Z) (n:Z) (m:Z), ((0%Z <= n)%Z /\ (0%Z <= m)%Z) ->
  ((power x (n + m)%Z) = ((power x n) * (power x m))%Z).

Axiom Power_mult : forall (x:Z) (n:Z) (m:Z), (0%Z <= n)%Z -> ((0%Z <= m)%Z ->
  ((power x (n * m)%Z) = (power (power x n) m))).

Parameter div: Z -> Z -> Z.


Parameter mod1: Z -> Z -> Z.


Axiom Div_mod : forall (x:Z) (y:Z), (~ (y = 0%Z)) -> (x = ((y * (div x
  y))%Z + (mod1 x y))%Z).

Axiom Div_bound : forall (x:Z) (y:Z), ((0%Z <= x)%Z /\ (0%Z <  y)%Z) ->
  ((0%Z <= (div x y))%Z /\ ((div x y) <= x)%Z).

Axiom Mod_bound : forall (x:Z) (y:Z), (~ (y = 0%Z)) -> ((0%Z <= (mod1 x
  y))%Z /\ ((mod1 x y) <  (Zabs y))%Z).

Axiom Mod_1 : forall (x:Z), ((mod1 x 1%Z) = 0%Z).

Axiom Div_1 : forall (x:Z), ((div x 1%Z) = x).

Parameter map : forall (qta:Type) (qtb:Type), Type.

Parameter real_of_bool: bool -> R.


Parameter upd_map: forall (qta:Type) (qtb:Type), (map qta qtb) -> qta
  -> qtb -> (map qta qtb).

Implicit Arguments upd_map.

Parameter get_map: forall (qta:Type) (qtb:Type), (map qta qtb) -> qta -> qtb.

Implicit Arguments get_map.

Parameter in_dom_map: forall (qta:Type) (qtb:Type), qta -> (map qta qtb) ->
  Prop.

Implicit Arguments in_dom_map.

Parameter in_rng_map: forall (qta:Type) (qtb:Type), qtb -> (map qta qtb) ->
  Prop.

Implicit Arguments in_rng_map.

Definition fst (qta:Type) (qtb:Type)(p:(qta* qtb)%type): qta :=
  match p with
  | (a, b) => a
  end.
Implicit Arguments fst.

Definition snd (qta:Type) (qtb:Type)(p:(qta* qtb)%type): qtb :=
  match p with
  | (a, b) => b
  end.
Implicit Arguments snd.

Parameter proj: forall (qta:Type), (option qta) -> qta.

Implicit Arguments proj.

Parameter hd: forall (qta:Type), (list qta) -> qta.

Implicit Arguments hd.

Parameter tl: forall (qta:Type), (list qta) -> (list qta).

Implicit Arguments tl.

Parameter empty_map: forall (qta:Type) (qtb:Type), (map qta qtb).

Set Contextual Implicit.
Implicit Arguments empty_map.
Unset Contextual Implicit.

Parameter k: Z.


Parameter n: Z.


Parameter q: Z.


Parameter xor_bs_k: bitstring_k -> bitstring_k -> bitstring_k.


Parameter bs0_k: bitstring_k.


Definition block  := bitstring_k.

Parameter xor_bs_n: bitstring_n -> bitstring_n -> bitstring_n.


Parameter bs0_n: bitstring_n.


Definition state  := bitstring_n.

Definition msg  := (list bool).

Definition padding  := (list bitstring_k).

Definition fmap  := (map (bitstring_k* bitstring_n)%type bitstring_n).

Definition chain  := (list (bitstring_k* bitstring_n)%type).

Parameter IV: bitstring_n.


Definition injective (qta:Type) (qtb:Type)(T:(map qta qtb)): Prop :=
  forall (x:qta) (y:qta), (in_dom_map x T) -> ((in_dom_map y T) ->
  (((get_map T x) = (get_map T y)) -> (x = y))).
Implicit Arguments injective.

Definition injective_fst (qta:Type) (qta1:Type) (qtb:Type)(I:(map qta1 (qta*
  qtb)%type)): Prop := forall (x:qta1) (y:qta1), (in_dom_map x I) ->
  ((in_dom_map y I) -> (((fst (get_map I x)) = (fst (get_map I y))) ->
  (x = y))).
Implicit Arguments injective_fst.

Definition inclusion (qta:Type) (qtb:Type)(Tqt:(map qta qtb)) (T:(map qta
  qtb)): Prop := (forall (x:qta), (in_dom_map x Tqt) -> (in_dom_map x T)) /\
  forall (x:qta), (in_dom_map x Tqt) -> ((get_map Tqt x) = (get_map T x)).
Implicit Arguments inclusion.

Definition inverse (qta:Type) (qtb:Type)(T:(map qta qtb)) (Tqt:(map qtb
  qta)): Prop := (forall (x:qta), (in_dom_map x T) -> ((in_dom_map (get_map T
  x) Tqt) /\ ((get_map Tqt (get_map T x)) = x))) /\ forall (y:qtb),
  (in_dom_map y Tqt) -> ((in_dom_map (get_map Tqt y) T) /\ ((get_map T
  (get_map Tqt y)) = y)).
Implicit Arguments inverse.

Definition ext_eq (qta:Type) (qtb:Type)(T1:(map qta qtb)) (T2:(map qta
  qtb)): Prop := (forall (a:qta), (in_dom_map a T1) <-> (in_dom_map a T2)) /\
  forall (a:qta), (in_dom_map a T1) -> ((get_map T1 a) = (get_map T2 a)).
Implicit Arguments ext_eq.

Parameter pad: (list bool) -> (list bitstring_k).


Parameter unpad: (list bitstring_k) -> (option (list bool)).


Parameter mapfst: (list (bitstring_k* bitstring_n)%type) -> (list
  bitstring_k).


Parameter ischained: (map (bitstring_k* bitstring_n)%type bitstring_n)
  -> bitstring_n -> (list (bitstring_k* bitstring_n)%type) -> bitstring_n ->
  Prop.


Parameter findseq: bitstring_k -> bitstring_n -> (map (bitstring_k*
  bitstring_n)%type bitstring_n) -> (option (list (bitstring_k*
  bitstring_n)%type)).


Definition valid_chain(c:(list (bitstring_k* bitstring_n)%type)) (T:(map
  (bitstring_k* bitstring_n)%type bitstring_n)): Prop :=
  exists z:bitstring_n, (ischained T IV c z) /\
  ~ ((unpad (mapfst c)) = (None:(option (list bool)))).

Parameter set_bad3: bitstring_n -> (map (bitstring_k* bitstring_n)%type
  bitstring_n) -> (map (bitstring_k* bitstring_n)%type bitstring_n) -> (map
  bitstring_n (bitstring_k* bitstring_n)%type) -> Prop.


Definition claim5(Tqt:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (T:(map (bitstring_k* bitstring_n)%type bitstring_n)): Prop :=
  forall (xqt:bitstring_k) (yqt:bitstring_n) (x:bitstring_k), (in_dom_map (
  xqt, yqt) T) -> ((in_dom_map (x, (get_map T (xqt, yqt))) Tqt) ->
  (((findseq xqt yqt T) = (None:(option (list (bitstring_k*
  bitstring_n)%type)))) -> (in_dom_map (xqt, yqt) Tqt))).

Definition ROmapinT(ROmap:(map (list bool) (bitstring_n* Z)%type)) (T:(map
  (bitstring_k* bitstring_n)%type bitstring_n)): Prop := (forall (m:(list
  bool)), (in_dom_map m ROmap) -> exists x:bitstring_k, exists y:bitstring_n,
  (~ ((findseq x y T) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))) /\
  ((m = (proj (unpad (mapfst (infix_plpl (proj (findseq x y T)) (Cons (x, y)
  (Nil:(list (bitstring_k* bitstring_n)%type)))))))) /\ (in_dom_map (x, y)
  T))) /\ ((forall (x:bitstring_k) (y:bitstring_n), (~ ((findseq x y
  T) = (None:(option (list (bitstring_k* bitstring_n)%type))))) ->
  ((in_dom_map (proj (unpad (mapfst (infix_plpl (proj (findseq x y T))
  (Cons (x, y) (Nil:(list (bitstring_k* bitstring_n)%type))))))) ROmap) ->
  (in_dom_map (x, y) T))) /\ forall (x:bitstring_k) (y:bitstring_n),
  (~ ((findseq x y T) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))) -> ((in_dom_map (x, y) T) ->
  ((in_dom_map (proj (unpad (mapfst (infix_plpl (proj (findseq x y T))
  (Cons (x, y) (Nil:(list (bitstring_k* bitstring_n)%type))))))) ROmap) /\
  ((fst (get_map ROmap (proj (unpad (mapfst (infix_plpl (proj (findseq x y
  T)) (Cons (x, y) (Nil:(list (bitstring_k*
  bitstring_n)%type))))))))) = (get_map T (x, y)))))).

Definition Inv_exists(icount:Z) (I:(map Z (bitstring_n* bool)%type))
  (Yadv:(list bitstring_n)): Prop := exists i:Z, (0%Z <= i)%Z /\
  ((i <  icount)%Z /\ (((snd (get_map I i)) = true) /\ (mem (fst (get_map I
  i)) Yadv))).

Axiom Some_inj : forall (qta:Type), forall (x:qta) (y:qta),
  ((Some x) = (Some y)) -> (x = y).

Axiom Proj_Some : forall (qta:Type), forall (x:qta), ((proj (Some x)) = x).

Axiom Proj_eq : forall (qta:Type), forall (o1:(option qta)) (o2:(option
  qta)), (~ (o1 = (None:(option qta)))) -> ((~ (o2 = (None:(option qta)))) ->
  (((proj o1) = (proj o2)) -> (o1 = o2))).

Axiom Some_or_None : forall (qta:Type), forall (o:(option qta)),
  (o = (None:(option qta))) \/ exists x:qta, (o = (Some x)).

Axiom head_def : forall (qta:Type), forall (a:qta) (l:(list qta)),
  ((hd (Cons a l)) = a).

Axiom tail_def : forall (qta:Type), forall (a:qta) (l:(list qta)),
  ((tl (Cons a l)) = l).

Axiom get_upd_map_same : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a1:qta) (a2:qta) (b:qtb), (a1 = a2) -> ((get_map (upd_map m a1 b)
  a2) = b).

Axiom get_upd_map_diff : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a1:qta) (a2:qta) (b:qtb), (~ (a1 = a2)) -> ((get_map (upd_map m a1
  b) a2) = (get_map m a2)).

Axiom upd_map_comm : forall (qtb:Type) (qta:Type), forall (m:(map qta qtb))
  (a:qta) (aqt:qta) (b:qtb) (bqt:qtb), (~ (a = aqt)) -> ((upd_map (upd_map m
  a b) aqt bqt) = (upd_map (upd_map m aqt bqt) a b)).

Axiom upd_in_dom_same : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a:qta) (aqt:qta) (b:qtb), (a = aqt) -> (in_dom_map aqt (upd_map m a
  b)).

Axiom upd_in_dom_diff : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a:qta) (aqt:qta) (b:qtb), (~ (a = aqt)) -> ((in_dom_map aqt
  (upd_map m a b)) <-> (in_dom_map aqt m)).

Axiom upd_in_rng_same : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a:qta) (b:qtb) (bqt:qtb), (b = bqt) -> (in_rng_map bqt (upd_map m a
  b)).

Axiom upd_in_rng_diff : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a:qta) (b:qtb) (bqt:qtb), (~ (b = bqt)) -> ((in_rng_map bqt
  (upd_map m a b)) <-> (in_rng_map bqt m)).

Axiom in_dom_in_rng : forall (qta:Type) (qtb:Type), forall (m:(map qta qtb))
  (a:qta), (in_dom_map a m) -> (in_rng_map (get_map m a) m).

Axiom in_rng_in_dom : forall (qtb:Type) (qta:Type), forall (m:(map qta qtb))
  (b:qtb), (in_rng_map b m) -> exists a:qta, (in_dom_map a m) /\ ((get_map m
  a) = b).

Axiom empty_in_dom : forall (qta:Type) (qtb:Type) (qtb1:Type),
  forall (a:qta), ~ (in_dom_map a (empty_map:(map qta qtb1))).

Axiom empty_in_rng : forall (qtb:Type) (qta:Type) (qta1:Type),
  forall (b:qtb), ~ (in_rng_map b (empty_map:(map qta1 qtb))).

Axiom real_of_bool_true : ((real_of_bool true) = (IZR 1%Z)).

Axiom real_of_bool_false : ((real_of_bool false) = (IZR 0%Z)).

Axiom real_of_int_le_compat : forall (x:Z) (y:Z), (x <= y)%Z ->
  ((IZR x) <= (IZR y))%R.

Axiom real_of_int_lt_compat : forall (x:Z) (y:Z), (x <  y)%Z ->
  ((IZR x) <  (IZR y))%R.

Axiom rmult_le_compat_l : forall (x:R) (y:R) (z:R), ((IZR 0%Z) <= x)%R ->
  ((y <= z)%R -> ((x * y)%R <= (x * z)%R)%R).

Axiom rmult_le_compat_r : forall (x:R) (y:R) (z:R), ((IZR 0%Z) <= z)%R ->
  ((x <= y)%R -> ((x * z)%R <= (y * z)%R)%R).

Axiom rmul_plus_distr_r : forall (x:R) (y:R) (z:R),
  (((x + y)%R * z)%R = ((x * z)%R + (y * z)%R)%R).

Axiom rdiv_le_compat : forall (x1:R) (x2:R) (y1:R) (y2:R),
  ((IZR 0%Z) <  y2)%R -> ((y2 <= y1)%R -> (((IZR 0%Z) <= x1)%R ->
  ((x1 <= x2)%R -> ((Rdiv x1 y1)%R <= (Rdiv x2 y2)%R)%R))).

Axiom rdiv_0_le : forall (x:R) (y:R), ((IZR 0%Z) <  y)%R ->
  (((IZR 0%Z) <= x)%R -> ((IZR 0%Z) <= (Rdiv x y)%R)%R).

Axiom pow2_pos : forall (n1:Z), (0%Z <= n1)%Z -> (0%Z <  (power 2%Z n1))%Z.

Axiom xor_k_comm : forall (x:bitstring_k) (y:bitstring_k), ((xor_bs_k x
  y) = (xor_bs_k y x)).

Axiom xor_k_assoc : forall (x:bitstring_k) (y:bitstring_k) (z:bitstring_k),
  ((xor_bs_k (xor_bs_k x y) z) = (xor_bs_k x (xor_bs_k y z))).

Axiom xor_k_zero_r : forall (x:bitstring_k), ((xor_bs_k x bs0_k) = x).

Axiom xor_k_cancel : forall (x:bitstring_k), ((xor_bs_k x x) = bs0_k).

Axiom xor_n_comm : forall (x:bitstring_n) (y:bitstring_n), ((xor_bs_n x
  y) = (xor_bs_n y x)).

Axiom xor_n_assoc : forall (x:bitstring_n) (y:bitstring_n) (z:bitstring_n),
  ((xor_bs_n (xor_bs_n x y) z) = (xor_bs_n x (xor_bs_n y z))).

Axiom xor_n_zero_r : forall (x:bitstring_n), ((xor_bs_n x bs0_n) = x).

Axiom xor_n_cancel : forall (x:bitstring_n), ((xor_bs_n x x) = bs0_n).

Axiom q_pos : (0%Z <  q)%Z.

Axiom n_pos : (0%Z <  n)%Z.

Axiom unpad_pad : forall (m:(list bool)), ((unpad (pad m)) = (Some m)).

Axiom unpad_nil : ((unpad (Nil:(list bitstring_k))) = (None:(option (list
  bool)))).

Axiom unpad_ex_pad : forall (p:(list bitstring_k)),
  (~ ((unpad p) = (None:(option (list bool))))) -> exists m:(list bool),
  (p = (pad m)).

Axiom unpad_inj : forall (x:(list bitstring_k)) (y:(list bitstring_k)),
  ((unpad x) = (unpad y)) -> ((~ ((unpad x) = (None:(option (list
  bool))))) -> (x = y)).

Axiom prefixfree : forall (m1:(list bool)) (m2:(list bool)) (bl:(list
  bitstring_k)), (~ (m1 = m2)) -> ~ ((pad m1) = (infix_plpl (pad m2) bl)).

Axiom mapfst_nil : ((mapfst (Nil:(list (bitstring_k*
  bitstring_n)%type))) = (Nil:(list bitstring_k))).

Axiom mapfst_cons : forall (x:bitstring_k) (y:bitstring_n) (c:(list
  (bitstring_k* bitstring_n)%type)), ((mapfst (Cons (x, y) c)) = (Cons x
  (mapfst c))).

Axiom ischained_nil : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (y:bitstring_n) (z:bitstring_n), (ischained T y (Nil:(list
  (bitstring_k* bitstring_n)%type)) z) <-> (y = z).

Axiom ischained_cons : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (y:bitstring_n) (xy:(bitstring_k* bitstring_n)%type)
  (z:bitstring_n), (ischained T y (Cons xy (Nil:(list (bitstring_k*
  bitstring_n)%type))) z) <-> ((in_dom_map xy T) /\ ((y = (snd xy)) /\
  ((get_map T xy) = z))).

Axiom ischained_conscons : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (xy:(bitstring_k* bitstring_n)%type) (y:bitstring_n)
  (xyqt:(bitstring_k* bitstring_n)%type) (c:(list (bitstring_k*
  bitstring_n)%type)) (z:bitstring_n), (ischained T y (Cons xy (Cons xyqt c))
  z) <-> ((in_dom_map xy T) /\ ((y = (snd xy)) /\ (((get_map T
  xy) = (snd xyqt)) /\ (ischained T (snd xyqt) (Cons xyqt c) z)))).

Axiom findseq_ischained : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (x:bitstring_k) (y:bitstring_n), (~ ((findseq x y
  T) = (None:(option (list (bitstring_k* bitstring_n)%type))))) ->
  (ischained T IV (proj (findseq x y T)) y).

Axiom findseq_unpad : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (x:bitstring_k) (y:bitstring_n), (~ ((findseq x y
  T) = (None:(option (list (bitstring_k* bitstring_n)%type))))) ->
  ~ ((unpad (mapfst (infix_plpl (proj (findseq x y T)) (Cons (x, y)
  (Nil:(list (bitstring_k* bitstring_n)%type)))))) = (None:(option (list
  bool)))).

Axiom findseq_complete : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (x:bitstring_k) (y:bitstring_n) (c:(list (bitstring_k*
  bitstring_n)%type)), (injective T) -> ((~ (in_rng_map IV T)) ->
  ((ischained T IV c y) -> ((~ ((unpad (mapfst (infix_plpl c (Cons (x, y)
  (Nil:(list (bitstring_k* bitstring_n)%type)))))) = (None:(option (list
  bool))))) -> ~ ((findseq x y T) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))))).

Axiom set_bad3_def : forall (z:bitstring_n) (Tqt:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (invT:(map bitstring_n (bitstring_k* bitstring_n)%type)),
  (set_bad3 z Tqt T invT) <-> ((in_dom_map z invT) /\
  ((~ (in_dom_map (get_map invT z) Tqt)) /\ forall (c:(list (bitstring_k*
  bitstring_n)%type)), ~ (valid_chain (infix_plpl c (Cons (get_map invT z)
  (Nil:(list (bitstring_k* bitstring_n)%type)))) T))).

Axiom eq_ext_eq : forall (qta:Type) (qtb:Type), forall (T1:(map qta qtb))
  (T2:(map qta qtb)), (ext_eq T1 T2) <-> (T1 = T2).

Axiom hd_tl : forall (qta:Type), forall (l:(list qta)), (~ (l = (Nil:(list
  qta)))) -> ((Cons (hd l) (tl l)) = l).

Axiom tl_length : forall (qta:Type), forall (l:(list qta)),
  (~ (l = (Nil:(list qta)))) -> ((length (tl l)) = ((length l) - 1%Z)%Z).

Axiom length0 : forall (qta:Type), forall (l:(list qta)),
  ((length l) = 0%Z) -> (l = (Nil:(list qta))).

Axiom length_tl_notnil : forall (qta:Type), forall (l:(list qta)),
  ((~ (l = (Nil:(list qta)))) /\ ~ ((tl l) = (Nil:(list qta)))) <->
  (1%Z <  (length l))%Z.

Axiom hd_length_one : forall (qta:Type), forall (l:(list qta)),
  (~ (l = (Nil:(list qta)))) -> (((length l) <= 1%Z)%Z -> (l = (Cons (hd l)
  (Nil:(list qta))))).

Axiom append_same_nil : forall (qta:Type), forall (l1:(list qta)) (l2:(list
  qta)), ((infix_plpl l1 l2) = l1) -> (l2 = (Nil:(list qta))).

Axiom app_nil_end : forall (qta:Type), forall (l:(list qta)), ((infix_plpl l
  (Nil:(list qta))) = l).

Axiom app_cons_nil : forall (qta:Type), forall (a:qta) (l:(list qta)),
  ((infix_plpl (Cons a (Nil:(list qta))) l) = (Cons a l)).

Theorem exists_last : forall (qta:Type), forall (l:(list qta)),
  (l = (Nil:(list qta))) \/ exists x:qta, exists lqt:(list qta),
  (l = (infix_plpl lqt (Cons x (Nil:(list qta))))).
Proof with reflexivity.
intros T c.
apply list_ind with (l := c).
 (* base case, l = [] *)
 left...
 (* induction step, l = a::al *)
 intros a al IH.
 destruct IH as [e|(al',(b,e))]; subst.
  (* case al = [] *)
  right. exists a, Nil.
  simpl...
  (* case  al = al'@b::[] *)
  right. exists al', (Cons a b).
  simpl...
Qed.

Theorem app_inj_tl : forall (qta:Type), forall (l1:(list qta)) (l2:(list
  qta)) (x1:qta) (x2:qta), ((infix_plpl l1 (Cons x1 (Nil:(list
  qta)))) = (infix_plpl l2 (Cons x2 (Nil:(list qta))))) -> ((l1 = l2) /\
  (x1 = x2)).
Proof.
intros T l1 l2 x1 x2.
generalize l2; clear l2.
apply list_ind with (l := l1).
 (* l1 = [] *)
 simpl. intros.
 destruct l2 as [_ |b bl].
  (* l2 = [] *)
  inversion H. intuition.
  (* l2 = b::bl *)
  apply False_ind. simpl in H.
  inversion H.
  destruct bl; inversion H2.
 (* l1 = a::al *)
 intros a al IH l2 H.
 destruct l2 as [ _ | b bl ].
  (* l2 = [] *)
  destruct al; inversion H.
  (* l2 = b::bl *)
  simpl in H.
  inversion H.
  apply IH in H2.
  destruct H2.
  rewrite H0.
  intuition.
Qed.

Lemma cons_app_swap : forall (qta:Type), forall (x:qta) (l:(list qta)),
  exists xqt:qta, exists lqt:(list qta), ((Cons x l) = (infix_plpl lqt
  (Cons xqt (Nil:(list qta))))).
Proof.
  intros T a al. generalize a; clear a.
  apply list_ind with (l := al).
   (* case al = [] *)
   intros. exists a, Nil. simpl. reflexivity.
   (* case al = a'::al' *)
   intros a' al' IH a.
   specialize (IH a'). destruct IH as (x,(xl,H)). 
   exists x. exists (Cons a xl).
   rewrite H. simpl. reflexivity.
Qed.

Axiom append_cons : forall (qta:Type), forall (x:qta) (xs:(list qta))
  (l:(list qta)), ((infix_plpl (Cons x xs) l) = (Cons x (infix_plpl xs l))).

Axiom append_nil : forall (qta:Type), forall (l:(list qta)),
  ((infix_plpl (Nil:(list qta)) l) = l).

Axiom last_in : forall (qta:Type), forall (l:(list qta)) (x:qta), (mem x
  (infix_plpl l (Cons x (Nil:(list qta))))).

Axiom in_split : forall (qta:Type), forall (l:(list qta)) (x:qta), (mem x
  l) -> exists l1:(list qta), exists l2:(list qta),
  (l = (infix_plpl (infix_plpl l1 (Cons x (Nil:(list qta)))) l2)).

Axiom in_dom_upd_map : forall (qtb:Type) (qta:Type), forall (m:(map qta qtb))
  (a:qta) (aqt:qta) (b:qtb), (in_dom_map aqt (upd_map m a b)) <->
  ((a = aqt) \/ (in_dom_map aqt m)).

Axiom in_dom_upd_map_excl : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a:qta) (aqt:qta) (b:qtb), (in_dom_map aqt (upd_map m a b)) <->
  ((a = aqt) \/ ((~ (a = aqt)) /\ (in_dom_map aqt m))).

Axiom inclusion_injective : forall (qta:Type) (qtb:Type), forall (T:(map qta
  qtb)) (Tqt:(map qta qtb)), (inclusion Tqt T) -> ((injective T) ->
  (injective Tqt)).

Axiom inclusion_upd : forall (qta:Type) (qtb:Type), forall (T:(map qta qtb))
  (Tqt:(map qta qtb)) (a:qta), (inclusion Tqt T) -> ((in_dom_map a T) ->
  (inclusion Tqt (upd_map Tqt a (get_map T a)))).

Axiom inclusion_updqt : forall (qta:Type) (qtb:Type), forall (T:(map qta
  qtb)) (Tqt:(map qta qtb)) (a:qta), (inclusion Tqt T) -> ((in_dom_map a
  T) -> (inclusion (upd_map Tqt a (get_map T a)) T)).

Axiom inclusion_updqtqt : forall (qtb:Type) (qta:Type), forall (T:(map qta
  qtb)) (Tqt:(map qta qtb)) (a:qta) (b:qtb), (inclusion Tqt T) ->
  (inclusion (upd_map Tqt a b) (upd_map T a b)).

Axiom inclusion_not_rng : forall (qtb:Type) (qta:Type), forall (T:(map qta
  qtb)) (Tqt:(map qta qtb)) (b:qtb), (inclusion Tqt T) -> ((~ (in_rng_map b
  T)) -> ~ (in_rng_map b Tqt)).

Axiom not_rng_upd : forall (qtb:Type) (qta:Type), forall (T:(map qta qtb))
  (a:qta) (b:qtb) (bqt:qtb), (~ (in_rng_map bqt T)) -> ((~ (b = bqt)) ->
  ~ (in_rng_map bqt (upd_map T a b))).

Axiom injective_upd : forall (qtb:Type) (qta:Type), forall (T:(map qta qtb))
  (a:qta) (b:qtb), (~ (in_rng_map b T)) -> ((injective T) ->
  (injective (upd_map T a b))).

Axiom inverse_dom_rng : forall (qtb:Type) (qta:Type), forall (T:(map qta
  qtb)) (invT:(map qtb qta)) (b:qtb), (inverse T invT) -> ((in_dom_map b
  invT) -> (in_rng_map b T)).

Axiom inverse_rng_dom : forall (qtb:Type) (qta:Type), forall (T:(map qta
  qtb)) (invT:(map qtb qta)) (b:qtb), (inverse T invT) -> ((in_rng_map b
  T) -> (in_dom_map b invT)).

Axiom prefixfreeqt : forall (p1:(list bitstring_k)) (p2:(list bitstring_k)),
  (~ ((unpad (infix_plpl p1 p2)) = (None:(option (list bool))))) ->
  ((~ (p2 = (Nil:(list bitstring_k)))) -> ((unpad p1) = (None:(option (list
  bool))))).

Theorem unpad_tl_prefix : forall (ms:(list bitstring_k)) (c:(list
  bitstring_k)), (2%Z <  (length ms))%Z -> ((~ ((unpad (infix_plpl c
  ms)) = (None:(option (list bool))))) -> ((unpad (infix_plpl (infix_plpl c
  (Cons (hd ms) (Nil:(list bitstring_k)))) (Cons (hd (tl ms)) (Nil:(list
  bitstring_k))))) = (None:(option (list bool))))).
Proof.
intros ms c.
intros Hlen Hpad.
simpl.
destruct ms as [_|a al].
 (* case ms = [] *)
   clear - Hlen. apply False_ind. simpl in Hlen. omega. 
 (* case ms = a::al *)
 destruct al as [_|a' al'].
  (* case al = [] *)
   clear - Hlen. apply False_ind. simpl in Hlen. omega.
  (* case al = a'::al' *)
  destruct al' as [_|a'' al''].
   (* case al' = [] *)
   clear - Hlen. apply False_ind. simpl in Hlen. omega. 
   (* case al' = a''::al'' *)
   clear - Hpad. rewrite tail_def. repeat rewrite head_def.
   eapply prefixfreeqt. instantiate (1 := Cons a'' al'').
   (* unpad .. <> None *)
   repeat rewrite <- Append_assoc. simpl.  assumption.
   (* a''::al'' <> Nil *)
   clear. intro C. inversion C. 
Qed.

Theorem mapfst_app : forall (c1:(list (bitstring_k* bitstring_n)%type))
  (c2:(list (bitstring_k* bitstring_n)%type)), ((mapfst (infix_plpl c1
  c2)) = (infix_plpl (mapfst c1) (mapfst c2))).
Proof.
intros c1 c2.
apply list_ind with (l := c1).
 (* base case, c1 = [] *)
 rewrite mapfst_nil. simpl. reflexivity.
 (* induction step, c1 = a::al *)
 intros a al. intro IH.
 destruct a as (a1,a2).
 simpl. repeat rewrite mapfst_cons. simpl.
 rewrite IH.
 reflexivity.
Qed.

Axiom ischained_lasteq : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (xy:(bitstring_k* bitstring_n)%type) (y:bitstring_n) (c:(list
  (bitstring_k* bitstring_n)%type)) (z:bitstring_n), (ischained T y (Cons xy
  c) z) -> (y = (snd xy)).




Theorem ischained_app : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Y:bitstring_n) (xy:(bitstring_k* bitstring_n)%type)
  (S:bitstring_n) (c1:(list (bitstring_k* bitstring_n)%type)) (c2:(list
  (bitstring_k* bitstring_n)%type)), ((ischained T Y c1 (snd xy)) /\
  ((in_dom_map xy T) /\ (ischained T (get_map T xy) c2 S))) <-> (ischained T
  Y (infix_plpl c1 (Cons xy c2)) S).
Proof.
intros T Y xy Z c1 c2.
split.

 (* -> *)
 intuition.
 generalize Y H0; clear Y H0.
 apply list_ind with (l := c1).
  (* base case, c1 = [] *)
  intros. simpl. 
  rewrite ischained_nil in H0. subst.
  destruct c2 as [|xy' c2'].
   (* case c2 = [] *)
   rewrite ischained_cons.
   rewrite ischained_nil in H2. auto.
   (* case c2 = xy'::c2' *)
   rewrite ischained_conscons.
   rewrite <- (ischained_lasteq _ _ _ _ _ H2). auto.
  (* induction step, c1 = a::c1' *)
  intros a c1'. intro IH. intros.
  destruct c1' as [|b c1''].
   (* case c1' = [] *)
   specialize (IH (snd xy)).
   simpl in *.
   rewrite (ischained_lasteq _ _ _ _ _ H0). rewrite (ischained_lasteq _ _ _ _ _ H0) in H0.
   rewrite ischained_nil in IH. rewrite ischained_cons in H0. rewrite ischained_conscons.
   tauto.
   (* case c1' = b::c1'' *)
   specialize (IH (snd b)).
   simpl in *.
   rewrite (ischained_lasteq _ _ _ _ _ H0). rewrite (ischained_lasteq _ _ _ _ _ H0) in H0.
   rewrite ischained_conscons in *.
   tauto.

 (* <- *)
 generalize Y; clear Y. 
 apply list_ind with (l := c1).
  (* base case, c1 = [] *)
  intros. simpl in H.
  rewrite ischained_nil.
  destruct c2 as [|xy' c2'].
   (* case c2 = [] *)
   apply ischained_cons in H. intuition.
   rewrite ischained_nil. assumption.
   (* case c2 = xy'::c2' *)
   rewrite ischained_conscons in H. intuition.
   rewrite H1. assumption.
  (* induction step, c1 = a::c1' *)
  intros a c1'. intro IH. intros.
  destruct c1' as [|b c1''].
   (* case c1' = [] *)
   specialize (IH (snd xy)).
   simpl in *.
   rewrite (ischained_lasteq _ _ _ _ _ H). rewrite (ischained_lasteq _ _ _ _ _ H) in H.
   rewrite ischained_nil in IH. rewrite ischained_conscons in H. rewrite ischained_cons.
   tauto.
   (* case c1' = b::c1'' *)
   specialize (IH (snd b)).
   simpl in *.
   rewrite (ischained_lasteq _ _ _ _ _ H). rewrite (ischained_lasteq _ _ _ _ _ H) in H.
   rewrite ischained_conscons in *. tauto.
Qed.

Theorem ischained_same_length : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (Y1:bitstring_n) (Y2:bitstring_n) (c1:(list
  (bitstring_k* bitstring_n)%type)) (c2:(list (bitstring_k*
  bitstring_n)%type)) (z:bitstring_n), ((length c1) = (length c2)) ->
  ((injective T) -> ((ischained T Y1 c1 z) -> ((ischained T Y2 c2 z) ->
  (c1 = c2)))).
Proof.
intros T Y1 Y2 c1 c2 z.
intros Heq HB2 Hch1 Hch2.
generalize Hch1 Heq; clear Hch1 Heq.
generalize Hch2; clear Hch2.
generalize c2 Y1 Y2; clear c2 Y1 Y2.
apply list_ind with (l := c1).

 (* base case, c1 = [] *)
 intros.
 destruct c2 as [|b bl].
  (* case c2 = [] *)
  reflexivity.
  (* case c2 = b::bl *)
  apply False_ind. clear - Heq.
  unfold length in Heq. fold length in Heq.
  remember (Length_nonnegative _ bl); omega.

 (* induction step, c1 = a::al *)
 intros a al. intros IH. intros.
 destruct c2 as [|b bl].
  (* case c2 = [] *)
  apply False_ind. clear - Heq.
  unfold length in Heq. fold length in Heq.
  remember (Length_nonnegative _ al); omega.

  (* case c2 = b::bl *)
  specialize (IH bl).
  assert (length al = length bl) as Heq'; [unfold length in Heq; fold length in Heq;omega|].
  clear Heq; rename Heq' into Heq.
  assert (forall (x:prod bitstring_k bitstring_n) xl, (Cons x xl) = (infix_plpl Nil (Cons x xl))).
   clear. intros. simpl. reflexivity.
  rewrite H in Hch1, Hch2; clear H.
  rewrite <- ischained_app in Hch1, Hch2.
  destruct Hch1 as (_,(Hdoma,Hch1)). destruct Hch2 as (_,(Hdomb,Hch2)).
  specialize (IH (get_map T a) (get_map T b) Hch2 Hch1 Heq).
  subst. clear - HB2 Hdoma Hdomb Hch1 Hch2. move HB2 after b.
  cut (a = b); [intro; subst; reflexivity|].
  destruct bl as [|b' bl'].
   (* case bl = [] *)
   rewrite ischained_nil in Hch1, Hch2. rewrite <- Hch2 in Hch1; clear Hch2.
   unfold injective in HB2.
   exact (HB2 a b Hdoma Hdomb Hch1).
   (* case bl = b'::bl' *)
   assert (Cons b' bl' = infix_plpl Nil (Cons b' bl')).
    clear. simpl. reflexivity.
   rewrite H in Hch1, Hch2; clear H.
   rewrite <- ischained_app in Hch1, Hch2.
   destruct Hch1 as (Heq,_). destruct Hch2 as (Heq',_).
   rewrite ischained_nil in Heq, Heq'. rewrite <- Heq' in Heq; clear Heq'.
   unfold injective in HB2.
   exact (HB2 a b Hdoma Hdomb Heq).
Qed.

Theorem ischained_diff_length : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (Y1:bitstring_n) (Y2:bitstring_n) (c1:(list
  (bitstring_k* bitstring_n)%type)) (c2:(list (bitstring_k*
  bitstring_n)%type)) (z:bitstring_n), ((length c2) <  (length c1))%Z ->
  ((injective T) -> ((ischained T Y1 c1 z) -> ((ischained T Y2 c2 z) ->
  exists xy:(bitstring_k* bitstring_n)%type, exists pre:(list (bitstring_k*
  bitstring_n)%type), (c1 = (infix_plpl pre (Cons xy c2)))))).
Proof.
intros T Y1 Y2 c1 c2 z.
intros Hgt HB2 Hch1 Hch2.
generalize Hch1 Hch2 Hgt; clear Hch1 Hch2 Hgt.
generalize c1 Y1 Y2; clear c1 Y1 Y2.
apply list_ind with (l := c2).

 (* base case, c2 = [] *)
 intros.
 destruct c1 as [|a al].
  (* case c1 = [] *)
  (* in this case, we get a contradiction since we have length([]) > length([]) *)
  apply False_ind. clear - Hgt.
  simpl in Hgt. omega.
  (* case c1 = a::al *)
  (* in this case, we have to show: exists x xl, a::al = xl@x *)
  exact (cons_app_swap _ a al).

 (* induction step, c2 = b::bl *)
 intros b bl IH. intros.
 destruct c1 as [|a al].
  (* case c1 = [] *)
  apply False_ind. clear - Hgt.
  unfold length in Hgt; fold length in Hgt.
  remember (Length_nonnegative _ bl).
  omega.
  (* case c1 = a::al *)
  (* in this case we use the IH to obtain: exists x xl, al = xl++x::bl *)
  specialize (IH al).
  assert ((length bl < length al)%Z) as Hgt'; [unfold length in Hgt; fold length in Hgt; omega|].
  clear Hgt; rename Hgt' into Hgt.
  assert (forall (x:prod bitstring_k bitstring_n) xl, (Cons x xl) = (infix_plpl Nil (Cons x xl))).
   clear. intros. simpl. reflexivity.
  rewrite H in Hch1, Hch2; clear H.
  rewrite <- ischained_app in Hch1, Hch2.
  destruct Hch1 as (_,(_,Hch1)). destruct Hch2 as (_,(Hdomb,Hch2)).
  specialize (IH (get_map T a) (get_map T b) Hch1 Hch2 Hgt).
  destruct IH as (xy',(pre')). subst.
  clear - HB2 Hdomb Hch1 Hch2. move HB2 after a.
  (* we now want to show that xy' = b; then it is easy to find instances for xy and pre in the goal *)
  rewrite <- ischained_app in Hch1.
  destruct Hch1 as (_,(Hdomxy',Hch1)).
  destruct bl as [|b' bl'].
   (* case bl = [] *)
   rewrite ischained_nil in Hch1, Hch2.
   rewrite <- Hch2 in Hch1; clear Hch2.
   unfold injective in HB2.
   specialize (HB2 xy' b Hdomxy' Hdomb Hch1). subst.
   destruct (cons_app_swap _ a pre') as (xy,(pre)).
   rewrite <- append_cons. rewrite H.
   exists xy, pre. rewrite <- Append_assoc. simpl. reflexivity.
   (* case bl = b'::bl' *)
   rewrite <- (append_nil _ (Cons b' bl')) in Hch1, Hch2.
   rewrite <- ischained_app in Hch1, Hch2.
   destruct Hch1 as (Hch1,_). destruct Hch2 as (Hch2,_).
   rewrite ischained_nil in Hch1, Hch2.
   rewrite <- Hch2 in Hch1; clear Hch2.
   unfold injective in HB2.
   specialize (HB2 xy' b Hdomxy' Hdomb Hch1). subst.
   rewrite <- append_cons.
   destruct (cons_app_swap _ a pre') as (xy,(pre)). rewrite H.
   exists xy, pre. rewrite <- Append_assoc. simpl. reflexivity.
Qed.

Theorem ischained_diff_length_absurd : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (Y1:bitstring_n) (Y2:bitstring_n) (c1:(list
  (bitstring_k* bitstring_n)%type)) (c2:(list (bitstring_k*
  bitstring_n)%type)) (z:bitstring_n), ((length c2) <  (length c1))%Z ->
  ((~ (in_rng_map Y2 T)) -> ((injective T) -> ((ischained T Y1 c1 z) ->
  ~ (ischained T Y2 c2 z)))).
Proof.
intros T Y1 Y2 c1 c2 z.
intros Hgt HB1 HB2 Hch1 Hch2.
remember (ischained_diff_length T Y1 Y2 c1 c2 z Hgt HB2 Hch1 Hch2) as H; clear HeqH.
destruct H as (a,(al)); subst.
clear HB2 Hgt.
assert (in_rng_map Y2 T).
 clear HB1.
 destruct c2 as [|b bl].
  (* case c2 = [] *)
  rewrite ischained_nil in Hch2. subst.
  rewrite <- ischained_app in Hch1.
  destruct Hch1 as (_,(Hdoma,Hch1)).
  apply in_dom_in_rng in Hdoma.
  rewrite ischained_nil in Hch1. rewrite Hch1 in Hdoma.
  assumption.
  (* case c2 = b::bl *)
  apply ischained_lasteq in Hch2. subst.
  rewrite <- ischained_app in Hch1.
  destruct Hch1 as (_,(Hdoma,Hch1)).
  apply in_dom_in_rng in Hdoma.
  rewrite (ischained_lasteq _ _ _ _ _ Hch1) in Hdoma.
  assumption.
exact (HB1 H).
Qed.

Axiom ischained_inj : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Y:bitstring_n) (c1:(list (bitstring_k* bitstring_n)%type))
  (c2:(list (bitstring_k* bitstring_n)%type)) (z:bitstring_n),
  (~ (in_rng_map Y T)) -> ((injective T) -> ((ischained T Y c1 z) ->
  ((ischained T Y c2 z) -> (c1 = c2)))).

Axiom ischained_in_dom : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (c:(list (bitstring_k* bitstring_n)%type)) (xy:(bitstring_k*
  bitstring_n)%type) (z:bitstring_n), (mem xy c) -> ((ischained T IV c z) ->
  (in_dom_map xy T)).

Theorem ischained_upd : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (c:(list (bitstring_k* bitstring_n)%type)) (xy:(bitstring_k*
  bitstring_n)%type) (z:bitstring_n) (zqt:bitstring_n), (~ (mem xy c)) ->
  ((ischained T IV c z) -> (ischained (upd_map T xy zqt) IV c z)).
Proof.
intros T c xy z z'.
intros Hnin Hch.
generalize Hnin Hch; clear Hnin Hch.
generalize IV as Y.
apply list_ind with (l := c).
 (* c = [] *)
 intros. rewrite ischained_nil in *; trivial.
 (* c = a::al *)
 intros a al IH. intros.
 rewrite <- (append_nil _ (Cons a al)).
 apply ischained_app.
 rewrite <- (append_nil _ (Cons a al)) in Hch.
 apply ischained_app in Hch. rewrite ischained_nil in *.
 destruct Hch as (HY,(Hdom,Hch)).
 repeat split; try assumption.
 (* a in dom(upd(T,xy,z')) *)
 clear - Hdom. rewrite in_dom_upd_map.
 right; assumption.
 (* ischained upd(T,xy,z') upd(T,xy,z')[a] al z = true *)
 clear - IH Hch Hnin.
 assert ( xy <> a ) as n0.
  clear - Hnin.
  simpl in Hnin.
  intuition.
 rewrite (get_upd_map_diff _ _ _ _ _ _ n0).
 specialize (IH (get_map T a)).
 simpl in Hnin.
 intuition.
Qed.

Theorem ischained_mapfst_eq : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (c1:(list (bitstring_k* bitstring_n)%type)) (c2:(list
  (bitstring_k* bitstring_n)%type)) (z1:bitstring_n) (z2:bitstring_n),
  (ischained T IV c1 z1) -> ((ischained T IV c2 z2) ->
  (((mapfst c1) = (mapfst c2)) -> ((c1 = c2) /\ (z1 = z2)))).
Proof.
intros T c1 c2 z1 z2.
intros Hch1 Hch2 Heq.
generalize Hch1 Hch2; clear Hch1 Hch2.
generalize IV as Y.
generalize Heq; clear Heq.
generalize c2; clear c2.
apply list_ind with (l := c1).
 (* case c1 = [] *)
 intros. destruct c2 as [|b bl].
  (* c2 = [] *)
  clear Heq.
  rewrite ischained_nil in *.
  rewrite <- Hch1. rewrite <- Hch2.
  tauto.
  (* c2 = b::bl *)
  clear - Heq. apply False_ind.
  destruct b.
  rewrite mapfst_nil in Heq; rewrite mapfst_cons in Heq.
  inversion Heq.

 (* case c1 = a::al *)
 intros a al IH. intros.
 destruct c2 as [|b bl].
  (* c2 = [] *)
  clear - Heq. apply False_ind.
  destruct a.
  rewrite mapfst_nil in Heq; rewrite mapfst_cons in Heq.
  inversion Heq.
  (* c2 = b::bl *)
  specialize (IH bl).
  destruct a as (a1,a2). destruct b as (b1,b2).
  repeat rewrite mapfst_cons in Heq.
  inversion Heq.
  rename H0 into Hfsteq; rename H1 into Hmapeq.
  specialize (IH Hmapeq); clear Hmapeq.
  rewrite <- (append_nil _ (Cons (a1,a2) al)) in Hch1.
  rewrite <- (append_nil _ (Cons (b1,b2) bl)) in Hch2.
  rewrite <- ischained_app in Hch1.
  rewrite <- ischained_app in Hch2.
  destruct Hch1 as (Hsndeq',(_,Hch1)).
  destruct Hch2 as (Hsndeq,(_,Hch2)).
  rewrite ischained_nil in Hsndeq, Hsndeq'.
  rewrite Hsndeq' in Hsndeq; clear Hsndeq'.
  simpl in Hsndeq.
  rewrite Hfsteq in *; clear Hfsteq.
  rewrite Hsndeq in *; clear Hsndeq.
  specialize (IH (get_map T (b1,b2)) Hch1 Hch2); clear Hch1 Hch2.
  destruct IH as (aleqbl,z1eqz2). rewrite aleqbl, z1eqz2.
  split; reflexivity.
Qed.

Theorem ischained_inclusion : forall (Tqt:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Y:bitstring_n) (c:(list (bitstring_k* bitstring_n)%type))
  (z:bitstring_n), (inclusion Tqt T) -> ((ischained Tqt Y c z) ->
  (ischained T Y c z)).
Proof.
intros T' T Y c z.
intros Hsub.
generalize Y; clear Y.
apply list_ind with (l := c).
 (* base case *)
 intro Y. repeat rewrite ischained_nil; trivial.
 (* induction step, c = a::ab *)
 intros a ab IH Y Hch.
 assert (Cons a ab = infix_plpl Nil (Cons a ab)).
  clear. simpl. reflexivity.
 rewrite H in *; clear H.
 apply ischained_app.
 apply ischained_app in Hch.
 repeat split. 
 (* ischained T Y Nil (snd a) *)
 clear - Hch.
 rewrite ischained_nil in *. tauto.
 (* in_dom_map a T *)
 clear - Hsub Hch.
 destruct Hch as (_,(Hdom,_)).
 unfold inclusion in Hsub.
 destruct Hsub as (Hsub,_).
 exact (Hsub a Hdom).
 (* ischained T (get_map T a) ab z *)
 clear - IH Hsub Hch.
 destruct Hch as (_,(Hdom,Hch)).
 unfold inclusion in Hsub.
 destruct Hsub as (_,Hsub).
 specialize (Hsub a Hdom).
 rewrite <- Hsub; clear Hsub.
 exact (IH (get_map T' a) Hch).
Qed.

Theorem ischained_helpful_upd : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (c:(list (bitstring_k* bitstring_n)%type))
  (x:bitstring_k) (y:bitstring_n) (yqt:bitstring_n) (z:bitstring_n),
  (~ (ischained T IV c yqt)) -> ((ischained (upd_map T (x, y) z) IV c yqt) ->
  (mem (x, y) c)).
Proof.
intros T c x y y' z.
generalize IV as Y.
apply list_ind with (l := c).

 (* case c = [] *)
 intros Y Hnch Hch. apply False_ind.
 apply ischained_nil in Hch. 
 subst. rewrite ischained_nil in Hnch.
 auto.

 (* case c = a::ab *)
 intros a ab IH.
 intros Y Hnch Hch.
 simpl.
 destruct ab as [|a' ab'].
  (* case ab = [] *)
  rewrite ischained_cons in Hch.
  destruct Hch as (adomuT,(Ysnda,getuTa)).
  rewrite in_dom_upd_map_excl in adomuT.
  destruct adomuT as [xya|(xyna,adomT)]; [left; assumption|].
  rewrite (get_upd_map_diff _ _ _ _ _ _ xyna) in getuTa.
  rewrite ischained_cons in Hnch.
  apply False_ind; apply Hnch.
  tauto.

  (* case ab = a'::ab' *)
  remember Hch as Hchtmp; clear HeqHchtmp.
  rewrite ischained_conscons in Hchtmp.
  destruct Hchtmp as (Hdom,_).
  rewrite in_dom_upd_map_excl in Hdom.
  destruct Hdom as [xya|(H,_)]; [left; assumption|].
  specialize (IH (get_map (upd_map T (pair x y) z) a)).
  (* now we have to show:
      ischained T (get_map (upd_map T (pair x y) z) a) (Cons a' ab') y' <> true *)
  assert ( ~ ischained T (get_map (upd_map T (pair x y) z) a) (Cons a' ab') y' ) as Hnch'.
   clear - Hch Hnch H.
   rewrite ischained_conscons in Hch.
   destruct Hch as (Hdom,(Heq,(HTa,_))).
   rewrite ischained_conscons in Hnch.
   rewrite in_dom_upd_map in Hdom.
   destruct Hdom as [nH|Hdom]; [apply False_ind; apply H; exact nH|].
   rewrite (get_upd_map_diff _ _ _ _ _ _ H) in HTa.
   clear H.
   intro H. rewrite (ischained_lasteq _ _ _ _ _ H) in H.
   tauto.
  rewrite ischained_conscons in Hch.
  clear - IH Hch Hnch'.
  destruct Hch as (_,(_,(Heq,Hch))).
  rewrite <- Heq in Hch; clear Heq.
  right. apply IH; assumption.
Qed.

Theorem ischained_last_cases : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (c:(list (bitstring_k* bitstring_n)%type)) (z:bitstring_n),
  (ischained T IV c z) -> ((z = IV) \/ exists x:bitstring_k,
  exists y:bitstring_n, (in_dom_map (x, y) T) /\ ((get_map T (x, y)) = z)).
Proof.
intros T c z.
intros Hch.
case exists_last with (l  := c).
 (* c = [] *)
 intros e; rewrite e in *; clear e.
 left. rewrite ischained_nil in Hch.
 auto.
 (* c = al@[a] *)
 intros e. destruct e as (xy',(c',e)).
 destruct xy' as (x',y').
 rewrite e in *; clear e.
 right. exists x', y'.
 apply ischained_app in Hch. rewrite ischained_nil in Hch.
 destruct Hch as (_,(Hdom,Hnext)).
 auto.
Qed.

Theorem claim4 : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)), (~ (in_rng_map IV T)) -> ((injective T) -> forall (c1:(list
  (bitstring_k* bitstring_n)%type)) (c2:(list (bitstring_k*
  bitstring_n)%type)) (xy:(bitstring_k* bitstring_n)%type)
  (xyqt:(bitstring_k* bitstring_n)%type), (ischained T IV c1 (snd xy)) ->
  ((~ ((unpad (mapfst (infix_plpl c1 (Cons xy (Nil:(list (bitstring_k*
  bitstring_n)%type)))))) = (None:(option (list bool))))) -> ((ischained T IV
  c2 (snd xyqt)) -> ((~ ((unpad (mapfst (infix_plpl c2 (Cons xyqt (Nil:(list
  (bitstring_k* bitstring_n)%type)))))) = (None:(option (list bool))))) ->
  ~ (mem xy c2))))).
Proof.
intros T HB1 HB2 c1 c2 xy xy'.
move HB1 after xy'. move HB2 after HB1.
intros Hch1 Hpad1 Hch2 Hpad2.
intro C.
apply in_split in C.
destruct C as (al,(bl,C)). move al after xy'. move bl after xy'.
rewrite C in *; clear C c2; rename c1 into c.
assert (al = c).
 clear - HB1 HB2 Hch1 Hch2.
 rewrite <- Append_assoc in Hch2. simpl in Hch2.
 rewrite <- ischained_app in Hch2.
 destruct Hch2 as (Hch2,_).
 eapply ischained_inj; eauto.
rewrite H in *; clear H.
clear - Hpad1 Hpad2.
remember (prefixfreeqt (mapfst (infix_plpl c (Cons xy Nil))) (mapfst (infix_plpl bl (Cons xy' Nil)))) as C; clear HeqC.
rewrite <- mapfst_app in C.
rewrite Append_assoc in *.
apply C in Hpad2; clear C.
 (* here we get the contradiction *)
 exact (Hpad1 Hpad2).
 (* it remains to prove that mapfst (Append bl (Cons xy' Nil)) <> Nil *)
 clear. destruct bl as [|b' bl'].
  (* case bl = [] *)
  destruct xy' as (x',y').
  rewrite append_nil. rewrite mapfst_cons.
  intro C. inversion C.
  (* case bl = b'::bl' *)
  destruct b'.
  rewrite append_cons. rewrite mapfst_cons.
  intro C. inversion C.
Qed.

Axiom findseq_complete_unique : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (x:bitstring_k) (y:bitstring_n) (c:(list
  (bitstring_k* bitstring_n)%type)), (injective T) -> ((~ (in_rng_map IV
  T)) -> ((ischained T IV c y) -> ((~ ((unpad (mapfst (infix_plpl c (Cons (x,
  y) (Nil:(list (bitstring_k* bitstring_n)%type)))))) = (None:(option (list
  bool))))) -> ((~ ((findseq x y T) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))) /\ ((findseq x y T) = (Some c)))))).

Axiom findseq_complete_valid_chain : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (x:bitstring_k) (y:bitstring_n) (c:(list
  (bitstring_k* bitstring_n)%type)), (injective T) -> ((~ (in_rng_map IV
  T)) -> ((valid_chain (infix_plpl c (Cons (x, y) (Nil:(list (bitstring_k*
  bitstring_n)%type)))) T) -> ~ ((findseq x y T) = (None:(option (list
  (bitstring_k* bitstring_n)%type)))))).

Axiom findseq_complete_unique_valid_chain : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (x:bitstring_k) (y:bitstring_n) (c:(list
  (bitstring_k* bitstring_n)%type)), (injective T) -> ((~ (in_rng_map IV
  T)) -> ((valid_chain (infix_plpl c (Cons (x, y) (Nil:(list (bitstring_k*
  bitstring_n)%type)))) T) -> ((~ ((findseq x y T) = (None:(option (list
  (bitstring_k* bitstring_n)%type))))) /\ ((proj (findseq x y T)) = c)))).

Axiom findseq_ischained_unpad : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (x:bitstring_k) (y:bitstring_n) (c:(list
  (bitstring_k* bitstring_n)%type)), (injective T) -> ((~ (in_rng_map IV
  T)) -> ((ischained T IV c y) -> (((unpad (infix_plpl (mapfst c) (Cons x
  (Nil:(list bitstring_k))))) = (None:(option (list bool)))) -> ((findseq x y
  T) = (None:(option (list (bitstring_k* bitstring_n)%type))))))).

Axiom findseq_mapfst_eq : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (x1:bitstring_k) (y1:bitstring_n) (x2:bitstring_k)
  (y2:bitstring_n), (~ ((findseq x1 y1 T) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))) -> ((~ ((findseq x2 y2 T) = (None:(option (list
  (bitstring_k* bitstring_n)%type))))) ->
  (((proj (unpad (mapfst (infix_plpl (proj (findseq x2 y2 T)) (Cons (x2, y2)
  (Nil:(list (bitstring_k*
  bitstring_n)%type))))))) = (proj (unpad (mapfst (infix_plpl (proj (findseq x1
  y1 T)) (Cons (x1, y1) (Nil:(list (bitstring_k* bitstring_n)%type)))))))) ->
  ((x1, y1) = (x2, y2)))).

Theorem findseq_inclusion_eq : forall (Tqt:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (x:bitstring_k) (y:bitstring_n), (inclusion Tqt T) ->
  ((injective T) -> ((~ (in_rng_map IV T)) -> ((~ ((findseq x y
  Tqt) = (None:(option (list (bitstring_k* bitstring_n)%type))))) ->
  ((findseq x y T) = (findseq x y Tqt))))).
Proof.
intros T' T x y Hsub HB2 HB1 Hseq.
remember Hseq as Hseq'; clear HeqHseq'.
apply findseq_ischained in Hseq.
apply findseq_complete_unique with (x := x) in Hseq.
 (* find_seq x y T = find_seq x y T' *)
 destruct Hseq as (_,Hsome).
 remember Hseq' as Hpad; clear HeqHpad; rename Hseq' into Hch.
 apply findseq_ischained in Hch.
 apply findseq_unpad in Hpad.
 apply ischained_inclusion with (T := T) in Hch; [|assumption].
 clear Hsub.
 apply findseq_complete_unique with (x := x) in Hch; try assumption.
 rewrite <- Hsome in Hch.
 tauto.
 (* Injective T' *)
 clear - Hsub HB2.
 apply inclusion_injective with (Tqt := T') in HB2; assumption.
 (* in_rng_map IV T' <> true *)
 clear - Hsub HB1.
 apply inclusion_not_rng with (Tqt := T') in HB1; assumption.
 (* unpad ... (find_seq x y T') ++ [(x,y)] <> None *)
 clear - Hseq'. 
 apply findseq_unpad in Hseq'; assumption.
Qed.

Axiom findseq_inclusion_upd_eq : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (x:bitstring_k) (y:bitstring_n) (xqt:bitstring_k)
  (yqt:bitstring_n) (zqt:bitstring_n), (inclusion Tqt T) -> ((injective T) ->
  ((~ (in_rng_map IV T)) -> ((~ (zqt = IV)) -> ((~ (in_rng_map zqt T)) ->
  ((~ (in_dom_map (xqt, yqt) T)) -> ((~ ((findseq x y Tqt) = (None:(option
  (list (bitstring_k* bitstring_n)%type))))) -> ((findseq x y (upd_map T (
  xqt, yqt) zqt)) = (findseq x y Tqt)))))))).

Theorem findseq_last_in_dom_valid : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (x:bitstring_k) (y:bitstring_n), (inclusion Tqt T) ->
  ((~ ((findseq x y Tqt) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))) -> ((in_dom_map (x, y) T) ->
  (valid_chain (infix_plpl (proj (findseq x y Tqt)) (Cons (x, y) (Nil:(list
  (bitstring_k* bitstring_n)%type)))) T))).
Proof.
intros T T' x y incl fseq xydomT.
unfold valid_chain.
exists (get_map T (x,y)).
split; [|apply findseq_unpad in fseq; assumption].
apply findseq_ischained in fseq.
rewrite <- ischained_app.
repeat split; [simpl; apply (ischained_inclusion _ _ _ _ _ incl) in fseq; assumption|assumption|].
rewrite ischained_nil; reflexivity.
Qed.

Axiom findseq_updqt : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (xy:(bitstring_k* bitstring_n)%type) (xqt:bitstring_k)
  (yqt:bitstring_n) (z:bitstring_n), (injective T) -> ((~ (in_rng_map IV
  T)) -> ((~ (in_dom_map xy T)) -> ((~ (in_rng_map z T)) -> ((~ (z = IV)) ->
  (((findseq xqt yqt (upd_map T xy z)) = (None:(option (list (bitstring_k*
  bitstring_n)%type)))) -> ((findseq xqt yqt T) = (None:(option (list
  (bitstring_k* bitstring_n)%type))))))))).

Theorem findseq_pred_in_Tqt : forall (Tqt:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (xqt:bitstring_k) (yqt:bitstring_n) (x:bitstring_k),
  (inclusion Tqt T) -> ((injective T) -> ((~ (in_rng_map IV T)) ->
  ((in_dom_map (xqt, yqt) T) -> ((~ ((findseq x (get_map T (xqt, yqt))
  Tqt) = (None:(option (list (bitstring_k* bitstring_n)%type))))) ->
  (in_dom_map (xqt, yqt) Tqt))))).
Proof.
intros T' T x' y' x.
intros Hsub HB2 HB1 Hdom Hseq.
apply findseq_ischained in Hseq.
remember (get_map T (x', y')) as y.
assert ( exists c, (proj (findseq x y T')) = infix_plpl c (Cons (pair x' y') Nil) ) as Hproj.
 generalize Hseq; clear Hseq.
 generalize (proj (findseq x y T')) as c'.
 intros. case exists_last with (l := c').
  (* case c' = [] *)
  clear Hsub HB2.
  intros. apply False_ind.
  subst. rewrite ischained_nil in Hseq.
  apply in_dom_in_rng in Hdom. rewrite <- Hseq in Hdom; clear Hseq.
  exact (HB1 Hdom).
  (* case c' = al@[a] *)
  clear HB1.
  intro s. destruct s as (a,(al,e)); repeat rewrite e in *; clear e.
  exists al.
  rewrite <- ischained_app in Hseq. destruct Hseq as (_,(Hdoma,Hpreda)).
  rewrite ischained_nil in Hpreda.
  unfold inclusion in Hsub. destruct Hsub as (Hsubdom,Hsubeq).
  remember Hdoma as Hdoma'; clear HeqHdoma'.
  apply Hsubdom in Hdoma; clear Hsubdom.
  apply Hsubeq in Hdoma'; clear Hsubeq.
  rewrite Hdoma' in Hpreda; clear Hdoma'.
  rewrite Heqy in Hpreda; clear Heqy.
  unfold injective in HB2. specialize (HB2 a (pair x' y') Hdoma Hdom Hpreda).
  subst. reflexivity.
clear - Hseq Hproj.
destruct Hproj as (c,Hproj).
rewrite Hproj in Hseq; clear Hproj.
apply ischained_in_dom with (c := (infix_plpl c (Cons (pair x' y') Nil))) (z := y); [|exact Hseq].
clear.
apply last_in.
Qed.

Axiom findseq_helpful_upd : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (x:bitstring_k) (xqt:bitstring_k) (y:bitstring_n)
  (yqt:bitstring_n) (z:bitstring_n), (injective T) -> ((~ (in_rng_map IV
  T)) -> (((findseq xqt yqt T) = (None:(option (list (bitstring_k*
  bitstring_n)%type)))) -> ((~ ((findseq xqt yqt (upd_map T (x, y)
  z)) = (None:(option (list (bitstring_k* bitstring_n)%type))))) -> (mem (x,
  y) (proj (findseq xqt yqt (upd_map T (x, y) z))))))).

Theorem findseq_useless_upd : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (x:bitstring_k) (xqt:bitstring_k) (y:bitstring_n) (yqt:bitstring_n),
  (inclusion Tqt T) -> ((injective T) -> ((~ (in_rng_map IV T)) ->
  ((~ ((findseq x y Tqt) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))) -> ((in_dom_map (x, y) T) -> ((findseq xqt yqt
  (upd_map Tqt (x, y) (get_map T (x, y)))) = (findseq xqt yqt Tqt)))))).
Proof.
intros T T' x x' y y'.
intros Hsub HB2 HB1 Hseq Hdom.

assert ( inclusion T' (upd_map T' (pair x y) (get_map T (pair x y))) ) as Hsub'.
 clear - Hsub Hdom.
 apply inclusion_upd; trivial.
assert ( inclusion (upd_map T' (pair x y) (get_map T (pair x y))) T ) as Hsub''.
 clear - Hsub Hdom.
 apply inclusion_updqt; trivial.
apply inclusion_injective with (Tqt := (upd_map T' (pair x y) (get_map T (pair x y)))) in HB2; [|exact Hsub''].
apply inclusion_not_rng with (Tqt := (upd_map T' (pair x y) (get_map T (pair x y)))) in HB1; [|exact Hsub''].

destruct (Some_or_None _ (findseq x' y' T')).
 (* case (find_seq x' y' T') = None *)
 case (Some_or_None _ (findseq x' y' (upd_map T' (pair x y) (get_map T (pair x y))))) as [e0|Hseq'].
  (* case (find_seq x' y' (upd_map T' (pair x y) (get_map T (pair x y)))) = None *)
  rewrite H, e0. reflexivity.
  (* case (find_seq x' y' (upd_map T' (pair x y) (get_map T (pair x y)))) <> None *)
  destruct Hseq' as (S,Hseq').
  assert ( findseq x' y' (upd_map T' (x, y) (get_map T (x, y))) <> None ) as Hseqtmp.
   intro C; rewrite C in Hseq'; inversion Hseq'.
  clear Hseq'; rename Hseqtmp into Hseq'.
  apply False_ind.
  clear Hsub Hsub'' Hdom.
  assert ( mem (pair x y) (proj (findseq x' y' (upd_map T' (pair x y) (get_map T (pair x y))))) ) as Hin.
   apply findseq_helpful_upd; try assumption.
   (* Injective T' *)
   apply inclusion_injective with (Tqt := T') in HB2; [|exact Hsub']. assumption.
   (* in_rng_map IV T' <> true *)
   apply inclusion_not_rng with (Tqt := T') in HB1; [|exact Hsub']. assumption.
  assert ( findseq x y (upd_map T' (pair x y) (get_map T (pair x y))) = findseq x y T' ) as Hseqeq. 
   clear - HB1 HB2 Hseq Hsub'.
   apply findseq_inclusion_eq; assumption.
  rewrite <- Hseqeq in Hseq; clear Hseqeq.
  clear Hsub'.
  generalize HB1 HB2 Hseq Hseq' Hin; clear HB1 HB2 Hseq Hseq' Hin.
  generalize (upd_map T' (pair x y) (get_map T (pair x y))) as T''.
  clear T; intro T; intros.
  remember Hseq as Hpad; clear HeqHpad; rename Hseq into Hch.
  apply findseq_ischained in Hch.
  apply findseq_unpad in Hpad.
  remember Hseq' as Hpad'; clear HeqHpad'; rename Hseq' into Hch'.
  apply findseq_ischained in Hch'.
  apply findseq_unpad in Hpad'.
  remember (claim4 T HB1 HB2 (proj (findseq x y T)) (proj (findseq x' y' T)) (pair x y) (pair x' y')) as C; clear HeqC.
  simpl in C.
  specialize (C Hch Hpad Hch' Hpad').
  exact (C Hin).

 (* case (find_seq x' y' T') <> None *)
 destruct H as (S,Hseq'). 
 clear - HB1 HB2 Hseq' Hsub'.
 apply findseq_inclusion_eq; auto.
 intro C; rewrite C in Hseq'; inversion Hseq'.
Qed.

Axiom findseq_useless_updqt : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (x:bitstring_k) (xqt:bitstring_k) (y:bitstring_n) (yqt:bitstring_n)
  (z:bitstring_n), (inclusion Tqt T) -> ((injective T) -> ((~ (in_rng_map IV
  T)) -> ((~ (z = IV)) -> ((~ (in_rng_map z T)) -> ((~ (in_dom_map (x, y)
  T)) -> ((~ ((findseq x y Tqt) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))) -> ((findseq xqt yqt (upd_map Tqt (x, y)
  z)) = (findseq xqt yqt Tqt)))))))).

Theorem findseq_upd_nohelp : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (x:bitstring_k) (xqt:bitstring_k) (y:bitstring_n)
  (yqt:bitstring_n) (z:bitstring_n), (injective T) -> ((~ (in_rng_map IV
  T)) -> ((~ (in_dom_map (x, y) T)) -> ((~ (z = IV)) -> ((~ (in_rng_map z
  T)) -> ((~ (z = y)) -> ((~ exists x0:bitstring_k, (in_dom_map (x0, z)
  T)) -> ((in_dom_map (xqt, yqt) (upd_map T (x, y) z)) -> ((findseq xqt yqt
  (upd_map T (x, y) z)) = (findseq xqt yqt T))))))))).
Proof.
intros T x x' y y' z.
intros HB2 HB1 Hndom HnzIV Hnzrng Hneq Hnex Hdom.

destruct (Some_or_None _ (findseq x' y' T)) as [e | n].
 (* case (find_seq x' y' T) = None *)
 destruct (Some_or_None _ (findseq x' y' (upd_map T (pair x y) z))) as [e0|n0].
  (* case find_seq x' y' (upd_map T (pair x y) z) = None *)
  rewrite e, e0. reflexivity.

  (* case find_seq x' y' (upd_map T (pair x y) z) <> None *)
  destruct n0 as (S,upseqsome).
  assert ( findseq x' y' (upd_map T (x, y) z) <> None ) as n0.
   intro C; rewrite C in upseqsome; inversion upseqsome.
  clear Hndom HnzIV Hnzrng S upseqsome.
  apply False_ind.
  assert ( mem (pair x y) (proj (findseq x' y' (upd_map T (pair x y) z))) ) as Hin.
   clear - HB2 HB1 e n0.
   apply findseq_helpful_upd; assumption.
  clear HB1 HB2 e.
  rename n0 into Hseq.
  apply findseq_ischained in Hseq.
  generalize Hseq Hin; clear Hin Hseq.
  generalize (proj (findseq x' y' (upd_map T (pair x y) z))) as c; intros c.
  (* now, this could be written as a lemma: maybe with this lemma the smt solvers would derive _nohelp :-) *)
  generalize IV as Y.
(* induktion ueber c
 wenn c = []
  so ist widerspruch zu Hin
 wenn c = a::al
  dann fallunterscheidung (x y) = a -> dann ist das nchste element entwder nochmal (x,y), aber
                                       das ist wiederspruch zu Hneq; oder es ist etwas anderes als
                                       (x,y) und es hat die form (x0,z) und ist in der dom(T)

                                       wenn kein naechstes element, so ist z = y'. mit Hdom
                                       erhalten wir dann: in_dom( (x',y'), upd(T,(x,y),z) )
                                       und somit in_dom (x',y'), T), denn (x',y') != (x,y);
                                       wre (x',y') = (x,y), so y' = y aber z = y' also z = y widerspruch;
                                       schliesslich: Hdom wird zu in_dom((x',z),T) widerspruch zu Hnex
                          (x y) != a -> dann knnen wir irgendwie die induktionshypothese anwenden... *)
  apply list_ind with (l := c).
   (* case c = [] *)
   intros Y _ C. clear - C.
   auto.
   (* case c = a::al *)
   intros a al IH. intros.
   simpl in Hin.
   destruct Hin as [e|n].
    (* case a = (x,y) *)
    rewrite <- e in *. clear e a.
    clear IH.
    destruct al as [|a' al'].
     (* case al = [] *)
     rewrite ischained_cons in Hseq.
     destruct Hseq as (_,(_,Heq)).
     rewrite get_upd_map_same in Heq.
     rewrite in_dom_upd_map_excl in Hdom.
     destruct Hdom as [e|(n,Hdom)].
      (* case (x,y) = (x',y') *)
      clear - Hneq Heq e.
      rewrite Heq in Hneq; clear Heq.
      inversion e.
      symmetry in H1.
      exact (Hneq H1).
      (* case (x,y) <> (x',y') *)
      apply Hnex.
      rewrite Heq.
      exists x'; assumption.
     reflexivity.
     (* case al = a'::al' *)
(* also erstmal wollen wir
 get_map (upd(T)) (x,y) = snd(a')
dann fallunterscheidung:
 a' = (x,y) (nochmal (x,y)) -->  T[xy] = snd(a') = y = z aber z <> y
 a' <> (x,y) --> wir wissen also: a' in dom(upd(T))
                               get_map (upd(T)) (x,y) = snd(a')
                               also in_dom_map((fst(a'),z),upd(T))
                               da aber a' <> (x',y') wissen wir:
                               in_dom_map((fst(a'),z),T) widerspruch zu Hnex! *)
     rewrite ischained_conscons in Hseq.
     destruct Hseq as (_,(_,(Heq,Hch))).
     rewrite get_upd_map_same in Heq.
     rewrite <- (append_nil _ (Cons a' al')) in Hch.
     apply ischained_app in Hch.
     destruct Hch as (_,(Hdom',_)).
     rewrite in_dom_upd_map in Hdom'.
     destruct Hdom' as [e|Hdom'].
      (* case a' = (x,y) *)
      clear - Hneq Heq e.
      destruct a' as (a1,a2).
      simpl in Heq. rewrite <- Heq in e.
      inversion e.
      symmetry in H1.
      exact (Hneq H1).
      (* case a' <> (x,y) *)
      clear - Hnex Heq Hdom'.
      destruct a' as (a1,a2).
      simpl in Heq. rewrite <- Heq in Hdom'.
      apply Hnex.
      exists a1; assumption.
    reflexivity.
    (* mem (x, y) al *)
    clear - IH Hseq n.
    rewrite <- (append_nil _ (Cons a al)) in Hseq.
    apply ischained_app in Hseq.
    destruct Hseq as (_,(_,Hseq)).
    eapply IH; eauto.

 (* case (find_seq x' y' T) <> None *)
 destruct n as (S, Hseq).
 assert (findseq x' y' T <> None) as Nseq.
  intro C; rewrite C in Hseq; inversion Hseq.
 clear S Hseq Hneq Hnex Hdom.
 apply findseq_inclusion_upd_eq; trivial.
 unfold inclusion; auto.
Qed.

Theorem valid_chain_upd : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (xy:(bitstring_k* bitstring_n)%type) (z:bitstring_n) (c:(list
  (bitstring_k* bitstring_n)%type)), (~ (in_dom_map xy T)) -> ((valid_chain c
  T) -> (valid_chain c (upd_map T xy z))).
Proof.
intros T xy z c ndomxyT chcT.
unfold valid_chain in *.
destruct chcT as (z', (chc, unpadc)). 
exists z'.
split; [|trivial].
apply ischained_upd; [|trivial].
intro xyinc. 
apply ndomxyT.
apply (ischained_in_dom _ _ _ _ xyinc chc).
Qed.

Theorem valid_chain_upd_nohelp : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (x:bitstring_k) (y:bitstring_n)
  (z:bitstring_n) (xyqt:(bitstring_k* bitstring_n)%type) (c:(list
  (bitstring_k* bitstring_n)%type)), (injective T) -> ((~ (in_rng_map IV
  T)) -> ((~ (in_dom_map (x, y) T)) -> ((~ (z = IV)) -> ((~ (in_rng_map z
  T)) -> ((~ (z = y)) -> ((~ exists x0:bitstring_k, (in_dom_map (x0, z)
  T)) -> ((in_dom_map xyqt (upd_map T (x, y) z)) -> (((findseq x y
  T) = (None:(option (list (bitstring_k* bitstring_n)%type)))) ->
  ((valid_chain (infix_plpl c (Cons xyqt (Nil:(list (bitstring_k*
  bitstring_n)%type)))) (upd_map T (x, y) z)) <-> (valid_chain (infix_plpl c
  (Cons xyqt (Nil:(list (bitstring_k* bitstring_n)%type)))) T)))))))))).
Proof.
intros T x y z xy' c.
intros HB2 HB1 Hndom HnzIV Hnzrng Hneq Hnex Hdom Hnone.

split.

 (* -> *)
 intros Hval.
 assert (injective (upd_map T (pair x y) z)) as HB2'.
  clear - HB2 Hnzrng.
  apply injective_upd; assumption.
 assert (~ in_rng_map IV (upd_map T (pair x y) z)) as HB1'.
  clear - HB1 HnzIV.
  apply not_rng_upd; assumption.
 destruct xy' as (x',y').
 apply (findseq_complete_unique_valid_chain (upd_map T (pair x y) z) x' y' c HB2' HB1') in Hval.
 clear HB1' HB2'.
 destruct Hval as (Hval,e).
 rewrite <- e; clear e c.
 rewrite findseq_upd_nohelp; try assumption.
 rewrite findseq_upd_nohelp in Hval; try assumption.
 rewrite in_dom_upd_map in Hdom.
 destruct Hdom as [e|Hdom].
  (* xy' = (x,y) *)
  intros. clear - e Hval Hnone.
  apply False_ind.
  inversion e.
  rewrite H0, H1 in *; clear e.
  exact (Hval Hnone).
  (* (x,y) <> (x',y') *)
  intros. clear - Hval Hdom.
  remember (findseq_last_in_dom_valid T T x' y'); clear Heqv.
  apply v; try assumption.
  unfold inclusion; auto.

 (* <- *)
 intros HVal.
 apply valid_chain_upd; assumption.
Qed.

Theorem valid_chain_upd_nohelpqt : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (x:bitstring_k) (y:bitstring_n)
  (z:bitstring_n) (xyqt:(bitstring_k* bitstring_n)%type) (c:(list
  (bitstring_k* bitstring_n)%type)), (injective T) -> ((~ (in_rng_map IV
  T)) -> ((~ (in_dom_map (x, y) T)) -> ((~ (z = IV)) -> ((~ (in_rng_map z
  T)) -> ((~ (z = y)) -> ((~ exists x0:bitstring_k, (in_dom_map (x0, z)
  T)) -> ((in_dom_map xyqt T) -> ((valid_chain (infix_plpl c (Cons xyqt
  (Nil:(list (bitstring_k* bitstring_n)%type)))) (upd_map T (x, y) z)) <->
  (valid_chain (infix_plpl c (Cons xyqt (Nil:(list (bitstring_k*
  bitstring_n)%type)))) T))))))))).
Proof.
intros T x y z xy' c.
intros HB2 HB1 Hndom HnzIV Hnzrng Hneq Hnex Hdom.

split.

 (* -> *)
 intros Hval.
 assert (injective (upd_map T (pair x y) z)) as HB2'.
  clear - HB2 Hnzrng.
  apply injective_upd; assumption.
 assert (~ in_rng_map IV (upd_map T (pair x y) z)) as HB1'.
  clear - HB1 HnzIV.
  apply not_rng_upd; assumption.
 assert (in_dom_map xy' (upd_map T (pair x y) z)) as Hdom'.
  clear - Hdom.
  rewrite in_dom_upd_map.
  right; assumption.
 destruct xy' as (x',y').
 apply (findseq_complete_unique_valid_chain (upd_map T (pair x y) z) x' y' c HB2' HB1') in Hval.
 clear HB1' HB2'.
 destruct Hval as (Hval,e).
 rewrite <- e; clear e c.
 rewrite findseq_upd_nohelp; try assumption.
 rewrite findseq_upd_nohelp in Hval; try assumption.
 clear - Hval Hdom.
 remember (findseq_last_in_dom_valid T T x' y'); clear Heqv.
 apply v; try assumption.
 unfold inclusion; auto.

 (* <- *)
 intros HVal.
 apply valid_chain_upd; assumption.
Qed.

Axiom set_bad3_eq : forall (z:bitstring_n) (T1:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (T1qt:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (T2:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (T2qt:(map (bitstring_k* bitstring_n)%type bitstring_n)) (invT1:(map
  bitstring_n (bitstring_k* bitstring_n)%type)) (invT2:(map bitstring_n
  (bitstring_k* bitstring_n)%type)), ((((~ (set_bad3 z T1qt T1 invT1)) ->
  (false = true)) \/ ((~ (set_bad3 z T2qt T2 invT2)) -> (false = true))) ->
  (((set_bad3 z T1qt T1 invT1) \/ ((~ (set_bad3 z T1qt T1 invT1)) /\
  (false = true))) /\ ((set_bad3 z T2qt T2 invT2) \/ ((~ (set_bad3 z T2qt T2
  invT2)) /\ (false = true))))) -> (((set_bad3 z T1qt T1 invT1) ->
  ((~ (set_bad3 z T2qt T2 invT2)) -> (true = false))) /\ ((~ (set_bad3 z T1qt
  T1 invT1)) -> ((set_bad3 z T2qt T2 invT2) -> (false = true)))).

Theorem set_bad3_upd : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (invT:(map bitstring_n (bitstring_k* bitstring_n)%type)) (x:bitstring_k)
  (y:bitstring_n) (y0:bitstring_n) (z:bitstring_n), (inclusion Tqt T) ->
  ((injective T) -> ((inverse T invT) -> ((~ (in_rng_map IV T)) ->
  ((~ (in_dom_map (x, y) T)) -> ((~ (in_rng_map z T)) -> ((~ (z = IV)) ->
  ((~ ((findseq x y Tqt) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))) -> (((set_bad3 y0 (upd_map Tqt (x, y) z) (upd_map T
  (x, y) z) (upd_map invT z (x, y))) -> ((~ (set_bad3 y0 Tqt T invT)) ->
  (true = false))) /\ ((~ (set_bad3 y0 (upd_map Tqt (x, y) z) (upd_map T (x,
  y) z) (upd_map invT z (x, y)))) -> ((set_bad3 y0 Tqt T invT) ->
  (false = true))))))))))).
Proof.
intros T T' invT x y y0 z.
intros Hsub HB2 Hinv HB1 Hndom Hnzrng HnzIV Hseq'.
split.
(* -> *)
intros Hbad Hnbad.
apply False_ind.
repeat rewrite set_bad3_def in *.
assert (z <> y0) as n0.
 intro e.
 rewrite <- e in *.
 rewrite get_upd_map_same in *.
 destruct Hbad as (_,(C,_)).
 repeat rewrite in_dom_upd_map in C.  
 intuition.
 reflexivity.
rewrite (get_upd_map_diff _ _ _ _ _ _ n0) in Hbad.
destruct Hbad as (Hrng,(Hndom',Hnval)).
apply Hnbad.
repeat split.
rewrite in_dom_upd_map in Hrng.
destruct Hrng; [intuition|trivial].
intro C.
rewrite in_dom_upd_map in Hndom'; intuition.
intros c Hval.
specialize (Hnval c).
apply valid_chain_upd with (xy := pair x y) (z := z) in Hval; try assumption.
exact (Hnval Hval).

(* <- *)
intros Hnbad Hbad.
apply False_ind.
apply Hnbad; clear Hnbad.
repeat rewrite set_bad3_def in *.
assert (z <> y0) as n0.
 intro e.
 rewrite <- e in *.
 destruct Hbad as (zdominvT,_).
 clear - Hinv Hnzrng zdominvT. 
 apply inverse_dom_rng with (b := z) in Hinv; try assumption.
 exact (Hnzrng Hinv).
rewrite (get_upd_map_diff _ _ _ _ _ _ n0).
destruct Hbad as (Hrng,(Hndom',Hnval)).
assert ( pair x y <> get_map invT y0 ) as n1.
 clear - Hinv Hrng Hndom.
 intro. rewrite H in Hndom.
 unfold inverse in Hinv. destruct Hinv as (_,Hinv2).
 specialize (Hinv2 y0 Hrng).
 tauto.
repeat split.
 (* in_dom_map y0 (upd_map invT z (x, y)) *)
 rewrite in_dom_upd_map; right.
 clear - Hrng. assumption.
 (* ~ in_dom_map (get_map invT y0) (upd_map T' (x, y) z) *)
 clear - Hndom' n1. intro C.
 rewrite in_dom_upd_map in C.
 destruct C as [C|C]; [exact (n1 C)|exact (Hndom' C)].
 (* forall c, ~valid_chain(c++invT[y0], upd(T)) *)
 intros c' Hval. clear - Hsub HB1 HB2 HnzIV Hnzrng Hndom n1 Hseq' Hval Hnval.
 specialize (Hnval c').
 assert (findseq x y (upd_map T (pair x y) z) <> None) as Hseq.
  rewrite findseq_inclusion_upd_eq with (Tqt := T'); assumption.
 assert (injective (upd_map T (pair x y) z)) as HB2'; [|clear HB2; rename HB2' into HB2].
  clear - HB2 Hnzrng.
  apply injective_upd; assumption.
 assert (~ in_rng_map IV (upd_map T (pair x y) z)) as HB1'; [|clear HB1; rename HB1' into HB1].
  clear - HB1 HnzIV.
  apply not_rng_upd; assumption.
 clear Hsub Hseq' HnzIV Hnzrng Hndom T'.
 assert ( mem (pair x y) (infix_plpl c' (Cons (get_map invT y0) Nil)) ) as Hin.
  clear - Hval Hnval.
  unfold valid_chain in *.
  destruct Hval as (z0,(Hch,Hpad)).
  assert ( ~ ischained T IV (infix_plpl c' (Cons (get_map invT y0) Nil)) z0 ) as Hnch.
   intros C.
   destruct Hnval. exists z0.
   split; assumption.
  clear - Hch Hnch.
  eapply ischained_helpful_upd; eauto.
 clear Hnval.
 remember Hseq as Hpad; clear HeqHpad; rename Hseq into Hch.
 apply findseq_ischained in Hch. apply findseq_unpad in Hpad.
 unfold valid_chain in Hval.
 destruct Hval as (z0,(Hch',Hpad')).
 generalize HB1 HB2 Hch Hpad Hch' Hpad' Hin n1; clear HB1 HB2 Hch Hpad Hch' Hpad' Hin n1.
 generalize (proj (findseq x y (upd_map T (pair x y) z))) as c.
 generalize (upd_map T (pair x y) z) as T'; clear T.
 generalize (get_map invT y0) as xy'.
 clear. intros xy' T c. intros. (* now we are almost ready to apply claim4 *)
 apply ischained_app in Hch'. destruct Hch' as (Hch',_); clear z0.
 remember (claim4 T HB1 HB2 c c' (pair x y) xy' Hch Hpad Hch' Hpad') as n2; clear Heqn2.
 clear - Hin n1 n2.
 rewrite mem_append in Hin. 
 destruct Hin as [C|C]; [exact (n2 C)|].
 simpl in C.
 destruct C as [C|C]; [exact (n1 C)|assumption].
Qed.

Theorem set_bad3_updqt : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (invT:(map bitstring_n (bitstring_k* bitstring_n)%type)) (x:bitstring_k)
  (y:bitstring_n) (y0:bitstring_n) (z:bitstring_n), (inclusion Tqt T) ->
  ((injective T) -> ((inverse T invT) -> ((~ (in_rng_map IV T)) ->
  ((~ (in_dom_map (x, y) T)) -> ((~ (in_rng_map z T)) -> ((~ (z = IV)) ->
  ((~ (z = y)) -> ((~ exists x0:bitstring_k, (in_dom_map (x0, z) T)) ->
  (((set_bad3 y0 (upd_map Tqt (x, y) z) (upd_map T (x, y) z) (upd_map invT z
  (x, y))) -> ((~ (set_bad3 y0 Tqt T invT)) -> (true = false))) /\
  ((~ (set_bad3 y0 (upd_map Tqt (x, y) z) (upd_map T (x, y) z) (upd_map invT
  z (x, y)))) -> ((set_bad3 y0 Tqt T invT) -> (false = true)))))))))))).
Proof.
intros T T' invT x y y0 z.
intros Hsub HB2 Hinv HB1 Hndom Hnzrng HnzIV Hneq Hnex.
split.
(* -> *)
intros Hbad Hnbad.
apply False_ind.
repeat rewrite set_bad3_def in *.
assert (z <> y0) as n0.
 intro e.
 rewrite <- e in *.
 rewrite get_upd_map_same in *.
 destruct Hbad as (_,(C,_)).
 repeat rewrite in_dom_upd_map in C.  
 intuition.
 reflexivity.
rewrite (get_upd_map_diff _ _ _ _ _ _ n0) in Hbad.
destruct Hbad as (Hrng,(Hndom',Hnval)).
apply Hnbad.
repeat split.
rewrite in_dom_upd_map in Hrng.
destruct Hrng; [intuition|trivial].
intro C.
rewrite in_dom_upd_map in Hndom'; intuition.
intros c Hval.
specialize (Hnval c).
apply valid_chain_upd with (xy := pair x y) (z := z) in Hval; try assumption.
exact (Hnval Hval).

(* <- *)
intros Hnbad Hbad.
apply False_ind.
apply Hnbad; clear Hnbad.
repeat rewrite set_bad3_def in *.
assert (z <> y0) as n0.
 intro e.
 rewrite <- e in *.
 destruct Hbad as (zdominvT,_).
 clear - Hinv Hnzrng zdominvT. 
 apply inverse_dom_rng with (b := z) in Hinv; try assumption.
 exact (Hnzrng Hinv).

rewrite (get_upd_map_diff _ _ _ _ _ _ n0).
destruct Hbad as (Hrng,(Hndom',Hnval)).
assert ( pair x y <> get_map invT y0 ) as n1.
 clear - Hinv Hrng Hndom.
 intro. rewrite H in Hndom.
 unfold inverse in Hinv. destruct Hinv as (_,Hinv2).
 specialize (Hinv2 y0 Hrng).
 tauto.
repeat split.
 (* in_dom_map y0 (upd_map invT z (x, y)) *)
 rewrite in_dom_upd_map; right.
 clear - Hrng. assumption.
 (* ~ in_dom_map (get_map invT y0) (upd_map T' (x, y) z) *)
 clear - Hndom' n1. intro C.
 rewrite in_dom_upd_map in C.
 destruct C as [C|C]; [exact (n1 C)|exact (Hndom' C)].
 (* forall c, ~valid_chain(c++invT[y0], upd(T)) *)
 intros c Hval. clear - Hsub HB1 HB2 HnzIV Hnzrng Hndom Hnex Hneq Hval Hnval n1.
 specialize (Hnval c).
 assert (injective (upd_map T (pair x y) z)) as HB2'; [|clear HB2; rename HB2' into HB2].
  clear - HB2 Hnzrng.
  apply injective_upd; assumption.
 assert (~ in_rng_map IV (upd_map T (pair x y) z)) as HB1'; [|clear HB1; rename HB1' into HB1].
  clear - HB1 HnzIV.
  apply not_rng_upd; assumption.
 clear Hsub HnzIV Hnzrng Hndom T'.
 assert ( mem (pair x y) (infix_plpl c (Cons (get_map invT y0) Nil)) ) as Hin.
  clear - Hval Hnval.
  unfold valid_chain in *.
  destruct Hval as (z0,(Hch,Hpad)).
  assert ( ~ ischained T IV (infix_plpl c (Cons (get_map invT y0) Nil)) z0 ) as Hnch.
   intros C.
   destruct Hnval. exists z0.
   split; assumption.
  clear - Hch Hnch.
  eapply ischained_helpful_upd; eauto.
 clear Hnval.
 assert ( mem (pair x y) c) as Hin'; [|clear Hin; rename Hin' into Hin].
  clear - Hin n1.
  rewrite mem_append in Hin. 
  destruct Hin as [|C]; [assumption|].
  apply False_ind.
  simpl in C.
  destruct C as [C|]; [apply False_ind; exact (n1 C)|assumption].
 clear HB1 HB2 n1.
 apply in_split in Hin.
 destruct Hin as (al,(bl,e)). move al after z. move bl after z.
 rewrite e in *; clear e c.
 destruct bl as [|b' bl'].
  (* case bl = [] *)
  unfold valid_chain in Hval. destruct Hval as (z0,(Hch,_)).
  rewrite <- Append_assoc in Hch. simpl in Hch. 
  rewrite <- Append_assoc in Hch. 
  apply ischained_app in Hch. destruct Hch as (_,(_,Hch)).
  rewrite get_upd_map_same in Hch; [|reflexivity].
  rewrite ischained_cons in Hch. destruct Hch as (Hdom,(Heq,_)).
  rewrite in_dom_upd_map in Hdom.
  destruct Hdom as [e|Hdom].
   (* invT[y0] = (x,y) *)
   clear - Hneq Heq e. rewrite <- e in *; clear e y0 invT.
   simpl in Heq. exact (Hneq Heq).
   (* in_dom_map (get_map invT y0) T *)
   clear - Hnex Hdom Heq. 
   destruct Hnex. exists (fst (get_map invT y0)).
   rewrite Heq. destruct (get_map invT y0). simpl. assumption.
  (* case bl = b'::bl' *)
  unfold valid_chain in Hval. destruct Hval as (z0,(Hch,_)).
  rewrite <- Append_assoc in Hch. simpl in Hch. rewrite <- Append_assoc in Hch.
  apply ischained_app in Hch. destruct Hch as (_,(_,Hch)).
  rewrite get_upd_map_same in Hch; [|reflexivity].
  destruct bl' as [|b'' bl''].
   (* case bl' = [] *)
   simpl in Hch. rewrite ischained_conscons in Hch. destruct Hch as (Hdom,(Heq,_)).
   rewrite in_dom_upd_map in Hdom.
   destruct Hdom as [e|Hdom].
    (* b' = (x,y) *)
    clear - Hneq Heq e. rewrite <- e in *; clear e b'.
    simpl in Heq. exact (Hneq Heq).
    (* in_dom_map b' T *)
    clear - Hnex Hdom Heq.
    destruct Hnex. exists (fst b').
    rewrite Heq. destruct b'. simpl. assumption.
   (* case bl' = b''::bl'' *)
   simpl in Hch.
   rewrite ischained_conscons in Hch. destruct Hch as (Hdom,(Heq,_)).
   rewrite in_dom_upd_map in Hdom.
   destruct Hdom as [e|Hdom].
    (* b' = (x,y) *)
    clear - Hneq Heq e. rewrite <- e in *; clear e b'.
    simpl in Heq. exact (Hneq Heq).
    (* in_dom_map b' T *)
    clear - Hnex Hdom Heq.
    destruct Hnex. exists (fst b').
    rewrite Heq. destruct b'. simpl. assumption.
Qed.

Theorem set_bad3_upd_I : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (invT:(map bitstring_n (bitstring_k* bitstring_n)%type)) (x:bitstring_k)
  (y:bitstring_n) (z:bitstring_n) (I:(map Z (bitstring_n* bool)%type)) (i:Z)
  (icount:Z), (injective T) -> ((~ (in_rng_map IV T)) -> ((~ (z = IV)) ->
  ((~ (in_rng_map z T)) -> ((forall (i1:Z), (in_dom_map i1 I) ->
  ~ (z = (fst (get_map I i1)))) -> ((forall (i1:Z), (in_dom_map i1 I) ->
  ((set_bad3 (fst (get_map I i1)) Tqt T invT) <-> ((snd (get_map I
  i1)) = true))) -> ((~ (in_dom_map (x, y) T)) -> ((in_dom_map i (upd_map I
  icount (z, false))) -> ((~ ((findseq x y T) = (None:(option (list
  (bitstring_k* bitstring_n)%type))))) -> ((set_bad3 (fst (get_map (upd_map I
  icount (z, false)) i)) Tqt (upd_map T (x, y) z) (upd_map invT z (x, y))) ->
  ((snd (get_map (upd_map I icount (z, false)) i)) = true)))))))))).
Proof.
intros T T' invT x y z I i icount.
intros Hinj Hnrng znIV Hznrng nfix badflag xyndom idomI fseq Hbad.
rewrite set_bad3_def in Hbad.
destruct Hbad as (fstdominvT,(ndominvTfst,nch)).
rewrite in_dom_upd_map_excl in idomI.
destruct idomI as [e|(n,idomI)].
 (* icount = i *)
 rewrite e in *; clear e icount.
 rewrite get_upd_map_same in nch; [|rewrite get_upd_map_same;simpl;reflexivity].
 apply False_ind.
 specialize nch with (proj(findseq x y (upd_map T (pair x y) z))).
 apply nch; clear nch.
 apply findseq_last_in_dom_valid;
 [unfold inclusion; split; intros; trivial
 |intro fupseq; apply fseq; apply (findseq_updqt T (pair x y) x y z); trivial
 |rewrite in_dom_upd_map; left; reflexivity].
 (* icount <> i *)
 rewrite (get_upd_map_diff _ _ _ _ _ _ n).
 rewrite <- (badflag _ idomI).
 rewrite (get_upd_map_diff _ _ _ _ _ _ n) in fstdominvT.
 rewrite (get_upd_map_diff _ _ _ _ _ _ n) in ndominvTfst.
 rewrite (get_upd_map_diff _ _ _ _ _ _ n) in nch.
 apply nfix in idomI.
 rename idomI into znfst.
 rewrite set_bad3_def.
 repeat split.
  rewrite in_dom_upd_map in fstdominvT.
  destruct fstdominvT as [C|]; [apply False_ind; exact (znfst C)|assumption].

  rewrite (get_upd_map_diff _ _ _ _ _ _ znfst) in ndominvTfst; trivial.

  rewrite (get_upd_map_diff _ _ _ _ _ _ znfst) in nch.
  intros c C.
  specialize nch with c.
  apply nch.
  apply valid_chain_upd; assumption.
Qed.

Theorem ischained_last_in_dom_claim5 : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (c:(list (bitstring_k* bitstring_n)%type)) (xy:(bitstring_k*
  bitstring_n)%type) (xyqt:(bitstring_k* bitstring_n)%type), (inclusion Tqt
  T) -> ((injective T) -> ((~ (in_rng_map IV T)) -> ((ischained T IV
  (infix_plpl c (Cons xyqt (Nil:(list (bitstring_k* bitstring_n)%type))))
  (snd xy)) -> ((~ ((unpad (mapfst (infix_plpl c (Cons xyqt (Cons xy
  (Nil:(list (bitstring_k* bitstring_n)%type))))))) = (None:(option (list
  bool))))) -> ((in_dom_map xyqt Tqt) -> ((claim5 Tqt T) -> (ischained Tqt IV
  (infix_plpl c (Cons xyqt (Nil:(list (bitstring_k* bitstring_n)%type))))
  (snd xy)))))))).
Proof.
intros T T' c xy xy'.
intros Hsub HB2 HB1 Hch Hpad Hdom Hord.

(* We cannot induct over the premises Hch and Hpad, because the induction premises would be unfulfillable.
We have to replace Hpad with a more suited premise, which tells us exactly what we need and which is suitable
for induction at the same time. We will call it Hnone and use it instead of Hpad. *)
assert ( forall x0 y0, mem (pair x0 y0) c -> findseq x0 y0 T = None) as Hnone.
 clear - HB1 HB2 Hch Hpad.
 intros x0 y0 Hin.
 destruct (Some_or_None _ (findseq x0 y0 T)) as [n|(x,S)]; [exact n|apply False_ind].
 assert (findseq x0 y0 T <> None) as Hch'.
  rewrite S; intro C; inversion C.  
 clear x S.
 remember Hch' as Hpad'; clear HeqHpad'.
 apply findseq_ischained in Hch'.
 apply findseq_unpad in Hpad'.
 generalize Hch' Hpad'; clear Hch' Hpad'.
 generalize (proj (findseq x0 y0 T)) as c'. intros.
 remember (claim4 T HB1 HB2 c' (infix_plpl c (Cons xy' Nil)) (pair x0 y0) xy) as C; clear HeqC.
 clear HB2 HB1.
 simpl in C.
 specialize (C Hch' Hpad'); clear Hch' Hpad'.
 rewrite <- Append_assoc in C. simpl in C.
 specialize (C Hch Hpad); clear - Hin C.
 rewrite mem_append in C. 
 apply C. left; assumption.
clear Hpad.

generalize Hch Hnone; clear Hch Hnone.
generalize IV as Y.
apply list_ind with (l := c).
 (* case c = [] *)
 intros. clear - Hsub Hdom Hch. rewrite append_nil in *.
 rewrite ischained_cons in *.
 destruct Hch as (_,(Heq,Heq')).
 repeat split; try assumption.
 unfold inclusion in Hsub. destruct Hsub as (_,Hsub).
 specialize (Hsub xy' Hdom).
 rewrite <- Hsub in Heq'. assumption.
 (* case c = a::al *)
 clear Hdom HB1 HB2.
 intros a al. intros IH. intros.
(* first we solve the premises for IH. this will give us the chainedness of al in T',
which we can use to fulfill the premises of Claim5 (in particular in_dom(hd(al)) if al is not Nil *)
 destruct al as [|a' al'].
  (* case al = [] *)
  rewrite append_nil in *. rewrite append_cons in *. rewrite append_nil in *. rewrite ischained_conscons in Hch.
  destruct Hch as (Hdom,(HeqY,(HeqTa,Hch))).
  specialize (IH (snd xy') Hch); clear Hch.
  assert ( forall x0 y0, mem (pair x0 y0) Nil -> findseq x0 y0 T = None) as Hall.
   clear. intros. 
   simpl in H. exact (False_ind _ H).
  specialize (IH Hall); clear Hall.
  (* now the premises for the IH are solved, we want to use Claim5 *)
  unfold claim5 in Hord.
  destruct a as (a1,a2).
  specialize (Hord a1 a2 (fst xy')).
  rewrite HeqTa in Hord.
  destruct xy' as (x',y').
  simpl in Hord.
  assert ( in_dom_map (x',y') T' ) as Hdom'.
   clear - IH.
   rewrite ischained_cons in IH. destruct IH as (Hdom,_). assumption.
  specialize (Hord Hdom Hdom'); clear Hdom Hdom'.
  specialize (Hnone a1 a2).
  simpl in Hnone.
  assert ((a1, a2) = (a1, a2) \/ False) as Heq. intuition.
  specialize (Hnone Heq); clear Heq.
  specialize (Hord Hnone).
  (* the rest is easy *)
  rename Hord into Hdom. clear - Hsub IH Hdom HeqTa HeqY. 
  unfold inclusion in Hsub. destruct Hsub as (_,Hsub).
  specialize (Hsub (a1,a2) Hdom). rewrite <- Hsub in HeqTa; clear Hsub.
  rewrite ischained_conscons.
  repeat split; assumption.
  (* case al = a'::al' *)
  repeat rewrite append_cons in *. rewrite ischained_conscons in Hch.
  destruct Hch as (Hdom,(HeqY,(HeqTa,Hch))).
  specialize (IH (snd a') Hch); clear Hch.
  assert ( forall x0 y0, mem (pair x0 y0) (Cons a' al') -> findseq x0 y0 T = None ) as Hall.
   clear - Hnone.
   intros. apply Hnone. clear - H.
   simpl in *; right.
   assumption.
  specialize (IH Hall); clear Hall.
  (* now the premises for the IH are solved, we want to use Claim5 *)
  unfold claim5 in Hord.
  destruct a as (a1,a2).
  destruct a' as (a1',a2'); simpl in *.
  specialize (Hord a1 a2 a1').
  specialize (Hord Hdom); rewrite HeqTa in Hord; clear Hdom.
  assert ( in_dom_map (a1',a2') T' ) as Hdom.
   clear - IH.
   rewrite <- (append_nil _ (Cons (a1',a2') (infix_plpl al' (Cons xy' Nil)))) in IH.
   apply ischained_app in IH. destruct IH as (_,(Hdom,_)). assumption.
  specialize (Hord Hdom); clear Hdom.
  specialize (Hnone a1 a2).
  assert (in_dom_map (a1, a2) T') as Hdom.
   apply Hord; apply Hnone; left; reflexivity.
  (* the rest is easy *)
  clear - Hsub IH Hdom HeqTa HeqY.
  unfold inclusion in Hsub. destruct Hsub as (_,Hsub).
  specialize (Hsub (a1,a2) Hdom). rewrite <- Hsub in HeqTa; clear Hsub.
  rewrite ischained_conscons.
  repeat split; assumption.
Qed.

Theorem findseq_set_bad3_claim5 : forall (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (invT:(map bitstring_n (bitstring_k* bitstring_n)%type))
  (x:bitstring_k) (y:bitstring_n), (inclusion Tqt T) -> ((inverse T invT) ->
  ((injective T) -> ((~ (in_rng_map IV T)) -> ((~ (set_bad3 y Tqt T invT)) ->
  ((claim5 Tqt T) -> ((~ ((findseq x y T) = (None:(option (list (bitstring_k*
  bitstring_n)%type))))) -> ~ ((findseq x y Tqt) = (None:(option (list
  (bitstring_k* bitstring_n)%type)))))))))).
Proof.
intros T T' invT x y.
intros Hsub Hinv HB2 HB1 Hnbad Hord Hseq.
intro C.

rewrite set_bad3_def in Hnbad.
apply Hnbad; clear Hnbad.
(* we have  ~
          ((in_dom_map y invT = true /\
            in_dom_map (get_map invT y) T' <> true) /\
           (forall c_619 : list (prod bitstring bitstring),
            ~ valid_chain (Append c_619 (Cons (get_map invT y) Nil)) T))

1. if ~ (in_dom_map y invT = true) -> this is a contradiction to Hseq! y has to be in rng(T)

2. if in_dom invT[y] T' = true -> we have to use Claim5 and maybe reason inductively. all elements of the chain have
                               to be in T', so we can conclude find_seq x y T' <> None

3. if ex c, valid_chain c++invT[y] T -> this is a contradiction to find_seq x y T <> None which tells us
                                 valid_chain (proj find_seq x y T)++(x,y) T,
                                 i.e. valid_chain c'++invT[y]::(x,y), so contradiction to prefix-freeness
*)
repeat split.

 (* 1. we show in_dom y invT = true *)
 clear - HB1 HB2 Hsub Hinv Hseq C. (* don't need Hord here *)
 apply inverse_rng_dom with (T := T); [assumption|clear Hinv].
 remember Hseq as Hpad; clear HeqHpad; rename Hseq into Hch.
 apply findseq_ischained in Hch.   
 apply findseq_unpad in Hpad.
 generalize Hch Hpad; clear Hch Hpad.
 generalize (proj (findseq x y T)) as c. intros.
 case exists_last with (l := c).
  (* c = [] *)
  clear - HB1 HB2 Hsub Hch Hpad C.
  intro e. rewrite e in *; clear e c.
  apply False_ind.
  apply inclusion_not_rng with (Tqt := T') in HB1; [|assumption].
  apply inclusion_injective with (Tqt := T') in HB2; [|assumption].
  clear Hsub.
  rewrite ischained_nil in Hch. rewrite <- (ischained_nil T') in Hch. 
  remember (findseq_complete T' x y Nil HB2 HB1 Hch Hpad) as Hseq'; clear - Hseq' C.
  exact (Hseq' C).
  (* c = al@[a] *)
  clear - Hch.
  intro e. destruct e as (c',(xy',e)).
  rewrite e in Hch; clear e c.  
  apply ischained_app in Hch. destruct Hch as (_,(Hdom,Heq)).
  rewrite ischained_nil in Heq.
  apply in_dom_in_rng in Hdom.
  rewrite Heq in Hdom. assumption.

 (* 2. here we have the assumption invT[y] in dom(T'). we can therefore use Claim5 to show that
       find_seq x y T' <> None, yielding a contradiction to C. *)
 intros Hdom.
 remember Hseq as Hpad; clear HeqHpad; rename Hseq into Hch.
 apply findseq_ischained in Hch.
 apply findseq_unpad in Hpad.
 generalize Hch Hpad; clear Hch Hpad.
 generalize (proj (findseq x y T)) as c. intros.
 case exists_last with (l := c).
  (* c = [] *)
  clear - HB1 HB2 Hsub Hch Hpad C.
  intro e. rewrite e in *; clear e c.
  apply inclusion_not_rng with (Tqt := T') in HB1; [|assumption].
  apply inclusion_injective with (Tqt := T') in HB2; [|assumption].
  clear Hsub.
  rewrite ischained_nil in Hch. rewrite <- (ischained_nil T') in Hch. 
  remember (findseq_complete T' x y Nil HB2 HB1 Hch Hpad) as Hseq'; clear - Hseq' C.
  exact (Hseq' C).
  (* c = al@[a] *) (* all premises are needed here *)
  intro e. destruct e as (xy',(c',e)).
  rewrite e in Hch, Hpad; clear e c.  
  assert ( get_map invT y = xy' ) as e.
   clear - Hinv Hch.
   apply ischained_app in Hch. destruct Hch as (_,(Hdom,Heq)).
   rewrite ischained_nil in Heq.
   unfold inverse in Hinv. destruct Hinv as (Hinv,_).
   specialize (Hinv xy' Hdom). destruct Hinv as (_,Heq').
   rewrite Heq in Heq'. assumption.
  rewrite e in *; clear e.
  clear Hinv invT.
  rewrite <- Append_assoc in Hpad. simpl in Hpad. 
  remember (ischained_last_in_dom_claim5 T T' c' (pair x y) xy' Hsub HB2 HB1 Hch Hpad Hdom Hord) as Hch'; clear - Hsub HB1 HB2 Hch' Hpad C.
  apply inclusion_not_rng with (Tqt := T') in HB1; [|assumption].
  apply inclusion_injective with (Tqt := T') in HB2; [|assumption].
  remember (findseq_complete T' x y (infix_plpl c' (Cons xy' Nil)) HB2 HB1) as Hseq; clear - Hseq Hpad Hch' C.
  rewrite <- Append_assoc in Hseq. simpl in Hseq. 
  specialize (Hseq Hch' Hpad); clear - Hseq C.
  exact (Hseq C).

 (* 3. with Hseq and Hval we obtain a contradiction to prefix-freeness. *)
 clear - Hinv Hsub HB2 HB1 Hseq C. (* don't need Hord *)
 intros c Hval.
(* again we will need to make a case distinction on the chain returned by find_seq x y T.
if it is [] -> then we know y = IV and (x,y) is a valid padding. but then we would have find_seq x y T' <> none,
                yielding a contradiction to C; i.e. in this case actually show the conclusion of the lemma,
                find_seq x y T' <> None, instead of showing a contradiction to the other premises
if it has the form al@[a] -> then we know from Hseq that ischained(T,IV,al++[a],y).
                             from Hval we know that ischained(T,IV,c++[invT[y]],z0).
                             we conclude a = invT[y] since we have from the first chain T[a] = y.
                             so we can rewrite the second chain as ischained(T,IV,c++a,y).
                             then we use ischained_inj to obtain al=c.
                             now: from the original Hseq we knew al++[a]::(x,y) is a valid padding
                                  from the original Hval we know c++invT[y] = al++[a] is a valid padding
                             contradiction to prefix-freeness! *)
 unfold valid_chain in Hval. destruct Hval as (z0,(Hch,Hpad)).
 remember Hseq as Hpad'; clear HeqHpad'; rename Hseq into Hch'.
 apply findseq_ischained in Hch'.
 apply findseq_unpad in Hpad'.
 generalize Hch' Hpad'; clear Hch' Hpad'.
 generalize (proj (findseq x y T)) as c'. intros.
 case exists_last with (l := c').
  (* c = [] *)
  clear - HB1 HB2 Hsub Hch' Hpad' C.
  intro e. rewrite e in *; clear e c'.
  apply inclusion_not_rng with (Tqt := T') in HB1; [|assumption].
  apply inclusion_injective with (Tqt := T') in HB2; [|assumption].
  clear Hsub.
  rewrite ischained_nil in Hch'. rewrite <- (ischained_nil T') in Hch'. 
  remember (findseq_complete T' x y Nil HB2 HB1 Hch' Hpad') as Hseq'; clear - Hseq' C.
  exact (Hseq' C).
  (* c = al@[a] *)
  clear - HB2 HB1 Hinv Hch Hpad Hch' Hpad'.
  intro e. destruct e as (a,(al,e)).
  rewrite e in Hch', Hpad'; clear e c'.
  assert ( get_map invT y = a ) as e.
   clear - Hinv Hch'.
   apply ischained_app in Hch'. destruct Hch' as (_,(Hdom,Heq)).
   rewrite ischained_nil in Heq.
   unfold inverse in Hinv. destruct Hinv as (Hinv,_).
   specialize (Hinv a Hdom). destruct Hinv as (_,Heq').
   rewrite Heq in Heq'. assumption.
  rewrite e in *; clear e.
  clear Hinv invT.
  apply ischained_app in Hch. destruct Hch as (Hch,_).
  remember (claim4 T HB1 HB2 c (infix_plpl al (Cons a Nil)) a (pair x y) Hch Hpad Hch' Hpad') as C; clear - C.
  apply C. apply last_in.
Qed.

Theorem claim5_upd : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (invT:(map bitstring_n (bitstring_k* bitstring_n)%type)) (x:bitstring_k)
  (y:bitstring_n), (injective T) -> ((~ (in_rng_map IV T)) -> ((inverse T
  invT) -> ((in_dom_map (x, y) T) -> ((~ (set_bad3 y Tqt T invT)) ->
  ((claim5 Tqt T) -> (claim5 (upd_map Tqt (x, y) (get_map T (x, y))) T)))))).
Proof.
intros T T' invT x y.
intros HB2 HB1 Hinv Hdom Hnbad Hord.
unfold claim5.
intros x' y' x0.
remember (get_map T (x', y')) as y0. rename Heqy0 into Hnext.
intros Hdom' Hdom0 Hnone.
(* from Hdom0 we know either (x0,y0) = (x,y) or (x0,y0) was already in dom(T') *)
rewrite in_dom_upd_map in Hdom0. destruct Hdom0 as [e|Hdom0'].
 (* case (x0,y0) = (x,y) *)
 inversion e. 
 rewrite <- H1 in *; clear e H0 H1 y0.
 rewrite set_bad3_def in Hnbad.
 assert ( get_map invT y = pair x' y' ) as e.
  clear - Hinv Hdom' Hnext.
  unfold inverse in Hinv. destruct Hinv as (Hinv,_).
  specialize (Hinv (pair x' y') Hdom'); clear Hdom'.
  destruct Hinv as (_,Hinv). rewrite <- Hnext in Hinv.
  assumption.
 rewrite e in Hnbad; clear e.
 assert (in_dom_map y invT) as yinvT.
  clear - Hinv Hdom' Hnext.
  unfold inverse in Hinv. destruct Hinv as (Hinv,_).
  specialize (Hinv (pair x' y') Hdom'); clear Hdom'.
  destruct Hinv as (Hinv,_). rewrite <- Hnext in Hinv.
  assumption.
 assert (forall c : list (bitstring_k * bitstring_n), ~ valid_chain (infix_plpl c (Cons (x', y') Nil)) T) as nch.
  clear - HB1 HB2 Hnone. intros c Hval.
  remember (findseq_complete_valid_chain T x' y' c HB2 HB1 Hval) as Hseq; clear HeqHseq.
  exact (Hseq Hnone).
 rewrite in_dom_upd_map; right.
 tauto.
 (* case (x0,y0) in dom(T') *)
 (* here we can use Claim5 to obtain the conclusion *)
 clear - Hord Hdom' Hnext Hdom0' Hnone.
 unfold claim5 in Hord.
 specialize (Hord x' y' x0).
 rewrite <- Hnext in Hord.
 specialize (Hord Hdom' Hdom0' Hnone).
 clear - Hord.
 apply in_dom_upd_map.
 right. assumption.
Qed.

Theorem claim5_updqt : forall (Tqt:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (T:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (invT:(map bitstring_n (bitstring_k* bitstring_n)%type)) (x:bitstring_k)
  (y:bitstring_n) (z:bitstring_n), (inclusion Tqt T) -> ((injective T) ->
  ((~ (in_rng_map IV T)) -> ((inverse T invT) -> ((~ (in_dom_map (x, y)
  T)) -> ((~ (z = IV)) -> ((~ (in_rng_map z T)) -> ((~ (set_bad3 y Tqt T
  invT)) -> ((claim5 Tqt T) -> (claim5 (upd_map Tqt (x, y) z) (upd_map T (x,
  y) z)))))))))).
Proof.
intros T' T invT x y z.
intros Hsub HB2 HB1 Hinv Hndom HnzIV Hnzrng Hnbad Hord.
unfold claim5.
intros x' y' x0.
remember (get_map (upd_map T (x, y) z) (x', y')) as y0; rename Heqy0 into Hnext.
intros Hdom' Hdom0 Hnone.
(* from Hdom0 we know either (x0,y0) = (x,y) or (x0,y0) was already in dom(T') *)
rewrite in_dom_upd_map in Hdom0. destruct Hdom0 as [e|Hdom0'].
 (* case (x0,y0) = (x,y) *)
 inversion e. rewrite <- H0 in *; rewrite <- H1 in *; clear H0 H1 e y0.
 rewrite in_dom_upd_map_excl in Hdom'; destruct Hdom' as [e|(n0,Hdom')].
  (* case (x',y') = (x,y) *)
  clear - e. rewrite e.
  rewrite in_dom_upd_map; left; reflexivity.
  (* case (x',y') <> (x,y). this implies (x',y') in dom(T') with Hdom'. *)
  rewrite in_dom_upd_map; right.
  rewrite get_upd_map_diff in Hnext; [|trivial].
  assert ( findseq x' y' T = None ) as Hnone'; [|clear Hnone; rename Hnone' into Hnone].
   destruct (Some_or_None _ (findseq x' y' T)) as [|(s,Hsome)]; [assumption|].
   assert (findseq x' y' T <> None) as Hseq.
    intro C; rewrite Hsome in C; inversion C.
   rewrite findseq_inclusion_upd_eq with (Tqt := T) in Hnone; auto.
   unfold inclusion; auto.
  rewrite set_bad3_def in Hnbad.
  assert ( get_map invT y = pair x' y' ) as e.
   clear - Hinv Hdom' Hnext.
   unfold inverse in Hinv. destruct Hinv as (Hinv,_).
   specialize (Hinv (pair x' y') Hdom'); clear Hdom'.
   destruct Hinv as (_,Hinv). rewrite <- Hnext in Hinv.
   assumption.
  rewrite e in Hnbad; clear e.
  assert (in_dom_map y invT) as yinvT.
   clear - Hinv Hdom' Hnext.
   unfold inverse in Hinv. destruct Hinv as (Hinv,_).
   specialize (Hinv (pair x' y') Hdom'); clear Hdom'.
   destruct Hinv as (Hinv,_). rewrite <- Hnext in Hinv.
   assumption.
  assert (forall c : list (bitstring_k * bitstring_n), ~ valid_chain (infix_plpl c (Cons (x', y') Nil)) T) as nch.
   clear - HB1 HB2 Hnone. intros c Hval.
   remember (findseq_complete_valid_chain T x' y' c HB2 HB1 Hval) as Hseq; clear HeqHseq.
   exact (Hseq Hnone).
  tauto.
 (* case (x0,y0) in dom(T') *)
 (* here we can use Claim5 to obtain the conclusion *)
 rewrite in_dom_upd_map_excl in Hdom'.
 destruct Hdom' as [e|(n0,Hdom')].
  (* case (x',y') = (x,y) *)
  clear - e. rewrite e.
  rewrite in_dom_upd_map; left; reflexivity.
  (* case (x',y') in dom(T) *)
  rewrite in_dom_upd_map; right.
  unfold claim5 in Hord.
  specialize (Hord x' y' x0).
  specialize (Hord Hdom').
  rewrite get_upd_map_diff in Hnext; [|trivial].
  rewrite <- Hnext in Hord.
  specialize (Hord Hdom0').
  apply Hord; clear Hord.
  clear - Hsub HB2 HB1 HnzIV Hnzrng Hndom Hnone.
  destruct (Some_or_None _ (findseq x' y' T)) as [|(s,Hsome)]; [assumption|].
  assert (findseq x' y' T <> None) as Hseq.
   intro C; rewrite Hsome in C; inversion C.
  rewrite findseq_inclusion_upd_eq with (Tqt := T) in Hnone; auto.
  unfold inclusion; auto.
Qed.

Theorem findseq_claim5_aux : forall (Tqt:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (T:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (x:bitstring_k) (y:bitstring_n) (z:bitstring_n), (inclusion Tqt T) ->
  ((injective T) -> ((~ (in_rng_map IV T)) -> ((~ (in_rng_map z T)) ->
  ((~ (z = IV)) -> ((claim5 (upd_map Tqt (x, y) z) (upd_map T (x, y) z)) ->
  (((findseq x y Tqt) = (None:(option (list (bitstring_k*
  bitstring_n)%type)))) -> ((findseq x y (upd_map T (x, y)
  z)) = (None:(option (list (bitstring_k* bitstring_n)%type)))))))))).
Proof.
intros T' T x y z.
intros Hsub HB2 HB1 Hnzrng HnzIV Hord Hnone.
destruct (Some_or_None _ (findseq x y (upd_map T (x, y) z))) as [|(s,Hs)]; [assumption|].
assert (findseq x y (upd_map T (x, y) z) <> None) as Hch.
 intro C; rewrite Hs in C; inversion C.
apply False_ind; clear s Hs.
remember Hch as Hpad; clear HeqHpad.
apply findseq_ischained in Hch.
apply findseq_unpad in Hpad.
generalize Hch Hpad; clear Hch Hpad.
generalize (proj (findseq x y (upd_map T (pair x y) z))) as c.
intros.
case exists_last with (l := c).
 (* case c = [] *)
 intro e. rewrite e in *; clear e c.
 apply inclusion_not_rng with (Tqt := T') in HB1; [|assumption].
 apply inclusion_injective with (Tqt := T') in HB2; [|assumption].
 clear Hsub.
 rewrite ischained_nil in Hch. rewrite <- (ischained_nil T') in Hch. 
 remember (findseq_complete T' x y Nil HB2 HB1 Hch Hpad) as Hseq; clear - Hseq Hnone.
 exact (Hseq Hnone).
 (* case c = a::al *)
 intro e. destruct e as (a,(al,e)). rewrite e in *; clear e c.
 remember (ischained_last_in_dom_claim5 (upd_map T (pair x y) z) (upd_map T' (pair x y) z) al (pair x y) a) as Hbig; clear HeqHbig.
 assert ( inclusion (upd_map T' (pair x y) z) (upd_map T (pair x y) z) ) as Hsub'.
  clear - Hsub.
  apply inclusion_updqtqt; assumption.
 specialize (Hbig Hsub'); clear Hsub'.
 assert ( injective (upd_map T (pair x y) z) ) as HB2'.
  clear - HB2 Hnzrng.
  apply injective_upd; assumption.
 specialize (Hbig HB2').
 assert ( ~ in_rng_map IV (upd_map T (pair x y) z) ) as HB1'.
  clear - HB1 HnzIV.
  apply not_rng_upd; assumption.
 specialize (Hbig HB1').
 simpl in Hbig.
 specialize (Hbig Hch).
 rewrite <- Append_assoc in Hpad. simpl in Hpad. 
 specialize (Hbig Hpad).
 assert ( in_dom_map a (upd_map T' (pair x y) z) ) as Hdom.
  unfold claim5 in Hord.
  destruct a as (a1,a2).
  specialize (Hord a1 a2 x).
  apply Hord; clear Hord.
   (* a in dom(upd(T,(x,y),z)) *)
   clear - Hch. apply ischained_app in Hch.
   destruct Hch as (_,(Hdom,_)). assumption.
   (* (x,y) in dom(upd(T',(x,y),z)), where y = upd(T,(x,y),z)[a] *)
   apply ischained_app in Hch.
   destruct Hch as (_,(_,Heq)). rewrite ischained_nil in Heq.
   rewrite Heq.
   clear. rewrite in_dom_upd_map; left; reflexivity.
   (* find_seq fst(a) snd(a) upd(T,(x,y),z) = None *)
   clear - HB2' HB1' Hch Hpad.
   destruct (Some_or_None _ (findseq a1 a2 (upd_map T (x, y) z))) as [|(s,Hs)]; [assumption|].
   assert (findseq a1 a2 (upd_map T (x, y) z) <> None) as Hch'.
    intro C; rewrite Hs in C; inversion C.
   apply False_ind; clear s Hs.
   remember Hch' as Hpad'; clear HeqHpad'.
   apply findseq_ischained in Hch'.
   apply findseq_unpad in Hpad'.
   generalize Hch' Hpad'; clear Hch' Hpad'.
   generalize (proj (findseq a1 a2 (upd_map T (pair x y) z))) as c'.
   intros.
   remember (claim4 (upd_map T (pair x y) z) HB1' HB2' c' (infix_plpl al (Cons (a1,a2) Nil)) (a1,a2) (pair x y)) as C; clear HeqC.
   clear HB1' HB2'.
   specialize (C Hch' Hpad'); clear Hch' Hpad'.
   rewrite <- Append_assoc in C. simpl in C. 
   specialize (C Hch Hpad); clear Hch Hpad.
   apply C. apply last_in.
 clear HB1' HB2'.
 specialize (Hbig Hdom); clear Hdom.
 specialize (Hbig Hord); clear Hord.
 assert ( injective (upd_map T' (pair x y) z) ) as HB2'.
  clear - Hsub HB2 Hnzrng.
  apply injective_upd.
  apply inclusion_not_rng with (T := T); assumption.
  apply inclusion_injective with (T := T); assumption.
 assert ( ~ in_rng_map IV (upd_map T' (pair x y) z) ) as HB1'.
  clear - Hsub HB1 HnzIV.
  apply not_rng_upd; [|assumption].
  apply inclusion_not_rng with (T := T); assumption.
 remember (findseq_complete (upd_map T' (pair x y) z) x y (infix_plpl al (Cons a Nil)) HB2' HB1' Hbig) as Hseq; clear HeqHseq.
 rewrite <- Append_assoc in Hseq. simpl in Hseq. 
 specialize (Hseq Hpad).
 clear - Hsub HB1 HB2 HB1' HB2' Hseq Hnone.
 apply inclusion_not_rng with (Tqt := T') in HB1; [|assumption].
 apply inclusion_injective with (Tqt := T') in HB2; [|assumption].
 clear Hsub.
 remember (findseq_helpful_upd T' x x y y z HB2 HB1 Hnone Hseq) as Hin; clear HeqHin.
 clear Hnone HB1 HB2.
 remember Hseq as Hpad; clear HeqHpad; rename Hseq into Hch.
 apply findseq_ischained in Hch.
 apply findseq_unpad in Hpad.
 generalize Hch Hpad Hin; clear Hch Hpad Hin.
 generalize (proj (findseq x y (upd_map T' (pair x y) z))) as c; intros.
 remember (claim4 (upd_map T' (pair x y) z) HB1' HB2' c c (pair x y) (pair x y) Hch Hpad Hch Hpad) as C; clear - Hin C.
 exact (C Hin).
Qed.

Theorem findseq_claim5 : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (invT:(map bitstring_n (bitstring_k* bitstring_n)%type)) (x:bitstring_k)
  (y:bitstring_n) (z:bitstring_n), (inclusion Tqt T) -> ((injective T) ->
  ((~ (in_rng_map IV T)) -> ((inverse T invT) -> ((~ (in_dom_map (x, y)
  T)) -> ((~ (in_rng_map z T)) -> ((~ (z = IV)) -> ((~ (set_bad3 y Tqt T
  invT)) -> ((claim5 Tqt T) -> (((findseq x y Tqt) = (None:(option (list
  (bitstring_k* bitstring_n)%type)))) -> ((findseq x y (upd_map T (x, y)
  z)) = (None:(option (list (bitstring_k* bitstring_n)%type))))))))))))).
Proof.
intros T T' invT x y z.
intros Hinc Hinj HnrngIV Hinv Hndom Hnrngz HznIV Hnbad Hord Hseq.
apply (claim5_updqt T' T invT x y z) in Hord; try assumption.
apply (findseq_claim5_aux T' T x y z); assumption.
Qed.

Theorem ROmapinT_upd : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (ROmap:(map (list bool) (bitstring_n* Z)%type))
  (x:bitstring_k) (y:bitstring_n) (z:bitstring_n) (i:Z), (injective T) ->
  ((~ (in_rng_map IV T)) -> ((~ (in_dom_map (x, y) T)) -> ((~ (z = IV)) ->
  ((~ (in_rng_map z T)) -> ((ROmapinT ROmap T) -> ((~ ((findseq x y
  T) = (None:(option (list (bitstring_k* bitstring_n)%type))))) ->
  ((~ (in_dom_map (proj (unpad (mapfst (infix_plpl (proj (findseq x y T))
  (Cons (x, y) (Nil:(list (bitstring_k* bitstring_n)%type))))))) ROmap)) ->
  (ROmapinT (upd_map ROmap (proj (unpad (mapfst (infix_plpl (proj (findseq x
  y T)) (Cons (x, y) (Nil:(list (bitstring_k* bitstring_n)%type))))))) (z,
  i)) (upd_map T (x, y) z))))))))).
Proof.
intros T R x y z i.
intros Hinj HnrngIV Hndom HznIV Hnrngz RinT Hseq HndomR.
unfold ROmapinT in *.
destruct RinT as (Hex,(HRinT,HTinR)).
assert (inclusion T T) as incTT. unfold inclusion; auto.
split.
 (* case exists x0 y0 ... *)
 intros m Hmdom.
 rewrite in_dom_upd_map in Hmdom.
 destruct Hmdom as [e|Hmdom].
  (* case e *)
  exists x, y.
  rewrite (findseq_useless_updqt T T x x y y z); try assumption.
  repeat split; [assumption|rewrite e; reflexivity|rewrite in_dom_upd_map; left; reflexivity].
  (* case Hmdom *)
  specialize (Hex m Hmdom).
  destruct Hex as (x0,(y0,(Hseq0,(meq0,Hdom0)))).
  exists x0,y0.
  rewrite (findseq_useless_updqt T T x x0 y y0 z); try assumption.
  repeat split; try assumption.
  rewrite in_dom_upd_map; right; assumption.
split.
 (* case domR in domT ... *)
 intros x0 y0 Hseq0 HdomR.
 rewrite (findseq_useless_updqt T T x x0 y y0 z) in *; try assumption.
 rewrite in_dom_upd_map in HdomR.
 destruct HdomR as [e|HdomR].
  (* case e *)
  apply findseq_mapfst_eq in e; try assumption. rewrite e.
  rewrite in_dom_upd_map; left; reflexivity.
  (* case HdomR *)
  specialize (HRinT x0 y0 Hseq0 HdomR).
  rewrite in_dom_upd_map; right; assumption.
 (* case domT in domR ... *)
 intros x0 y0 Hseq0 HdomT.
 rewrite (findseq_useless_updqt T T x x0 y y0 z) in *; try assumption.
 rewrite in_dom_upd_map_excl in HdomT.
 destruct HdomT as [e|(n,HdomT)].
  (* case e *)
  inversion e.
  split; [rewrite in_dom_upd_map; left; reflexivity| repeat rewrite (get_upd_map_same); reflexivity].
  (* case HdomT *)
  specialize (HTinR x0 y0 Hseq0 HdomT).
  destruct HTinR as (Hdom0,Hget0).
  split; [rewrite in_dom_upd_map; right; assumption|].
  rewrite (get_upd_map_diff).
  rewrite Hget0.
  rewrite (get_upd_map_diff _ _ _ _ _ _ n); reflexivity.
  intro C; symmetry in C.
  apply findseq_mapfst_eq in C; try assumption. exact (n C).
Qed.  

Theorem ROmapinT_upd2 : forall (T:(map (bitstring_k* bitstring_n)%type
  bitstring_n)) (Tqt:(map (bitstring_k* bitstring_n)%type bitstring_n))
  (invT:(map bitstring_n (bitstring_k* bitstring_n)%type)) (x:bitstring_k)
  (y:bitstring_n) (z:bitstring_n) (ROmap:(map (list bool) (bitstring_n*
  Z)%type)), (inclusion Tqt T) -> ((injective T) -> ((~ (in_rng_map IV T)) ->
  ((inverse T invT) -> ((~ (in_dom_map (x, y) T)) -> ((~ (in_rng_map z T)) ->
  ((~ (z = y)) -> ((~ (z = IV)) -> ((forall (x0:bitstring_k), ~ (in_dom_map (
  x0, z) T)) -> ((~ (set_bad3 y Tqt T invT)) -> ((claim5 Tqt T) ->
  (((findseq x y Tqt) = (None:(option (list (bitstring_k*
  bitstring_n)%type)))) -> ((ROmapinT ROmap T) -> (ROmapinT ROmap (upd_map T
  (x, y) z)))))))))))))).
Proof.
intros T T' invT x y z R.
intros Hinc Hinj HnrngIV Hinv Hndom Hnrngz Hzny HznIV Hzndom' Hnbad Hord Hseq HRinT.
assert ( ~ (exists x1 : bitstring_k, in_dom_map (x1, z) T)) as Hzndom.
 intro C; destruct C as (x1,C); exact (Hzndom' x1 C).
clear Hzndom'.
unfold ROmapinT in *.
destruct HRinT as (Hex,(RinT,TinR)).
assert (forall A B C:Prop, A -> (A->B) -> C -> (A /\ B /\ C)) as tmpconj.
 intuition.
apply tmpconj.
 (* case exists x0, x1 ... *)
 clear tmpconj.
 intros m Hmdom.
 specialize (Hex m Hmdom).
 destruct Hex as (x0,(y0,(Hseq0,(Hm0,Hdom0)))).
 assert (in_dom_map (x0, y0) (upd_map T (x, y) z)) as Hupdom0.
  rewrite in_dom_upd_map; right; trivial.
 exists x0, y0.
 rewrite findseq_upd_nohelp; trivial.
 repeat split; trivial.
 (* case domR in domT *)
 clear tmpconj.
 intros Hex' x0 y0 Hseq0 Hdom0.
 specialize (Hex' _ Hdom0).
 destruct Hex' as (x1,(y1,(Hseq1,(Hm1,Hdom1)))).
 rewrite <- (findseq_mapfst_eq _ _ _ _ _ Hseq1 Hseq0 Hm1); trivial.
 (* case domT in domR *)
 clear tmpconj.
 intros x0 y0 Hseq0 Hdom0.
 remember Hseq0 as F; clear HeqF.
 rewrite findseq_upd_nohelp; trivial.
 rewrite findseq_upd_nohelp in Hseq0; trivial.
 rewrite in_dom_upd_map in Hdom0.
 destruct Hdom0 as [e|indom0].
  (* case e *)
  inversion e. rewrite H0 in *; rewrite H1 in *. clear e H0 H1.
  destruct F.
  apply (findseq_claim5 T T' invT); trivial.
  (* case indom0 *)
  rewrite get_upd_map_diff.
  apply (TinR _ _ Hseq0 indom0).
  intro C.
  rewrite C in Hndom.
  exact (Hndom indom0).
Qed.

Theorem ROmapinT_upd3 : forall (ROmap:(map (list bool) (bitstring_n*
  Z)%type)) (m:bitstring_k) (h:bitstring_n) (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)), (injective T) -> ((~ (in_rng_map IV T)) ->
  ((~ (in_dom_map (m, h) T)) -> (((findseq m h T) = (None:(option (list
  (bitstring_k* bitstring_n)%type)))) -> forall (z:bitstring_n),
  (~ (z = IV)) -> ((~ (in_rng_map z T)) -> ((~ (z = h)) ->
  ((~ exists x0:bitstring_k, (in_dom_map (x0, z) T)) -> ((ROmapinT ROmap
  T) -> (ROmapinT ROmap (upd_map T (m, h) z))))))))).
Proof.
intros ROmap m h T inj nrngIVT ndommh fseqmh z znIV nrngzT znh nex0 RinT.
unfold ROmapinT in *.
destruct RinT as (RinT1,(RinT2,RinT3)).
assert (forall A B C : Prop, A -> (A -> B) -> C -> A /\ B /\ C) as conj'.
 intuition.
apply conj'.
(* Part A *)
intros m0 m0domR.
apply RinT1 in m0domR.
destruct m0domR as (x, exy).
destruct exy as (y, (fseqxy,(m0eq,xydomT))).
exists x. exists y. 
repeat split.
rewrite (findseq_upd_nohelp _ _ _ _ _ _ inj nrngIVT ndommh znIV nrngzT znh nex0);
 trivial; rewrite in_dom_upd_map; right; trivial.
rewrite (findseq_upd_nohelp _ _ _ _ _ _ inj nrngIVT ndommh znIV nrngzT znh nex0);
 trivial; rewrite in_dom_upd_map; right; trivial.
rewrite in_dom_upd_map; right; trivial.
(* Part B *)
intros partA x y fseqxy fseqdomR.
apply partA in fseqdomR.
destruct fseqdomR as (x0,(y0,(fseq0,(mfst,dom0)))).
rewrite <- (findseq_mapfst_eq _ _ _ _ _ fseq0 fseqxy mfst).
trivial.
(* Part C *)
intros x y fseqxy xydomT.
rewrite (findseq_upd_nohelp _ _ _ _ _ _ inj nrngIVT ndommh znIV nrngzT znh nex0 xydomT) in *.
assert ((m,h)<>(x,y)) as neq.
 intro C; inversion C. rewrite H0, H1 in fseqmh.
 exact (fseqxy fseqmh).
rewrite (get_upd_map_diff _ _ _ _ _ _ neq). 
apply (RinT3 x y fseqxy).
rewrite in_dom_upd_map in xydomT.
destruct xydomT as [eq|dom]; [intuition|trivial].
Qed.

Theorem help : forall (i:Z) (I:(map Z (bitstring_n* bool)%type)) (S:(list
  bitstring_n)) (z1:bitstring_n) (z2:bitstring_n), (~ (in_dom_map i I)) ->
  ((forall (z:bitstring_n), (mem z S) -> exists i1:Z, (in_dom_map i1 I) /\
  ((fst (get_map I i1)) = z)) -> ((mem z1 (Cons z2 S)) -> exists iqt:Z,
  (in_dom_map iqt (upd_map I i (z2, false))) /\ ((fst (get_map (upd_map I i (
  z2, false)) iqt)) = z1))).
Proof.
 intros i I S z1 z2 Hndom memex mem.
 simpl in mem.
 destruct mem as [e|mem].
 (* case e *)
 rewrite e; clear e.
 exists i.
 split; [rewrite in_dom_upd_map; left; reflexivity|].
 rewrite get_upd_map_same; simpl; reflexivity.
 (* case mem *)
 specialize (memex z1 mem).
 destruct memex as [i' [Hdom Hfst] ].
 exists i'; split.
 rewrite in_dom_upd_map; right; assumption.
 rewrite get_upd_map_diff; trivial.
 intro C. subst. exact (Hndom Hdom).
Qed.

Theorem help1 : forall (I:(map Z (bitstring_n* bool)%type)) (S:(list
  bitstring_n)) (j:Z), (forall (z:bitstring_n), (mem z S) -> exists i:Z,
  (in_dom_map i I) /\ ((fst (get_map I i)) = z)) -> forall (z:bitstring_n),
  let Iqt := (upd_map I j ((fst (get_map I j)), false)) in ((mem z S) ->
  exists i:Z, (in_dom_map i Iqt) /\ ((fst (get_map Iqt i)) = z)).
Proof.
 intros I S j memex z I' mem.
 destruct (memex z mem) as [i [Hdom Hfst]]; clear memex.
 unfold I'; clear I'.
 exists i.
 assert (forall A B:Prop, A -> (A->B) -> (A /\ B)) as tmpconj.
  intuition.
 apply tmpconj.
  (* case A *)
  rewrite in_dom_upd_map; right; assumption.
  (* case B *)
  intro Hupdom.
  rewrite in_dom_upd_map_excl in Hupdom.
  destruct Hupdom as [e|(n,_)].
   (* case e *)
   subst. rewrite get_upd_map_same; simpl; reflexivity.
   (* case n *)
   rewrite get_upd_map_diff; trivial.
Qed.

Theorem help1qt : forall (I:(map Z (bitstring_n* bool)%type)) (S:(list
  bitstring_n)) (z_0:bitstring_n) (iqt:Z), (forall (z:bitstring_n), (mem z
  S) -> exists i:Z, (in_dom_map i I) /\ ((fst (get_map I i)) = z)) ->
  ((~ (in_dom_map iqt I)) -> forall (z:bitstring_n), let Iqt := (upd_map I
  iqt (z_0, true)) in ((mem z (Cons z_0 S)) -> exists i:Z, (in_dom_map i
  Iqt) /\ ((fst (get_map Iqt i)) = z))).
Proof.
intros I S z0 i' memSex ndomi' z I' memcons.
unfold I'; clear I'.
simpl in memcons.
destruct memcons as [z0z | zmemS].
 (* case z0z *)
 rewrite z0z.
 exists i'.
 apply conj.
  rewrite in_dom_upd_map. left. reflexivity.
  rewrite get_upd_map_same; auto.
 (* case zmemS *)
 apply memSex in zmemS.
 destruct zmemS as (i,(domi,fstI)).
 exists i.
 apply conj.
 rewrite in_dom_upd_map. right. trivial.
 assert (i' <> i) as neqi.
  intro eqi. rewrite eqi in ndomi'. intuition.
 rewrite (get_upd_map_diff _ _ _ _ _ _ neqi).
 trivial.
Qed.

Theorem help4 : forall (ch:(list (bitstring_k* bitstring_n)%type)) (ms:(list
  bitstring_k)) (m:(list bool)) (hash:bitstring_n), ((infix_plpl (mapfst ch)
  ms) = (pad m)) -> ((~ (ms = (Nil:(list bitstring_k)))) ->
  ((1%Z <  (length (tl ms)))%Z -> ((unpad (infix_plpl (mapfst (infix_plpl ch
  (Cons ((hd ms), hash) (Nil:(list (bitstring_k* bitstring_n)%type)))))
  (Cons (hd (tl ms)) (Nil:(list bitstring_k))))) = (None:(option (list
  bool)))))).
Proof.
 intros.
 rewrite mapfst_app, mapfst_cons, mapfst_nil. 
 apply unpad_tl_prefix.
 apply tl_length in H0; omega.
 rewrite H, unpad_pad; discriminate.
Qed.

Theorem help5 : forall (ch:(list (bitstring_k* bitstring_n)%type)) (ms:(list
  bitstring_k)) (m:(list bool)) (hash:bitstring_n) (T:(map (bitstring_k*
  bitstring_n)%type bitstring_n)), ((infix_plpl (mapfst ch) ms) = (pad m)) ->
  (((unpad (mapfst (infix_plpl ch (Cons ((hd ms), hash) (Nil:(list
  (bitstring_k* bitstring_n)%type)))))) = (None:(option (list bool)))) ->
  ((ischained T IV ch hash) -> ((injective T) -> ((~ (in_rng_map IV T)) ->
  ((~ (ms = (Nil:(list bitstring_k)))) -> ((in_dom_map ((hd ms), hash) T) ->
  ((1%Z <  (length (tl ms)))%Z -> ((findseq (hd (tl ms)) (get_map T ((hd ms),
  hash)) T) = (None:(option (list (bitstring_k* bitstring_n)%type))))))))))).
Proof.
 intros.
 apply findseq_ischained_unpad with 
  (infix_plpl ch (Cons (hd(ms), hash) Nil)); trivial.

 apply ischained_app; repeat split; trivial.
 apply ischained_nil; trivial.
 
 rewrite mapfst_app, mapfst_cons, mapfst_nil.
 apply unpad_tl_prefix.
 rewrite tl_length in H6; [omega | trivial].
 rewrite H, unpad_pad; discriminate.
Qed.

Theorem help6 : forall (m:bitstring_k) (hash:bitstring_n) (T:(map
  (bitstring_k* bitstring_n)%type bitstring_n)) (Tqt:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (invT:(map bitstring_n (bitstring_k*
  bitstring_n)%type)) (I:(map Z (bitstring_n* bool)%type)) (icount:Z),
  ((findseq m hash T) = (None:(option (list (bitstring_k*
  bitstring_n)%type)))) -> ((inclusion Tqt T) -> ((injective T) ->
  ((~ (in_rng_map IV T)) -> ((inverse T invT) -> ((~ (in_dom_map icount
  I)) -> ((forall (i_5:Z), (in_dom_map i_5 I) -> ((set_bad3 (fst (get_map I
  i_5)) Tqt T invT) <-> ((snd (get_map I i_5)) = true))) -> ((~ (in_dom_map (
  m, hash) T)) -> forall (z:bitstring_n), (~ (z = IV)) -> ((~ (in_rng_map z
  T)) -> ((~ (z = hash)) -> ((~ exists x0:bitstring_k, (in_dom_map (x0, z)
  T)) -> ((forall (i_5:Z), (in_dom_map i_5 I) -> ~ (z = (fst (get_map I
  i_5)))) -> forall (i:Z), (in_dom_map i (upd_map I icount (z, true))) ->
  (((snd (get_map (upd_map I icount (z, true)) i)) = true) ->
  (set_bad3 (fst (get_map (upd_map I icount (z, true)) i)) Tqt (upd_map T (m,
  hash) z) (upd_map invT z (m, hash))))))))))))))).
Proof.
intros m h T T' invT I icount fseq inc inj nrng inver ndomicountI b3 ndommh z znIV nrngzT znh nexx znfstI i domiI sndIi.
rewrite in_dom_upd_map in domiI.
destruct domiI.
 rewrite H in *.
 rewrite get_upd_map_same; try reflexivity.
 rewrite set_bad3_def.
 apply conj.
  unfold fst.
  rewrite in_dom_upd_map.
  left. trivial.
 apply conj.
  unfold fst.
  rewrite get_upd_map_same.
  unfold inclusion in inc.
  destruct inc.
  intro.
  apply H0 in H2.
  intuition.
  trivial.

  intros.
  unfold fst.
  rewrite get_upd_map_same; try reflexivity.
  rewrite valid_chain_upd_nohelp; try trivial.
  intro.
  apply findseq_complete_valid_chain in H0; try trivial.
  intuition.
  rewrite in_dom_upd_map. left. trivial.

assert (icount <> i) as ineqc.
  intro.
  rewrite H0 in ndomicountI.
  intuition.
rewrite (get_upd_map_diff _ _ _ _ _ _ ineqc).
rewrite (get_upd_map_diff _ _ _ _ _ _ ineqc) in sndIi.
rewrite <- (b3 _ H) in sndIi.
rewrite set_bad3_def in sndIi.
destruct sndIi.
destruct H1.
rewrite set_bad3_def.
apply conj.
 rewrite in_dom_upd_map.
 right. trivial.
apply conj.
 intro.
 rewrite get_upd_map_diff in H3; [intuition|].
 apply znfstI; trivial.

 intros.
 intro. 
 rewrite get_upd_map_diff in H3; [|apply znfstI; trivial].
 rewrite valid_chain_upd_nohelp in H3; try trivial.
 apply H2 in H3; trivial.
 unfold inverse in inver.
 destruct inver.
 rewrite in_dom_upd_map. right.
 apply H5 in H0.
 destruct H0.
 trivial.
Qed.

Theorem help6qt : forall (m:bitstring_k) (hash:bitstring_n) (T:(map
  (bitstring_k* bitstring_n)%type bitstring_n)) (Tqt:(map (bitstring_k*
  bitstring_n)%type bitstring_n)) (invT:(map bitstring_n (bitstring_k*
  bitstring_n)%type)) (I:(map Z (bitstring_n* bool)%type)) (icount:Z),
  (~ (in_dom_map icount I)) -> ((forall (i_5:Z), (in_dom_map i_5 I) ->
  ((set_bad3 (fst (get_map I i_5)) Tqt T invT) <-> ((snd (get_map I
  i_5)) = true))) -> ((~ (in_dom_map (m, hash) T)) -> forall (z:bitstring_n),
  (forall (i_5:Z), (in_dom_map i_5 I) -> ~ (z = (fst (get_map I i_5)))) ->
  forall (i:Z), (in_dom_map i (upd_map I icount (z, true))) ->
  ((set_bad3 (fst (get_map (upd_map I icount (z, true)) i)) Tqt (upd_map T (
  m, hash) z) (upd_map invT z (m, hash))) -> ((snd (get_map (upd_map I icount
  (z, true)) i)) = true)))).
Proof.
intros m h T T' invT I icount ndomicountI b3 ndommh z znfstI i domiI sndIi.
rewrite in_dom_upd_map in domiI.
destruct domiI as [ici|domiI].
 rewrite ici. rewrite get_upd_map_same. trivial. trivial.

 assert (icount <> i) as icni.
   intro ici. rewrite ici in ndomicountI. intuition.
 rewrite (get_upd_map_diff _ _ _ _ _ _ icni).
 rewrite (get_upd_map_diff _ _ _ _ _ _ icni) in sndIi.
 rewrite <- (b3 i domiI).
 rewrite set_bad3_def in sndIi.
 destruct sndIi as (b3dom,(b3ndom,b3ch)).
 rewrite set_bad3_def.
 apply conj.
   rewrite in_dom_upd_map in b3dom.
   destruct b3dom as [zI|fstinvT].
     apply (znfstI i domiI) in zI. intuition.
     trivial.
 apply conj.
  intro domgetinv.
  rewrite (get_upd_map_diff _ _ _ _ _ _ (znfstI i domiI))in b3ndom.
  intuition.

  rewrite (get_upd_map_diff _ _ _ _ _ _ (znfstI i domiI))in b3ch.
  intro c. intro valch.
  apply (valid_chain_upd _ (m,h) z) in valch.  
  apply (b3ch c valch).
  trivial.
Qed.

Theorem Inv_exists_add_i : forall (icount:Z) (I:(map Z (bitstring_n*
  bool)%type)) (Yadv:(list bitstring_n)) (zb:(bitstring_n* bool)%type),
  (Inv_exists icount I Yadv) -> (Inv_exists (icount + 1%Z)%Z (upd_map I
  icount zb) Yadv).
Proof.
intros ic I Y zb Ie.
unfold Inv_exists in *.
destruct Ie as (i,(pos,(lt,(sndt,memY)))).
exists i.
rewrite get_upd_map_diff; [|omega].
repeat split; try assumption.
omega.
Qed.

Theorem Inv_exists_upd_not_in : forall (icount:Z) (I:(map Z (bitstring_n*
  bool)%type)) (Yadv:(list bitstring_n)) (j:Z), (~ (mem (fst (get_map I j))
  Yadv)) -> ((Inv_exists icount I Yadv) -> (Inv_exists icount (upd_map I j (
  (fst (get_map I j)), false)) Yadv)).
Proof.
intros ic I Y j nmemY Ie.
unfold Inv_exists in *.
destruct Ie as (i,(pos,(lt,(sndt,memY)))).
exists i.
rewrite get_upd_map_diff; [repeat split;assumption|].
intro C; rewrite C in nmemY.
exact (nmemY memY).
Qed.
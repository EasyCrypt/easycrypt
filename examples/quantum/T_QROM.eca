require import AllCore List Distr DBool DProd DList DInterval CHoareTactic IntDiv.
(*   *) import StdOrder RField RealOrder StdBigop Bigreal BRA.
require (*  *) Matrix Tuple (* FinType *).

type from.

clone import MUniFinFun as MUFF with
  type t <- from.   (* This assume that the type of from is finite *)

type hash.

(* Remark : this implies that hash is a finite type *)
op [lossless uniform full ] dhash : hash distr.

(* Uniform distribution over from -> hash *)
op dfhash : (from -> hash) distr = dfun (fun _ => dhash).

lemma dfhash_ll: is_lossless dfhash.
proof. apply dfun_ll => ?;apply dhash_ll. qed.

lemma dfhash_uni: is_uniform dfhash.
proof. apply dfun_uni => ?; apply dhash_uni. qed.

lemma dfhash_fu: is_full dhash => is_full dfhash.
proof. move=> dhash_fu; apply dfun_fu => ?; apply dhash_fu. qed.

hint solve 0 random : dfhash_ll dfhash_uni dfhash_fu.

module type QRO_i = {
  proc init () : unit
  quantum proc h {_:from} : hash    
}.

module type QRO = {
  include QRO_i [h]
}.

module QRO : QRO_i = {
  var  h : from -> hash
  var ch : int

  proc init() = { ch <- 0; h <$ dfhash; }

  quantum proc h {x:from} = { ch <- ch + 1; return h x; }

}.
 
abstract theory Collision.
 
  type input.
  
  quantum module type AdvCol (H:QRO) = {
    proc main(i:input) : from * from
  }.
  
  module Col(A:AdvCol) = {
    proc main(i:input) = {
      var xx;
      QRO.init();
      xx <@ A(QRO).main(i);
      return (xx.`1 <> xx.`2 && QRO.h xx.`1 = QRO.h xx.`2);
    }
  }.

  (* Thm 3.9 in MZ Thesis: N is the card of hash type. *)
  axiom pr_col i_ q (A<:AdvCol{-QRO}) &m:
    let r = mu1 dhash witness in
    hoare [Col(A).main : i = i_ ==> QRO.ch <= q] =>
    Pr[Col(A).main(i_) @ &m : res] <= (27 *(q +2)^3)%r * r. 

end Collision.

(* -------------------------------------------------------------------------- *)
(* Biased distribution over boolean return true with probability p *)   

op dbfun lam = dfun (fun _ => Biased.dbiased lam).

lemma dbfun_ll lam : is_lossless (dbfun lam).
proof. apply/dfun_ll => /=; apply/Biased.dbiased_ll. qed.
hint solve 0 random : dbfun_ll.

lemma pr_dbfun_l_eq lam x (l:from list) :
  0%r <= lam <= 1%r =>
  !x \in l => uniq l =>
  mu (dbfun lam) (fun (t : from -> bool) => t x /\ forall x', x' \in l => ! t x') =
    lam * (1%r - lam) ^ size l.
proof.
  move=> lam_bound hx hl; apply (eq_trans _ (lam ^ (size [x]) * (1%r - lam) ^ size l)); last first.
  + by rewrite /= RField.expr1.
  rewrite -(dfunE_mem_uniq lam (fun _ => Biased.dbiased lam) [x] l (fun _ => pred1 true)) //=.
  + by apply Biased.dbiased_ll. + by rewrite Biased.dbiased1E /= Biased.clamp_id. + smt().
  by apply mu_eq => /#.
qed.

lemma pr_dbfun_l_pow lam x (l:from list) q : 
  0%r <= lam <= 1%r =>
  !x \in l => size l <= q =>  
  lam*(1%r-lam)^q <= 
    mu (dbfun lam) (fun t => t x /\ forall x', x' \in l => !t x').
proof.
  move=> lam_bound hm hl.
  apply (ler_trans (lam ^ 1 * (1%r - lam) ^ size l)).
  + rewrite RField.expr1; apply ler_wpmul2l; 1: by case: lam_bound.
    apply ler_wiexpn2l; [1:smt ()| 2: smt(size_ge0)].
  apply (ler_trans _ _ _ 
    (dfunE_mem_le lam (fun _ => Biased.dbiased lam) [x] l (fun _ => pred1 true) _ _ _)) => /=.
  + by apply Biased.dbiased_ll. + by rewrite Biased.dbiased1E /= Biased.clamp_id. + smt().
  by apply mu_le => /#.
qed.

lemma pr_dbfun_l lam x (l:from list) q : 
  0%r <= lam <= 1%r =>
  !x \in l => size l <= q =>  
  lam*(1%r-q%r * lam) <= 
    mu (dbfun lam) (fun t => t x /\ forall x', x' \in l => !t x').
proof.
  move=> lam_bound hm hl.
  apply: ler_trans (pr_dbfun_l_pow _ _ _ _ lam_bound hm hl).
  apply ler_wpmul2l; 1: by case: lam_bound.
  apply le_binomial => //; smt(size_ge0).
qed.

(* -------------------------------------------------------------------------- *)
(* Semi Constant Definition Property *)
abstract theory SemiConstDistr.

op k : int.

type result = bool * from * from list.

op good(bf : from -> bool, x : from, l : from list) = 
     bf x /\ (forall x', x' \in l => !bf x') /\ size l <= k.

quantum module type AdvSCD (H:QRO) = {
  proc main() : result
}.
 
module SCD (A:AdvSCD) = {
  var bf : from -> bool
  var x : from
  var l : from list

  proc _F0(p:real) = {
    var c, y;
    bf <$ dbfun p;
    QRO.init();
    y  <$ dhash; 
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }

  proc _F1(p:real) = {
    var c, y;
    bf <$ dbfun p;
    QRO.init();
    y  <$ dhash; 
    QRO.h <- fun m => if bf m then y else QRO.h m;
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }
}.

axiom advantage q lambda (A<:AdvSCD{-SCD,-QRO}) &m:
  0%r <= lambda <= 1%r =>
  hoare [SCD(A)._F0 : p = lambda ==> QRO.ch <= q] =>
  `| Pr[SCD(A)._F0(lambda) @ &m : res] - Pr[SCD(A)._F1(lambda) @ &m: res] | 
   <= (2%r * q%r + k%r + 1%r)/ 6%r * lambda^2.

end SemiConstDistr.

(* -------------------------------------------------------------------------- *)
(* Small Range Definition Property                                            *)

op difun r = dfun (fun _ => [0..r-1]).

lemma pr_difun_l_pow r x (l:from list) q i :
  0 <= i < r =>  
  !x \in l => size l <= q =>  
  1.0/r%r * (1.0 - 1.0 / r%r)^q <= 
    mu (difun r) (fun fr => fr x = i /\ forall m', m' \in l => fr m' <> i).
proof.
  move=> hi hm hl.
  pose lam := 1.0/r%r.
  apply (ler_trans (lam ^ 1 * (1%r - lam) ^ size l)).
  + rewrite RField.expr1; apply ler_wpmul2l; 1: smt().
    apply ler_wiexpn2l; [1:smt ()| 2: smt(size_ge0)].
  apply (ler_trans _ _ _ 
    (dfunE_mem_le lam (fun _ => [0..r-1]) [x] l (fun _ => pred1 i) _ _ _)) => /=.
  + by apply dinter_ll => /#. + by rewrite dinter1E /#. + smt().
  by apply mu_le => /#.
qed.

lemma pr_difun_l r x (l:from list) q i :
  0 <= i < r =>  
  !x \in l => size l <= q =>  
  1.0/r%r * (1.0 - q%r / r%r) <= 
    mu (difun r) (fun fr => fr x = i /\ forall m', m' \in l => fr m' <> i).
proof.
  move=> i_bound hm hl.
  apply: ler_trans (pr_difun_l_pow _ _ _ _ _ i_bound hm hl).
  apply ler_wpmul2l; 1: smt(). 
  apply le_binomial => //; smt(size_ge0).
qed.

abstract theory SmallRange.

module type SR_i = {
  proc init (r: int) : unit
  quantum proc h {_:from} : hash    
}.

module type SR = {
  include SR_i [-init]
}.


quantum module type AdvSR (H:SR) = {
  proc main(r:int) : bool
}.

module SR : SR_i = {
  var rh : hash list
  var fr : from -> int
  proc init (r:int) = {
    rh <$ dlist dhash r;
    fr <$ difun r; 
    QRO.ch <- 0;
    QRO.h <- fun x => nth witness rh (fr x); 
  } 

  include QRO [h]
}.

module SRO : SR_i = {
  proc init (r:int) = {
    SR.fr <$ difun r; 
    QRO.init();
  } 

  include QRO [h]
}.

module IND_SR (H:SR_i, A:AdvSR) = {
  proc main(r:int) : bool = {
    var b;

    H.init(r);
    b <@ A(H).main(r);
    return b;
  }
}.

(* This bound comes from Corollary 4.15 of Mark Zhandry's thesis *)
axiom advantage (q:int) r_ (A<:AdvSR{-SR,-QRO}) &m:
  0 < r_ => 
  hoare [IND_SR(SRO,A).main : r = r_ ==> QRO.ch <= q] => 
  `| Pr[IND_SR(SRO,A).main(r_) @ &m : res] - Pr[IND_SR(SR,A).main(r_) @ &m : res] | <= 
      (27 * q^3)%r / r_%r.

module type SRr_i = {
  proc init (r: int) : unit
  quantum proc h {_:from} : int * hash    
}.

module type SRr = {
  include SRr_i [-init]
}.

module SRr: SRr_i = {
  import var SR
  proc init (r:int) = {
    rh <$ dlist dhash r;
    fr <$ difun r; 
    QRO.ch <- 0;
    QRO.h <- fun x => nth witness rh (fr x); 
  } 

  quantum proc h {x:from} = {
    QRO.ch <- QRO.ch + 1;
    return (fr x, QRO.h x);
  }
}.

module SROr : SRr_i = {
  import var SR
  proc init (r:int) = {
    fr <$ difun r; 
    QRO.init();
  } 

  include SRr [h]

}.

quantum module type AdvSRr (H:SRr) = {
  proc main(r:int) : bool
}.

module IND_SRr (H:SRr_i, A:AdvSRr) = {
  proc main(r:int) : bool = {
    var b;

    H.init(r);
    b <@ A(H).main(r);
    return b;
  }
}.

(* The proof of Theorem 4.16  gives a bound that is the summation
   of that in Corollary 4.15 and that in Theorem 4.9
   ( C(q + 2)^3/N) where C <= 27 is a constant and N=r. *)
axiom advantage_r (q:int) r_ (A<:AdvSRr{-SR,-QRO}) &m:
  0 < r_ => 
  hoare [IND_SRr(SROr,A).main : r = r_ ==> QRO.ch <= q] => 
  `| Pr[IND_SRr(SROr,A).main(r_) @ &m : res] - Pr[IND_SRr(SRr,A).main(r_) @ &m : res] | <= 
      (54 * q^3)%r / r_%r.

end SmallRange.

(* 
    Mark Zhandry
    Secure Identity-Based Encryption in the Quantum Random Oracle Model
    https://eprint.iacr.org/2012/076.pdf
    Theorem 3.1.  *)

abstract theory QROM_Fundamental_Lemma.

clone import Tuple as TupleXY with 
  type t <- from * hash.

type result.

quantum module type AdvRO (H:QRO) = {
  proc main() : result
}.

module QRO_main_D(A : AdvRO) = {
  proc main(adfhash : (from -> hash) distr) = {
    var r;
    QRO.ch <- 0;
    QRO.h <$ adfhash;
    r <@ A(QRO).main();
    return r;
  }
}.

axiom dA_split q (A<:AdvRO{-QRO}) &m:
   hoare [ QRO_main_D(A).main : true ==> QRO.ch <= q] => 
   exists (C : (from * hash) list -> result -> real),
   forall (adfhash: (from -> hash) distr) (r:result),
    Pr[ QRO_main_D(A).main(adfhash) @ &m : res = r] = 
    big predT (fun l => 
      C l r * mu adfhash (fun fx => all (fun (xr:_*_) => fx xr.`1 = xr.`2) l))
        (wordn (2*q)).

end QROM_Fundamental_Lemma.


quantum module type AdvRO (H:QRO) = {
  proc main() : bool
}.

abstract theory T_PRF.

type key.
op dkey : key distr.
op F : key -> from -> hash.

module PRF : QRO_i = {
  var k : key
  proc init() = { k <$ dkey; }
  quantum proc h{x:from} = { return F k x; } 
}.

module IND_QRO (A: AdvRO) = {
  proc rf() : bool = {
    var b;
    QRO.init();
    b <@ A(QRO).main();
    return b;
  }
  
  proc prf() : bool = {
    var b;
    PRF.init();
    b <@ A(PRF).main();
    return b;
  }
}.

(* The prf advantage is defined by: *)
axiom advantage_prf q (A <: AdvRO) &m:
  hoare [IND_QRO(A).rf : true ==> QRO.ch <= q] =>
  `| Pr[IND_QRO(A).rf() @ &m : res] - Pr[IND_QRO(A).prf() @ &m : res] | <= 1%r.

end T_PRF.

(*
abstract theory T_PRG.

type seed.
op G : seed -> hash.

abstract theory T_OracleSecurePRG.

op [lossless uniform full] dF : (from -> seed) distr.

(* G is an oracle-secure PRG if (G ∘ F) is a PRF for random F. *)
module PRF : QRO_i = {
  var f : from -> seed
  proc init() = { f <$ dF; }
  quantum proc h {x : from} = { return G (f x); }
}.

(* G is oracle-secure if for polynomial q,
axiom advantage q (A <: AdvRO[main: `{Inf, #H.h : q}]) &m:
`| Pr[IND_QRO(PRF, A).main() @ &m : res] - Pr[IND_QRO(QRO, A).main() @ &m : res] | <= negl.
*)

end T_OracleSecurePRG.

abstract theory T_StandardSecurePRG.

op [lossless uniform full] dseed : seed distr.

(* random number generation *)
module type RGi = {
  proc init() : unit
  proc sample() : hash
}.

module type RG = {
  include RGi [sample]
}.

(* adversary *)
quantum module type AdvPRG (G : RG) = {
  proc main() : bool
}.

module IND_PRG(G : RGi, D : AdvPRG) = {
  proc main() : bool = {
    var b;
    G.init();
    b <@ D(G).main();
    return b;
  }
}.

module PRG : RGi = {
  var s : seed
  proc init() = {
    s <$ dseed;
  }
  proc sample() = {
    return G s;
  }
}.

module RG : RGi = {
  var r : hash
  proc init() = {
    r <$ dhash;
  }
  proc sample() = {
    return r;
  }
}.

(* G is standard-secure if for polynomial q,
axiom advantage q (A <: AdvPRG[main: `{Inf, #G.sample : q}]) &m:
`| Pr[IND_PRG(PRG, A).main() @ &m : res] - Pr[IND_PRG(RG, A).main() @ &m : res] | <= negl.
*)

end T_StandardSecurePRG.

end T_PRG.


*)

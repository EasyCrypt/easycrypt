require import AllCore List Distr DBool CHoareTactic.
(*   *) import StdOrder RField RealOrder StdBigop Bigreal.
require (*  *) Matrix.

type from.
type hash.

(* Remark : this implies that hash is a finite type *)
op [lossless uniform full] dhash : hash distr.

clone import MUniFinFun as MUFF with
  type t <- from.   (* This assume that the type of from is finite *)

(* Uniform distribution over from -> hash *)
op dfhash : (from -> hash) distr = dfun (fun _ => dhash).

lemma dfhash_ll: is_lossless dfhash.
proof. apply dfun_ll => ?;apply dhash_ll. qed.

lemma dfhash_uni: is_uniform dfhash.
proof. apply dfun_uni => ?; apply dhash_uni. qed.

lemma dfhash_fu: is_full dfhash.
proof. apply dfun_fu => ?; apply dhash_fu. qed.

hint solve 0 random : dfhash_ll dfhash_uni dfhash_fu.

module type QRO_i = {
  proc init () : unit
  quantum proc h {_:from} : hash    
}.

module type QRO = {
  include QRO_i [h]
}.

module QRO : QRO_i = {
  var  h : from -> hash

  proc init() = { h <$ dfhash; }

  quantum proc h {x:from} = { return h x; }

}.

(* -------------------------------------------------------------------------- *)
(* Biased distribution over boolean return true with probability p *)   
clone MUniFinFunBiased as DBB with 
  type t <- from,
  op MUniFinFun.FinT.enum <-  MUFF.FinT.enum
  proof *.
realize MUniFinFun.FinT.enum_spec by apply MUFF.FinT.enum_spec.

(* -------------------------------------------------------------------------- *)
(* Semi Constant Definition Property *)
abstract theory SemiConstDistr.

op k : int.

type result = bool * from * from list.

op good(bf : from -> bool, x : from, l : from list) = 
     bf x /\ (forall x', x' \in l => !bf x') /\ size l <= k.

quantum module type AdvSCD (H:QRO) = {
  proc main() : result
}.
 
module SCD (A:AdvSCD) = {
  var bf : from -> bool
  var x : from
  var l : from list

  proc _F0(p:real) = {
    var c, y;
    bf <$ DBB.dbfun p;
    QRO.init();
    y  <$ dhash; 
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }

  proc _F1(p:real) = {
    var c, y;
    bf <$ DBB.dbfun p;
    QRO.init();
    y  <$ dhash; 
    QRO.h <- fun m => if bf m then y else QRO.h m;
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }
}.

axiom advantage q lambda (A<:AdvSCD{-SCD}[main : `{Inf, #H.h : q}]) &m:
  0%r <= lambda <= 1%r =>
  `| Pr[SCD(A)._F0(lambda) @ &m : res] - Pr[SCD(A)._F1(lambda) @ &m: res] | 
   <= (2%r * q%r + k%r + 1%r)/ 6%r * lambda^2.

end SemiConstDistr.

quantum module type AdvRO (H:QRO) = {
  proc main() : bool
}.

module IND_QRO (H:QRO_i, A:AdvRO) = {
  proc main() : bool = {
    var b;

    H.init();
    b <@ A(H).main();
    return b;
  }
}.

abstract theory T_PRF.

type key.
op dkey : key distr.
op F : key -> from -> hash.

module PRF : QRO_i = {
  var k : key
  proc init() = { k <$ dkey; }
  quantum proc h{x:from} = { return F k x; } 
}.

(* The prf advantage is defined by: 
  `| Pr[IND_QRO(PRF, A).main() @ &m : res] - Pr[IND_QRO(QRO, A).main() @ &m : res] |
*)

end T_PRF.

type seed.

op [lossless uniform full] dF : (from -> seed) distr.
op G : seed -> hash.

abstract theory T_OracleSecurePRG.

(* G is an oracle-secure PRG if (G âˆ˜ F) is a PRF for random F. *)
module PRF : QRO_i = {
  var f : from -> seed
  proc init() = { f <$ dF; }
  quantum proc h {x : from} = { return G (f x); }
}.

(* G is oracle-secure if for polynomial q,
axiom advantage q (A <: AdvRO[main: `{Inf, #H.h : q}]) &m:
`| Pr[IND_QRO(PRF, A).main() @ &m : res] - Pr[IND_QRO(QRO, A).main() @ &m : res] | <= negl.
*)

end T_OracleSecurePRG.

op [lossless uniform full] dseed : seed distr.

abstract theory T_StandardSecurePRG.

(* random number generation *)
module type RGi = {
  proc init() : unit
  proc sample() : hash
}.

module type RG = {
  include RGi [sample]
}.

(* adversary *)
quantum module type AdvPRG (G : RG) = {
  proc main() : bool
}.

module IND_PRG(G : RGi, D : AdvPRG) = {
  proc main() : bool = {
    var b;
    G.init();
    b <@ D(G).main();
    return b;
  }
}.

module PRG : RGi = {
  var s : seed
  proc init() = {
    s <$ dseed;
  }
  proc sample() = {
    return G s;
  }
}.

module RG : RGi = {
  var r : hash
  proc init() = {
    r <$ dhash;
  }
  proc sample() = {
    return r;
  }
}.

(* G is standard-secure if for polynomial q,
axiom advantage q (A <: AdvPRG[main: `{Inf, #G.sample : q}]) &m:
`| Pr[IND_PRG(PRG, A).main() @ &m : res] - Pr[IND_PRG(RG, A).main() @ &m : res] | <= negl.
*)

end T_StandardSecurePRG.

(* TODO: if G is standard-secure, then it is also oracle-secure. *)


(* Efficient QROM simulation: Theorem 6.1 in 
    Mark Zhandry
    Secure Identity-Based Encryption in the Quantum Random Oracle Model
    https://eprint.iacr.org/2012/076.pdf  *)

abstract theory T_LazyQROM.

op q : int.

axiom q_ge0 : 0 <= q.

(* Sampling is based on a finite field. *)
type FF.

op [lossless uniform full] duni_FF : FF distr.
hint solve 0 random : duni_FF_ll duni_FF_uni duni_FF_fu.

lemma duni_FF_funi : is_funiform duni_FF.
proof. apply is_full_funiform; [apply duni_FF_fu | apply duni_FF_uni]. qed.

(* The bijection requirement makes everything commute nicely,
   but these restrictions can probably be looser *)

op encode : from -> FF.
axiom encodeB : bijective encode.

op decode : FF -> hash.
axiom decodeB : bijective decode.

clone import Matrix with
  type R <- FF,
  op size <- 2*q
  proof ge0_size by smt(q_ge0).

op genseed = dvector duni_FF.

(* We use exponentiation to generate a row in a Vondermonde matrix *)
op (^) : FF -> int -> FF.

op compute(seed : vector, x : from) : hash =
        let xv = offunv (fun (i : int) => encode x^i) in
        let yf = dotp xv seed in
            decode yf.

module LQRO : QRO_i = {
  var seed : vector

  proc init() = { seed <$ genseed; }

  quantum proc h {x:from} = { return compute seed x; }

}.

type output.

quantum module type AdvRO (H:QRO) = {
  proc main() : output
}.


axiom efficient_sim P (A<:AdvRO{-QRO, -LQRO}[main : `{Inf, #H.h : q}]) &m:
  Pr[A(QRO).main() @ &m : P res] = Pr[ A(LQRO).main() @ &m: P res].

(* Could be a lemma based on Theorem 3.1 in the same paper and the
   fact that any set of 2q rows in the Vondermonde matrix we construct
   are linearly independent.  *)

end T_LazyQROM.

require import AllCore List Distr DBool DProd DList DInterval CHoareTactic IntDiv.
(*   *) import StdOrder RField RealOrder StdBigop Bigreal BRA.
require (*  *) Matrix Tuple (* FinType *).

type from.

clone import MUniFinFun as MUFF with
  type t <- from.   (* This assume that the type of from is finite *)

abstract theory Collision.
 
  type input.
  type hash.

  module type QROd_i = {
    proc init (dhash : hash distr) : unit
    quantum proc h {_:from} : hash    
  }.
  
  module type QROd = {
    include QROd_i [h]
  }.
  
  module QROd : QROd_i = {
    var  h : from -> hash
  
    proc init(dhash:hash distr) = { h <$ dfun (fun _ => dhash); }
  
    quantum proc h {x:from} = { return h x; }
  
  }.
  
  quantum module type AdvCol (H:QROd) = {
    proc main(i:input) : from list
  }.
  
  module Col(A:AdvCol) = {
    proc main(d:hash distr, i:input) = {
      var l;
      QROd.h <$ dfun (fun _ => d);
      l <@ A(QROd).main(i);
      return l;
    }
  }.
  
  (* FIXME: change to Thm 3.9 in MZ Thesis: C(q+2)^2/N where
     C is a fixed constant and N is the hash range cardinality. *)
  axiom pr_col r (d_:hash distr) i_ q (A<:AdvCol{-QROd}[main : `{Inf, #H.h : q}]) &m:
    (forall h, mu1 d_ h <= r) =>
    Pr[Col(A).main(d_, i_) @ &m : size res <= q /\ exists x1 x2, x1 <> x2 /\ x1 \in res /\ x2 \in res /\
                                 QROd.h x1 = QROd.h x2] <= q%r^3 * r. 

end Collision.
  
type hash.

(* Remark : this implies that hash is a finite type *)
op [lossless uniform full] dhash : hash distr.

(* Uniform distribution over from -> hash *)
op dfhash : (from -> hash) distr = dfun (fun _ => dhash).

lemma dfhash_ll: is_lossless dfhash.
proof. apply dfun_ll => ?;apply dhash_ll. qed.

lemma dfhash_uni: is_uniform dfhash.
proof. apply dfun_uni => ?; apply dhash_uni. qed.

lemma dfhash_fu: is_full dfhash.
proof. apply dfun_fu => ?; apply dhash_fu. qed.

hint solve 0 random : dfhash_ll dfhash_uni dfhash_fu.

module type QRO_i = {
  proc init () : unit
  quantum proc h {_:from} : hash    
}.

module type QRO = {
  include QRO_i [h]
}.

module QRO : QRO_i = {
  var  h : from -> hash

  proc init() = { h <$ dfhash; }

  quantum proc h {x:from} = { return h x; }

}.
 
(* -------------------------------------------------------------------------- *)
(* Biased distribution over boolean return true with probability p *)   

op dbfun lam = dfun (fun _ => Biased.dbiased lam).

lemma pr_dbfun_l_pow lam x (l:from list) q : 
  0%r <= lam <= 1%r =>
  !x \in l => size l <= q =>  
  lam*(1%r-lam)^q <= 
    mu (dbfun lam) (fun t => t x /\ forall x', x' \in l => !t x').
proof.
  move=> lam_bound hm hl.
  apply (ler_trans (lam ^ 1 * (1%r - lam) ^ size l)).
  + rewrite RField.expr1; apply ler_wpmul2l; 1: by case: lam_bound.
    apply ler_wiexpn2l; [1:smt ()| 2: smt(size_ge0)].
  apply (ler_trans _ _ _ 
    (dfunE_mem_le lam (fun _ => Biased.dbiased lam) [x] l (fun _ => pred1 true) _ _ _)) => /=.
  + by apply Biased.dbiased_ll. + by rewrite Biased.dbiased1E /= Biased.clamp_id. + smt().
  by apply mu_le => /#.
qed.

lemma pr_dbfun_l lam x (l:from list) q : 
  0%r <= lam <= 1%r =>
  !x \in l => size l <= q =>  
  lam*(1%r-q%r * lam) <= 
    mu (dbfun lam) (fun t => t x /\ forall x', x' \in l => !t x').
proof.
  move=> lam_bound hm hl.
  apply: ler_trans (pr_dbfun_l_pow _ _ _ _ lam_bound hm hl).
  apply ler_wpmul2l; 1: by case: lam_bound.
  apply le_binomial => //; smt(size_ge0).
qed.

(* -------------------------------------------------------------------------- *)
(* Semi Constant Definition Property *)
abstract theory SemiConstDistr.

op k : int.

type result = bool * from * from list.

op good(bf : from -> bool, x : from, l : from list) = 
     bf x /\ (forall x', x' \in l => !bf x') /\ size l <= k.

quantum module type AdvSCD (H:QRO) = {
  proc main() : result
}.
 
module SCD (A:AdvSCD) = {
  var bf : from -> bool
  var x : from
  var l : from list

  proc _F0(p:real) = {
    var c, y;
    bf <$ dbfun p;
    QRO.init();
    y  <$ dhash; 
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }

  proc _F1(p:real) = {
    var c, y;
    bf <$ dbfun p;
    QRO.init();
    y  <$ dhash; 
    QRO.h <- fun m => if bf m then y else QRO.h m;
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }
}.

axiom advantage q lambda (A<:AdvSCD{-SCD}[main : `{Inf, #H.h : q}]) &m:
  0%r <= lambda <= 1%r =>
  `| Pr[SCD(A)._F0(lambda) @ &m : res] - Pr[SCD(A)._F1(lambda) @ &m: res] | 
   <= (2%r * q%r + k%r + 1%r)/ 6%r * lambda^2.

end SemiConstDistr.

(* -------------------------------------------------------------------------- *)
(* Semi Constant Definition Property *)

op difun r = dfun (fun _ => [0..r-1]).

lemma pr_difun_l_pow r x (l:from list) q i :
  0 <= i < r =>  
  !x \in l => size l <= q =>  
  1.0/r%r * (1.0 - 1.0 / r%r)^q <= 
    mu (difun r) (fun fr => fr x = i /\ forall m', m' \in l => fr m' <> i).
proof.
  move=> hi hm hl.
  pose lam := 1.0/r%r.
  apply (ler_trans (lam ^ 1 * (1%r - lam) ^ size l)).
  + rewrite RField.expr1; apply ler_wpmul2l; 1: smt().
    apply ler_wiexpn2l; [1:smt ()| 2: smt(size_ge0)].
  apply (ler_trans _ _ _ 
    (dfunE_mem_le lam (fun _ => [0..r-1]) [x] l (fun _ => pred1 i) _ _ _)) => /=.
  + by apply dinter_ll => /#. + by rewrite dinter1E /#. + smt().
  by apply mu_le => /#.
qed.

lemma pr_difun_l r x (l:from list) q i :
  0 <= i < r =>  
  !x \in l => size l <= q =>  
  1.0/r%r * (1.0 - q%r / r%r) <= 
    mu (difun r) (fun fr => fr x = i /\ forall m', m' \in l => fr m' <> i).
proof.
  move=> i_bound hm hl.
  apply: ler_trans (pr_difun_l_pow _ _ _ _ _ i_bound hm hl).
  apply ler_wpmul2l; 1: smt(). 
  apply le_binomial => //; smt(size_ge0).
qed.

(* -------------------------------------------------------------------------- *)
(* Small Range Definition Property *)

theory SmallRange.

module type SR_i = {
  proc init (r: int) : unit
  quantum proc h {_:from} : hash    
}.

module type SR = {
  include SR_i [-init]
}.

quantum module type AdvSR (H:SR) = {
  proc main(r:int) : bool
}.

module IND_SR (H:SR_i, A:AdvSR) = {
  proc main(r:int) : bool = {
    var b;

    H.init(r);
    b <@ A(H).main(r);
    return b;
  }
}.

module SR : SR_i = {
  var rh : hash list
  var fr : from -> int
  proc init (r:int) = {
    rh <$ dlist dhash r;
    fr <$ difun r; 
    QRO.h <- fun x => nth witness rh (fr x); 
  } 

  quantum proc h {x:from} = {
    return (QRO.h x);
  }
}.

module SRO : SR_i = {
  proc init (r:int) = {
    SR.fr <$ difun r; 
    QRO.init();
  } 

  quantum proc h {x:from} = {
    return (QRO.h x);
  }
}.

(* This bound comes from Corollary 4.15 of Mark Zhandry's thesis *)
axiom advantage q r (A<:AdvSR{-SR}[main : `{Inf, #H.h : q}]) &m:
  0 < r => 
  `| Pr[IND_SR(SRO,A).main(r) @ &m : res] - Pr[IND_SR(SR,A).main(r) @ &m : res] | <= 
      27%r * q%r^3 / r%r.

module type SRr_i = {
  proc init (r: int) : unit
  quantum proc h {_:from} : int * hash    
}.

module type SRr = {
  include SRr_i [-init]
}.

module SRr : SRr_i = {
  var rh : hash list
  var fr : from -> int
  proc init (r:int) = {
    rh <$ dlist dhash r;
    fr <$ difun r; 
    QRO.h <- fun x => nth witness rh (fr x); 
  } 

  quantum proc h {x:from} = {
    return (fr x, QRO.h x);
  }
}.

module SROr : SRr_i = {
  proc init (r:int) = {
    SR.fr <$ difun r; 
    QRO.init();
  } 

  quantum proc h {x:from} = {
    return (SR.fr x, QRO.h x);
  }
}.

quantum module type AdvSRr (H:SRr) = {
  proc main(r:int) : bool
}.

module IND_SRr (H:SRr_i, A:AdvSRr) = {
  proc main(r:int) : bool = {
    var b;

    H.init(r);
    b <@ A(H).main(r);
    return b;
  }
}.

(* FIXME: The proof of Theorem 4.16  gives a bound that is the summation
   of that in Corollary 4.15 (currently used) and that in Theorem 4.9
   ( C(q + 2)3/N) where C is a constant and N is the cardinality of 
   the range of the hash. *)
axiom advantage_r q r (A<:AdvSRr{-SR}[main : `{Inf, #H.h : q}]) &m:
  0 < r => 
  `| Pr[IND_SRr(SROr,A).main(r) @ &m : res] - Pr[IND_SRr(SRr,A).main(r) @ &m : res] | <= 
      27%r * q%r^3 / r%r.

end SmallRange.

quantum module type AdvRO (H:QRO) = {
  proc main() : bool
}.

module IND_QRO (H:QRO_i, A:AdvRO) = {
  proc main() : bool = {
    var b;

    H.init();
    b <@ A(H).main();
    return b;
  }
}.

abstract theory T_PRF.

type key.
op dkey : key distr.
op F : key -> from -> hash.

module PRF : QRO_i = {
  var k : key
  proc init() = { k <$ dkey; }
  quantum proc h{x:from} = { return F k x; } 
}.

(* The prf advantage is defined by: 
  `| Pr[IND_QRO(PRF, A).main() @ &m : res] - Pr[IND_QRO(QRO, A).main() @ &m : res] |
*)

end T_PRF.

abstract theory T_PRG.

type seed.
op G : seed -> hash.

abstract theory T_OracleSecurePRG.

op [lossless uniform full] dF : (from -> seed) distr.

(* G is an oracle-secure PRG if (G âˆ˜ F) is a PRF for random F. *)
module PRF : QRO_i = {
  var f : from -> seed
  proc init() = { f <$ dF; }
  quantum proc h {x : from} = { return G (f x); }
}.

(* G is oracle-secure if for polynomial q,
axiom advantage q (A <: AdvRO[main: `{Inf, #H.h : q}]) &m:
`| Pr[IND_QRO(PRF, A).main() @ &m : res] - Pr[IND_QRO(QRO, A).main() @ &m : res] | <= negl.
*)

end T_OracleSecurePRG.

abstract theory T_StandardSecurePRG.

op [lossless uniform full] dseed : seed distr.

(* random number generation *)
module type RGi = {
  proc init() : unit
  proc sample() : hash
}.

module type RG = {
  include RGi [sample]
}.

(* adversary *)
quantum module type AdvPRG (G : RG) = {
  proc main() : bool
}.

module IND_PRG(G : RGi, D : AdvPRG) = {
  proc main() : bool = {
    var b;
    G.init();
    b <@ D(G).main();
    return b;
  }
}.

module PRG : RGi = {
  var s : seed
  proc init() = {
    s <$ dseed;
  }
  proc sample() = {
    return G s;
  }
}.

module RG : RGi = {
  var r : hash
  proc init() = {
    r <$ dhash;
  }
  proc sample() = {
    return r;
  }
}.

(* G is standard-secure if for polynomial q,
axiom advantage q (A <: AdvPRG[main: `{Inf, #G.sample : q}]) &m:
`| Pr[IND_PRG(PRG, A).main() @ &m : res] - Pr[IND_PRG(RG, A).main() @ &m : res] | <= negl.
*)

end T_StandardSecurePRG.

end T_PRG.


(* TODO: if G is standard-secure, then it is also oracle-secure. *)

(* 
    Mark Zhandry
    Secure Identity-Based Encryption in the Quantum Random Oracle Model
    https://eprint.iacr.org/2012/076.pdf
    Theorem 3.1.  *)

abstract theory QROM_Fundamental_Lemma.

clone import Tuple as TupleXY with 
  type t <- from * hash.

op q : int.

axiom q_ge0 : 0 <= q.


type result.

quantum module type AdvRO (H:QRO) = {
  proc main() : result
}.

module QRO_main_D(A : AdvRO) = {
  proc main(adfhash : (from -> hash) distr) = {
    var r;
    QRO.h <$ adfhash;
    r <@ A(QRO).main();
    return r;
  }
}.

module QRO_main(A : AdvRO, H : QRO_i) = {
  proc main() = {
    var r;
    H.init();
    r <@ A(H).main();
    return r;
  }
}.

axiom dA_split (A<:AdvRO{-QRO_main}[main : `{Inf, #H.h : q}]) &m:
   exists (C : (from * hash) list -> result -> real),
   forall (adfhash: (from -> hash) distr) (r:result),
    Pr[ QRO_main_D(A).main(adfhash) @ &m : res = r] = 
    big predT (fun l => 
      C l r * mu adfhash (fun fx => all (fun (xr:_*_) => fx xr.`1 = xr.`2) l))
        (wordn (2*q)).

end QROM_Fundamental_Lemma.

(* Efficient QROM simulation: Theorem 6.1 in 
    Mark Zhandry
    Secure Identity-Based Encryption in the Quantum Random Oracle Model
    https://eprint.iacr.org/2012/076.pdf  *)

(* The theorem can be generalized to capture any QROM of the following form:

   |X| < p^n
   |Y| = p^m

s.t. 1 < m <= n and 1 < p

The idea is that the linear independence argument gives a random element in FF_p^n,
which can be converted in a random element in FF_p^m by raising to p^{n-m}.

This means, in particular, that we can model any possible compressing or
length preserving QROM over bit strings and, in particular, random oracles
that map bit strings to a single bit.

*)

abstract theory T_LazyQROM.

op q : int.

axiom q_ge0 : 0 <= q.

(* Sampling is based on two finite fields with the same characteristic. *)
op p : { int | 1 < p } as gt1_p.

type ff_in.
op enum_ff_in : ff_in list.
op n : { int | 0 < n } as gt0_n.
axiom ff_in_order : size enum_ff_in = p^n.

clone  MFinite as FFin with
  type t <- ff_in,
  op Support.enum <- enum_ff_in.

lemma in_char_order : p %| FFin.Support.card. 
have -> : (p = p^1); first by smt(@Ring.IntID).
by rewrite /card  ff_in_order; apply dvdz_exp2l; smt(gt0_n).
qed.

type ff_out.
op enum_ff_out : ff_out list.
op m : { int | 0 < m <= n } as bnd_m.
axiom ff_out_order : size enum_ff_out = p^m.

clone  MFinite as FFout with
  type t <- ff_out,
  op Support.enum <- enum_ff_out.

lemma out_char_order : p %| FFout.Support.card. 
have -> : (p = p^1); first by smt(@Ring.IntID).
by rewrite /card  ff_out_order; apply dvdz_exp2l; smt(bnd_m).
qed.


(* Injection means that you have an FF that is large enough
   to encode all possible inputs *)
op encode : from -> ff_in.
axiom encodeB : injective encode.

(* Bijection means that a uniform field element gives you a uniform
   element in hash, which is all we need *)
op decode : ff_out -> hash.
axiom decodeB : bijective decode.

(* Note that this will work for any hash type that has p^n elements,
   for p prime and n > 0 some integer. And |from| <= |hash|. *)

clone import Matrix with
  type R <- ff_in,
  op size <- 2*q
  proof ge0_size by smt(q_ge0).

op genseed = dvector FFin.dunifin.

(* We use exponentiation to generate a row in a Vandermonde matrix *)
op (^) : ff_in -> int -> ff_in.

(* We use a projection function to obtain a value in ff_out *)

op project : ff_in -> ff_out.

axiom project_uniform y :
   size (filter (fun x => project x = y) enum_ff_in) = p^(n-m).

op compute(seed : vector, x : from) : hash =
        let xv = offunv (fun (i : int) => encode x^i) in
        let yf = dotp xv seed in
            decode (project yf).

module LQRO : QRO_i = {
  var seed : vector

  proc init() = { seed <$ genseed; }

  quantum proc h {x:from} = { return compute seed x; }

}.

op dcompute : (from -> hash) distr = 
       dmap genseed (fun seed => compute seed).

clone import QROM_Fundamental_Lemma with
    op q <- q
    proof q_ge0 by smt(q_ge0).
import TupleXY.

(* This requires some random sampling magic *)

lemma eager_sampling  (A<:AdvRO{-QRO, -LQRO}[main : `{Inf, #H.h : q}]) &m (r : result):
  Pr[ QRO_main(A,LQRO).main() @ &m: res = r] = Pr[ QRO_main_D(A).main(dcompute) @ &m: res = r]. 
(* Just use random *)
admitted.

(* This axiom captures the following property on the Vandermonde 
   matrix:  any 2q rows are linearly independent. *)

op uhash_list(xs : ff_in list, seed : vector) : vector = 
   offunv (fun i =>
              let x = nth witness xs i in
              let xv = offunv (fun (j : int) =>  x^j) in
                  dotp xv seed).

axiom indep2q xs: 
  size xs = 2*q =>
  uniq xs =>
    bijective (uhash_list xs).

op u2q_from : from list.
axiom unique_2q_valuesE : size u2q_from = 2*q /\ uniq u2q_from.

op extend : from list -> from list.
axiom extends_u2q l : size l <= 2*q => 
   (forall x, x \in l => x \in extend l) /\
   size (extend l) = 2*q /\ 
   uniq (extend l).

lemma universal2q xs :
  size xs = 2*q =>
  uniq xs =>
  genseed = dmap genseed (uhash_list xs).
proof. 
move => sxs uxs.
apply eq_funi_ll.
+  by rewrite /genseed; apply (dvector_funi _ FFin.dunifin_fu FFin.dunifin_uni).
+ by rewrite /genseed (dvector_ll _ FFin.dunifin_ll).
+ by rewrite /genseed;  apply (dmap_funi _ _ (indep2q xs sxs uxs) (dvector_funi _ FFin.dunifin_fu FFin.dunifin_uni)).
+ by rewrite /genseed; apply dmap_ll; apply dvector_ll; apply FFin.dunifin_ll.
qed.

lemma perfect_sim xy:
  xy \in wordn (2 * q) =>
 mu dfhash (fun (fx : from -> hash) => all (fun (xr : from * hash) => fx xr.`1 = xr.`2) xy) =
 mu dcompute (fun (fx : from -> hash) => all (fun (xr : from * hash) => fx xr.`1 = xr.`2) xy).
proof.
move => xys.
pose P := (fun (fx : from -> hash) => all (fun (xr : from * hash) => fx xr.`1 = xr.`2) xy).
rewrite /dfhash /dcompute /compute.
admitted.

lemma efficient_sim (A<:AdvRO{-QRO, -LQRO}[main : `{Inf, #H.h : q}]) &m (r : result):
  Pr[ QRO_main(A,QRO).main() @ &m: res = r ] = Pr[ QRO_main(A,LQRO).main() @ &m: res = r ].
proof.
have -> : 
 Pr[ QRO_main(A,QRO).main() @ &m: res = r ] = Pr[QRO_main_D(A).main(dfhash) @ &m : res = r].
   by byequiv=>//; conseq (_: _ ==> ={res})=> //; proc;inline*; sim; auto => />.
rewrite (eager_sampling A) (dA_split A &m dfhash r) (dA_split A &m dcompute r).
by apply (eq_big_seq _ _  (wordn (2*q))); move => * /=;congr; apply perfect_sim.
qed.

end T_LazyQROM.

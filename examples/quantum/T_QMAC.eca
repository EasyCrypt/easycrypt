require import AllCore List. (* provide you the type list *)

type msg.
type tag.
type skey.

module type QMACScheme = {
  proc kg() : skey
  quantum proc sign(sk:skey) {m:msg} : tag   (* This procedure needs to provide a quantum access *)
  proc verify(sk:skey, m:msg, s:tag) : bool
}.

module type OrclSign = {
  quantum proc sign {m: msg} : tag   
}.

quantum module type AdvEUF (O:OrclSign) = {
  proc choose() : (msg * tag) list  
}.



module EUF(A:AdvEUF) (O:QMACScheme) = {
  var sk: skey
  var ms: (msg * tag) list

  module Os = {
    quantum proc sign {m:msg} = { 
      quantum var s; 
      s <@ O.sign(sk){m};
      return s;
    }
  }

  proc main() = {
    var b, l, c, m, s;
    sk <@ O.kg();
    ms <@ A(Os).choose();
    b <- true;
    l <- ms;
    while (l <> []) { 
      (m,s) <- head witness l;
      l <- behead l;
      c <@ O.verify(sk,m,s);
      b <- b && c;
    }
    return b; 
  }
}.

require T_QROM.

clone import T_QROM as QROM with
  type from <- msg,
  type hash <- tag
  rename "hash" as "tag".

clone import T_PRF as PRF with
  type key <- skey.

module PRF_MAC : QMACScheme = {

  var ch : int

  proc kg(): skey = { var k : skey; ch <- 0; k <$ dkey; return k; }

  quantum proc sign(k: skey) {m: msg} : tag = { ch <- ch + 1; return F k m; }

  proc verify (k: skey, m: msg, s: tag) = { return F k m = s; }
}.


axiom advantage_euf q (A <: AdvEUF) &m:
  hoare [EUF(A, PRF_MAC).main : true ==> PRF_MAC.ch <= q < size EUF.ms ] =>
  `| Pr[EUF(A, PRF_MAC).main() @ &m : res] | <= 2%r. 
  (* FIXME: the probability should be (q+1)/N where N is the size of tag space*)


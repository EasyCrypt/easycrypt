require import AllCore List Distr DBool DProd DList DInterval CHoareTactic IntDiv SmtMap.
require import FunSamplingLib Birthday FSet.
(*   *) import StdOrder RField RealOrder StdBigop Bigreal BRA.
require (*  *) Matrix Tuple FinType ROM.

type from.

clone import MUniFinFun as MUFF with
  type t <- from.   (* This assumes that the type of from is finite *)


type hash.

clone  MUniFinFun as MUFFH with
  type t <- hash.   (* This assumes that the type of hash is finite *)

op [lossless uniform full ] dhash : hash distr.

type input.
clone ROM as ROM_ with
  type in_t <- from,
  type out_t <- hash,
  op dout <- fun _ => dhash,
  type d_in_t <- input,
  type d_out_t <- bool.

clone ROM_.LazyEager as LE with 
  theory FinType <- MUFF.FinT.


(* Uniform distribution over from -> hash *)
op dfhash : (from -> hash) distr = dfun (fun _ => dhash).

lemma dfhash_ll: is_lossless dfhash.
proof. apply dfun_ll => ?;apply dhash_ll. qed.

lemma dfhash_uni: is_uniform dfhash.
proof. apply dfun_uni => ?; apply dhash_uni. qed.

lemma dfhash_fu: is_full dhash => is_full dfhash.
proof. move=> dhash_fu; apply dfun_fu => ?; apply dhash_fu. qed.

hint solve 0 random : dfhash_ll dfhash_uni dfhash_fu.

module type QRO_i = {
  proc init () : unit
  quantum proc h {_:from} : hash 
}.


module type QRO = {
  include QRO_i [h]
}.

module QRO : QRO_i = {
  var  h : from -> hash
  var ch : int

  proc init() = { ch <- 0; h <$ dfhash; }

  quantum proc h {x:from} = { ch <- ch + 1; return h x; }
}.
 
abstract theory Collision.
   
  quantum module type AdvCol (H:QRO) = {
    proc main(i:input) : from * from
  }.
  
  module Col(A:AdvCol) = {
    proc main(i:input) = {
      var xx;
      QRO.init();
      xx <@ A(QRO).main(i);
      return (xx.`1 <> xx.`2 && QRO.h xx.`1 = QRO.h xx.`2);
    }
  }.

  (* Thm 3.9 in MZ Thesis: N is the card of hash type. *)
  axiom pr_col i_ q (A<:AdvCol{-QRO}) &m:
    let r = mu1 dhash witness in
    hoare [Col(A).main : i = i_ /\ QRO.ch = 0 ==> QRO.ch <= q] =>
    Pr[Col(A).main(i_) @ &m : res] <= (27 *(q +2)^3)%r * r. 

theory CLASSICAL.
  import ROM_.
  import LE.

  module type AdvCol_C (H: POracle) = {
    proc main(i:input) : from * from
  }.

  module WrapC(O : Oracle) : Oracle = {
    proc init() : unit = {
        O.init();
        QRO.ch <- 0;
    }

    proc o(x : from) : hash = {
        var r;
        r <@ O.o(x);
        QRO.ch <- QRO.ch + 1;
        return r;
    }
  }.
  
  module Col_C(A:AdvCol_C) = {
    proc main(i:input) = {
      var xx;
      WrapC(ERO).init();
      xx <@ A(WrapC(ERO)).main(i);
      return (xx.`1 <> xx.`2 && ERO.m.[xx.`1] = ERO.m.[xx.`2]);
    }
  }.

module (D(A : AdvCol_C): Distinguisher) ( H : POracle)   = {

  module HC = {
    proc o(x : from) : hash = {
        var r;
        r <@ H.o(x);
        QRO.ch <- QRO.ch + 1;
        return r;
    }
  }


  proc run(i : input): bool = {
      var xx,h1,h2;
      QRO.ch <- 0;
      xx <@ A(HC).main(i);
      h1 <@ H.o(xx.`1);
      h2 <@ H.o(xx.`2);
      return (xx.`1 <> xx.`2 && h1 = h2);

  } 
}.

  (* We shoul d have a version of Birthday with no q *)
  op q : int.
  axiom ge0_q :0 <= q.

section CollisionProbability.
  declare module A <:AdvCol_C{-ERO, -QRO, -Lazy.LRO}.


  declare axiom A_ll (O <: POracle): islossless O.o => islossless A(O).main.
  declare axiom A_Bounded : hoare [A(D(A, Lazy.LRO).HC).main : QRO.ch = 0 ==> QRO.ch <= q].

  local clone import Birthday as BBound with
    op   q <- q + 2,
    type T <- hash,
    op   uT <- dhash,
    op maxu <- witness
  proof *.
  realize ge0_q by smt(ge0_q).
  realize maxuP by smt(dhash_fu dhash_ll dhash_uni is_full_funiform). 

  (* We construct a Birthday Bound adversary from the Coll
     experiment. *)
  local module (AB:Adv) (S:ASampler) = {
    var i  : input
    (* We simulate an f-oracle using the s-oracle *)
    module HC = {
      proc init = Lazy.LRO.init

      proc o(x:from): hash = {
        var r;
        if (x \notin Lazy.LRO.m) {
          r <@ S.s();
          Lazy.LRO.m.[x] <- r;
        }
        return oget Lazy.LRO.m.[x];
      }
    }

    proc a(): unit = {
      var xx,h1,h2;
      HC.init();
      xx <@ A(HC).main(i);
      h1 <@ HC.o(xx.`1);
      h2 <@ HC.o(xx.`2);
    }
  }.

pred collision (m:(from,hash) fmap) = exists x x',
  x' <> x /\
  x \in m /\ x' \in m /\ m.[x] = m.[x'].


(* Some useful facts about the bad event *)
lemma no_collision (m:(from,hash) fmap):
  !collision m <=>
  forall x x',
    x' = x \/
    !x \in m  \/
    !x' \in m \/
    m.[x] <> m.[x'].
proof.
rewrite /collision negb_exists /=; apply/forall_iff=> /= x.
by rewrite negb_exists /=; apply/forall_iff=> /= x'; rewrite !negb_and.
qed.

lemma collision_add (m:(from,hash) fmap) x y:
  !x \in m =>
  collision m.[x <- y] <=> collision m \/ rng m y.
proof.
move=> x_notin_m; split=> [[z z' [z'_neq_z]]|].
+ rewrite mem_set=> -[z_in_m] [z'_in_m] mz_eq_mz'.
  case (rng m y)=> //= y_notin_rngm.
  by exists z z'; smt(@SmtMap).
move=> [[z z' [z'_neq_z] [z_in_m] [z'_in_m] mz_eq_mz']|].
+ exists z z'; rewrite z'_neq_z !mem_set !get_setE mz_eq_mz' z_in_m z'_in_m /=.
  move/contra: (congr1 (dom m) z x); rewrite x_notin_m z_in_m=> -> //=.
  by move/contra: (congr1 (dom m) z' x); rewrite x_notin_m z'_in_m=> -> //=.
rewrite rngE=> - /= [x'] mx'_y.
by exists x x'; smt(@SmtMap).
qed.

lemma collision_stable (m:(from,hash) fmap) y y':
  collision m =>
  y \notin m =>
  collision m.[y <- y'].
proof. by move=> h /collision_add /= ->; rewrite h. qed.

  local equiv Col_Exp i_ : 
     AB(Sample).a ~ ROM_.Exp(Lazy.LRO, D(A)).main : 
       AB.i{1} = i_ /\ arg{2} = i_ /\ ={glob A} /\ size Sample.l{1} = 0 ==>
         (res{2} => !uniq Sample.l{1}) /\
         size Sample.l{1} = card (fdom Lazy.LRO.m){2}.
  proof.
  proc; inline*.
  sp;seq 1 1:  (={Lazy.LRO.m, glob A,xx} /\
           size Sample.l{1} = card (fdom Lazy.LRO.m){2} /\
           (forall x, mem (frng Lazy.LRO.m) x <=> mem Sample.l x){1} /\
           (collision Lazy.LRO.m{2} => !uniq Sample.l{1})).
  + call (_: ={Lazy.LRO.m} /\
           size Sample.l{1} = card (fdom Lazy.LRO.m){2} /\
           (forall x, mem (frng Lazy.LRO.m) x <=> mem Sample.l x){1} /\
           (collision Lazy.LRO.m{2} => !uniq Sample.l{1})).
    + proc; inline*;wp;if{1}.
      + auto => /> &1 &2 h1 h2 h3 h4 r _.
        rewrite fdom_set fcardUI_indep 2:fcard1; 1: by rewrite fsetI1 mem_fdom h4.
        + by do split;smt(get_setE mem_frng rngE collision_add).
        by auto; smt (size_eq0 fdom0 fcards0 frng0 in_fset0 mem_empty).
    by auto => />; smt (size_eq0 fdom0 fcards0 frng0 in_fset0 mem_empty).
  sp; if{1}.
  + rcondt{2} 2; 1: by auto => />. 
    seq 1 1 : (#pre /\ r1{1} = r0{2}); 1 : by auto.
    seq 4 2 : (#{/~x{1}}pre /\ xx.`1{2} \in Lazy.LRO.m{2} /\ h1{2} = oget (Lazy.LRO.m{2}.[xx{2}.`1])); 
       1: by auto => /> &1 &2 *; do split;smt(@SmtMap @FSet get_setE mem_frng rngE collision_add).   
    sp; if{1}.
    + rcondt{2} 2; 1: by auto => />. 
      seq 1 1 : (#pre /\ r2{1} = r1{2}); 1 : by auto.
      seq 4 2 : (#{/~x0{1}}pre /\ xx.`2{2}  \in Lazy.LRO.m{2} /\ h2{2} = oget (Lazy.LRO.m{2}.[xx{2}.`2])); 
       1: by auto => /> &1 &2 *; do split;smt(@SmtMap @FSet get_setE mem_frng rngE collision_add).
      by auto => /> &1 &2  /> /#. 
    rcondf{2} 2; 1: by auto => />. 
    seq 0 1 : (#pre); 1 : by auto.
    by auto => /> &1 &2  /> /#. 
  rcondf{2} 2; 1: by auto => />. 
  seq 0 1 : (#pre); 1 : by auto.
  seq 1 1 : (#{/~x{1}}pre /\ xx.`1{2} \in Lazy.LRO.m{2} /\ h1{2} = oget (Lazy.LRO.m{2}.[xx{2}.`1])); 
       1: by auto => /> &1 &2 *; do split;smt(@SmtMap @FSet get_setE mem_frng rngE collision_add).   
    sp; if{1}.
    + rcondt{2} 2; 1: by auto => />. 
      seq 1 1 : (#pre /\ r2{1} = r1{2}); 1 : by auto.
      seq 4 2 : (#{/~x0{1}}pre /\ xx.`2{2}  \in Lazy.LRO.m{2} /\ h2{2} = oget (Lazy.LRO.m{2}.[xx{2}.`2])); 
       1: by auto => /> &1 &2 *; do split;smt(@SmtMap @FSet get_setE mem_frng rngE collision_add).
      by auto => /> &1 &2  /> /#. 
    rcondf{2} 2; 1: by auto => />. 
    seq 0 1 : (#pre); 1 : by auto.
    by auto => /> &1 &2  /> /#. 
 qed.

  local lemma HCo_ll (S <: ASampler{-AB}) : 
    islossless S.s =>
    islossless AB(S).HC.o by 
      move => S_ll; proc;  if; wp; [call (_: true) => /= | auto] =>//. 

  local lemma AB_ll (S <: ASampler {-AB}): islossless S.s => islossless AB(S).a.
  proof.
  move=> S_ll; proc; inline*; wp.
 seq 1 : true  => //; 1: by auto. 
 seq 1 : true => //.
 + call(_: true) => //. 
   + move => H Hl; apply (A_ll H Hl).  
     by apply (HCo_ll S);apply S_ll.
 seq 1 : true  => //; 1: by auto.
 seq 1 : true => //.
+  if; auto => />; 1: by conseq(_: true ==> _)=> //; call S_ll => />.
 seq 2 : true => //; 1: by auto.
+  if; auto => />;1: by conseq(_: true ==> _)=> //; call S_ll => />.
  qed.



  local hoare LRO_bounded : ROM_.Exp(Lazy.LRO, D(A)).main : 
       true ==> card (fdom Lazy.LRO.m) <= q + 2.
  proof. proc; inline *;wp;rnd;wp;rnd;wp.
    call (_:  Lazy.LRO.m = empty /\ QRO.ch = 0 ==> QRO.ch <= q /\ card (fdom Lazy.LRO.m) <= QRO.ch). 
  conseq (:  QRO.ch = 0 ==> QRO.ch <= q)
          (_: card (fdom Lazy.LRO.m) <= QRO.ch ==> card (fdom Lazy.LRO.m) <= QRO.ch). 
    smt(@SmtMap). 
    + proc(  card (fdom Lazy.LRO.m) <= QRO.ch); 1,2: smt().
      by proc; inline *; auto => />;smt(@SmtMap).
    apply (A_Bounded).
    auto => /> ; smt(@SmtMap).
  qed.

  lemma pr_collision &m i_:
    Pr[ROM_.Exp(Lazy.LRO, D(A)).main(i_) @ &m: res]
        <= ((q+2)*(q+1))%r/2%r * mu1 dhash witness.
  proof.
  have Hm2: exists &m2, AB.i{m2} = i_ /\ (glob A){m2} = (glob A){m}. admit.
  elim Hm2 => &m2 Hi.
  apply (ler_trans (Pr[Exp(Sample,AB).main() @ &m2: !uniq Sample.l])).
  + byequiv => //. 
    symmetry; proc *; inline Exp(Sample, AB).main.
    call (Col_Exp i_); 1: by inline *; auto.
  have /=  := (pr_collision AB _ _ &m2); last by smt().
  + by move => S S_ll; apply (AB_ll S S_ll).
  conseq (Col_Exp i_) (LRO_bounded); last by smt(). 
  move => &1 ?; exists  (glob A){1} => />. exists i_; do split.
  admit. smt(). 
  qed.

  lemma Conclusion &m i_:
    `|Pr[ROM_.Exp(Lazy.LRO, D(A)).main(i_) @ &m: res]|
      <= ((q+2)*(q+1))%r/2%r * mu1 dhash witness.
  proof.
    by move:  (pr_collision &m i_);smt(mu_bounded).
  qed.

end section CollisionProbability.


  lemma pr_col i_ (A<:AdvCol_C{-ERO, -QRO, -Lazy.LRO}) &m:
    (forall (O <: POracle), islossless O.o => islossless A(O).main) =>
    (hoare [A(D(A, Lazy.LRO).HC).main : QRO.ch = 0 ==> QRO.ch <= q]) =>
    let r = mu1 dhash witness in
    hoare [Col_C(A).main : i = i_ /\ QRO.ch = 0 ==> QRO.ch <= q] =>
    Pr[Col_C(A).main(i_) @ &m : res] <= ((q+2)*(q+1))%r/2%r * mu1 dhash witness.
move => A_ll A_Bounded r Hh.
have ->  : Pr[Col_C(A).main(i_) @ &m : res] =
          Pr[ Exp(Lazy.LRO, D(A)).main(i_) @ &m : res].
+ have -> : Pr[Col_C(A).main(i_) @ &m : res] =
          Pr[ Exp(ERO, D(A)).main(i_) @ &m : res].
  byequiv => //.
  proc; inline *;wp;call(_: ={glob ERO}); 1: by sim.
  wp;conseq (_: _ ==> ={glob ERO} /\ forall x, x \in ERO.m{1}); 1: by smt(). 
  while (w{1} = drop (FinT.card - size w{1}) FinT.enum /\
         ={glob ERO, w} /\ forall x, x \in ERO.m{2} <=> 
              x \in drop (size w{2}) FinT.enum); last first.
  + auto => />; do split.
    + by rewrite /FinT.card /= drop0.
    + move => x2; by rewrite drop_size /= mem_empty. 
    by move => mr; rewrite drop0 /= => Hx;  smt(FinT.enumP).
  auto => /> &2 Hs Hx Hl y ym; rewrite Hs;split.
  + have -> /= : size (behead (drop (FinT.card - size w{2}) FinT.enum)) = 
              size (drop (FinT.card - size w{2}) FinT.enum) -1 by smt().
    have -> : FinT.card - (size (drop (FinT.card - size w{2}) FinT.enum) - 1) = 
              ( FinT.card - (size (drop (FinT.card - size w{2}) FinT.enum))) + 1 by ring.
    rewrite (drop_nth witness  (FinT.card - size w{2}) FinT.enum) /=; 1:  by smt(size_ge0).
    by smt(@List). 
  + (* 
     move => x; rewrite -(head_behead w{2} witness Hl) /=. smt.
    rewrite (drop_nth witness (size (behead w{2}))) /=; 1: by rewrite size_ge0 /= /#. 
  + split.
    + case (x = (head witness w{2})).  
      + move => ->>; rewrite mem_set /=.*)
  admit.
  byequiv  (: ={QRO.ch, glob A} /\ ={arg}  ==> ={res}) => //.
  symmetry; conseq (: ={QRO.ch, glob A} /\ ={arg}  ==> ={res}) => //.
  by apply (eq_eager_sampling (D(A)) _);1:by move => *;apply dhash_ll.
  move:  (Conclusion A _ _ &m i_).
  + by move => O Oll; apply (A_ll O Oll). 
  + apply A_Bounded.
  by smt(mu_bounded).
qed.

end CLASSICAL.

end Collision.

(* -------------------------------------------------------------------------- *)
(* Biased distribution over boolean return true with probability p *)   


(* -------------------------------------------------------------------------- *)
(* Semi Constant Definition Property *)
abstract theory SemiConstDistr.

clone import DFunBiasedSingle with
   type X <- from,
   theory MUFF <- MUFF
   proof *.

op k : int.

type result = bool * from * from list.

op good(bf : from -> bool, x : from, l : from list) = 
     bf x /\ (forall x', x' \in l => !bf x') /\ size l <= k.

quantum module type AdvSCD (H:QRO) = {
  proc main() : result
}.
 
module SCD (A:AdvSCD) = {
  var bf : from -> bool
  var x : from
  var l : from list

  proc _F0(p:real) = {
    var c, y;
    bf <$ dbfun p;
    QRO.init();
    y  <$ dhash; 
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }

  proc _F1(p:real) = {
    var c, y;
    bf <$ dbfun p;
    QRO.init();
    y  <$ dhash; 
    QRO.h <- fun m => if bf m then y else QRO.h m;
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }
}.

axiom advantage q lambda (A<:AdvSCD{-SCD,-QRO}) &m:
  0%r <= lambda <= 1%r =>
  hoare [SCD(A)._F0 : p = lambda ==> QRO.ch <= q] =>
  `| Pr[SCD(A)._F0(lambda) @ &m : res] - Pr[SCD(A)._F1(lambda) @ &m: res] | 
   <= (2%r * q%r + k%r + 1%r)/ 6%r * lambda^2.

end SemiConstDistr.

abstract theory SmallRange.

clone import DFunSmallRange with 
    type X <- from,
    theory MUFF <- MUFF
    proof *.

type R.

clone import MFinite as Rt with
  type t <- R.

op _r =  Rt.Support.card.

op r2i(r : R) = find (pred1 r) Rt.Support.enum.

lemma r2i_range x : 0 <= r2i x < _r.
rewrite /r2i;split; first by smt(find_ge0). 
move => *;have <- := has_find (pred1 x) Support.enum. 
rewrite has_pred1; apply Support.enumP.
qed.

module type SR_i = {
  proc init () : unit
  quantum proc h {_:from} : hash    
}.

module type SR = {
  include SR_i [-init]
}.


quantum module type AdvSR (H:SR) = {
  proc main() : bool
}.


op difun_R = dfun (fun _=> dunifin).

module SR : SR_i = {
  var rh : hash list
  var fr : from -> R
  proc init () = {
    rh <$ dlist dhash _r;
    fr <$ difun_R; 
    QRO.ch <- 0;
    QRO.h <- fun x => nth witness rh (r2i (fr x)); 
  } 

  include QRO [h]
}.

module SRO : SR_i = {
  proc init () = {
    SR.fr <$ difun_R; 
    QRO.init();
  } 

  include QRO [h]
}.

module IND_SR (H:SR_i, A:AdvSR) = {
  proc main() : bool = {
    var b;

    H.init();
    b <@ A(H).main();
    return b;
  }
}.

(* This bound comes from Corollary 4.15 of Mark Zhandry's thesis *)
axiom advantage (q:int)  (A<:AdvSR{-SR,-QRO}) &m:
  0 < _r => 
  hoare [IND_SR(SRO,A).main : true ==> QRO.ch <= q] => 
  `| Pr[IND_SR(SRO,A).main() @ &m : res] - Pr[IND_SR(SR,A).main() @ &m : res] | <= 
      (27 * q^3)%r / _r%r.



module type SRr_i = {
  proc init () : unit
  quantum proc h {_:from} : R * hash    
}.

realize typing__0.
apply Finite.finite_type_pair. 
+ apply Rt.Support.is_finite.
apply MUFFH.FinT.is_finite.
qed.

module type SRr = {
  include SRr_i [-init]
}.

module SRr: SRr_i = {
  import var SR
  proc init () = {
    rh <$ dlist dhash _r;
    fr <$ difun_R; 
    QRO.ch <- 0;
    QRO.h <- fun x => nth witness rh (r2i (fr x)); 
  } 

  quantum proc h {x:from} = {
    QRO.ch <- QRO.ch + 1;
    return (fr x, QRO.h x);
  }
}.

realize typing__0.
apply Finite.finite_type_pair. 
+ apply Rt.Support.is_finite.
apply MUFFH.FinT.is_finite.
qed.


module SROr : SRr_i = {
  import var SR
  proc init () = {
    fr <$ difun_R; 
    QRO.init();
  } 

  include SRr [h]

}.

quantum module type AdvSRr (H:SRr) = {
  proc main() : bool
}.

module IND_SRr (H:SRr_i, A:AdvSRr) = {
  proc main() : bool = {
    var b;

    H.init();
    b <@ A(H).main();
    return b;
  }
}.

(* The proof of Theorem 4.16  gives a bound that is the summation
   of that in Corollary 4.15 and that in Theorem 4.9
   ( C(q + 2)^3/N) where C <= 27 is a constant and N=r. *)
axiom advantage_r (q:int)  (A<:AdvSRr{-SR,-QRO}) &m:
  0 < _r => 
  hoare [IND_SRr(SROr,A).main : true ==> QRO.ch <= q] => 
  `| Pr[IND_SRr(SROr,A).main() @ &m : res] - Pr[IND_SRr(SRr,A).main() @ &m : res] | <= 
      (54 * q^3)%r / _r%r.

end SmallRange.

(* 
    Mark Zhandry
    Secure Identity-Based Encryption in the Quantum Random Oracle Model
    https://eprint.iacr.org/2012/076.pdf
    Theorem 3.1.  *)

abstract theory QROM_Fundamental_Lemma.

clone import Tuple as TupleXY with 
  type t <- from * hash.

type result.

quantum module type AdvRO (H:QRO) = {
  proc main() : result
}.

module QRO_main_D(A : AdvRO) = {
  proc main(adfhash : (from -> hash) distr) = {
    var r;
    QRO.ch <- 0;
    QRO.h <$ adfhash;
    r <@ A(QRO).main();
    return r;
  }
}.

axiom dA_split q (A<:AdvRO{-QRO}) &m:
   hoare [ QRO_main_D(A).main : true ==> QRO.ch <= q] => 
   exists (C : (from * hash) list -> result -> real),
   forall (adfhash: (from -> hash) distr) (r:result),
    Pr[ QRO_main_D(A).main(adfhash) @ &m : res = r] = 
    big predT (fun l => 
      C l r * mu adfhash (fun fx => all (fun (xr:_*_) => fx xr.`1 = xr.`2) l))
        (wordn (2*q)).

end QROM_Fundamental_Lemma.

(* This is a PRF assumption against quantum adversaries,
   with quantum access to the prf *)
abstract theory T_PRF.

type key.
op dkey : key distr.
op F : key -> from -> hash.

quantum module type AdvRO (H:QRO) = {
  proc main() : bool
}.

module PRF : QRO_i = {
  var k : key
  proc init() = { QRO.ch <- 0; k <$ dkey; }
  quantum proc h{x:from} = { QRO.ch <- QRO.ch + 1; return F k x; } 
}.

module IND_QRO (R:QRO_i, A: AdvRO) = {
  proc main() : bool = {
    var b;
    R.init();
    b <@ A(R).main();
    return b;
  }
}.

(* The PRF-advantage is defined as :
   `| Pr[IND_QRO(PRF, A).main() @ &m : res] - Pr[IND_QRO(QRO, A).main() @ &m : res] | 
  The restriction on the number of queries can be obtained by adding the hypothesis:
   hoare [IND_QRO(QRO, A).main : true ==> QRO.ch <= q] or
   hoare [IND_QRO(PRF, A).main : true ==> QRO.ch <= q] 
  
*)

end T_PRF.

(* -------------------------------------------------------------------- *)
(* Finding q+1 distinct queries                                         *)
(* ---------------------------------------------------------------------*)

abstract theory T_Distinct.

(* This assume that the type hash is finite and contains "card" elements *)
clone export FinType.FinType with 
  type t <- hash.

quantum module type Adv_DistinctQueries (H:QRO) = {
  proc main(q:int) : (from * hash) list
}.

module DistinctQueries(A:Adv_DistinctQueries) = {
  proc main(q:int) : bool = {
    var fh : (from * hash) list;
    QRO.init();
    fh <@ A(QRO).main(q);
    return size fh = q + 1 /\ all (fun (p: from * hash) => QRO.h p.`1 = p.`2) fh; 
  }
}.

axiom bound_distinct (q_:int) (A<:Adv_DistinctQueries{-QRO}) &m :  
  hoare [DistinctQueries(A).main : q = q_ ==> QRO.ch <= q_] => 
    Pr[DistinctQueries(A).main(q_) @ &m : res] <= (q_ + 1)%r / FinT.card%r.

end T_Distinct.

(*
abstract theory T_PRG.

type seed.
op G : seed -> hash.

abstract theory T_OracleSecurePRG.

op [lossless uniform full] dF : (from -> seed) distr.

(* G is an oracle-secure PRG if (G ∘ F) is a PRF for random F. *)
module PRF : QRO_i = {
  var f : from -> seed
  proc init() = { f <$ dF; }
  quantum proc h {x : from} = { return G (f x); }
}.

(* G is oracle-secure if for polynomial q,
axiom advantage q (A <: AdvRO[main: `{Inf, #H.h : q}]) &m:
`| Pr[IND_QRO(PRF, A).main() @ &m : res] - Pr[IND_QRO(QRO, A).main() @ &m : res] | <= negl.
*)

end T_OracleSecurePRG.

abstract theory T_StandardSecurePRG.

op [lossless uniform full] dseed : seed distr.

(* random number generation *)
module type RGi = {
  proc init() : unit
  proc sample() : hash
}.

module type RG = {
  include RGi [sample]
}.

(* adversary *)
quantum module type AdvPRG (G : RG) = {
  proc main() : bool
}.

module IND_PRG(G : RGi, D : AdvPRG) = {
  proc main() : bool = {
    var b;
    G.init();
    b <@ D(G).main();
    return b;
  }
}.

module PRG : RGi = {
  var s : seed
  proc init() = {
    s <$ dseed;
  }
  proc sample() = {
    return G s;
  }
}.

module RG : RGi = {
  var r : hash
  proc init() = {
    r <$ dhash;
  }
  proc sample() = {
    return r;
  }
}.

(* G is standard-secure if for polynomial q,
axiom advantage q (A <: AdvPRG[main: `{Inf, #G.sample : q}]) &m:
`| Pr[IND_PRG(PRG, A).main() @ &m : res] - Pr[IND_PRG(RG, A).main() @ &m : res] | <= negl.
*)

end T_StandardSecurePRG.

end T_PRG.

*)

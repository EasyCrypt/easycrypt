require import AllCore List Distr DBool DProd DList DInterval CHoareTactic IntDiv SmtMap.
require import FunSamplingLib Birthday FSet.
(*   *) import StdOrder RField RealOrder StdBigop Bigreal BRA.
require (*  *) Matrix Tuple FinType ROM.

type from.

clone import MUniFinFun as MUFF with
  type t <- from.   (* This assumes that the type of from is finite *)


type hash.

clone  MUniFinFun as MUFFH with
  type t <- hash.   (* This assumes that the type of hash is finite *)

op [lossless uniform full ] dhash : hash distr.

clone ROM as ROM_ with
  type in_t <- from,
  type out_t <- hash,
  op dout <- fun _ => dhash,
  type d_out_t <- bool. (* FIX-ME: FIX LATER? *)

clone ROM_.LazyEager as LE with 
  theory FinType <- MUFF.FinT.


(* Uniform distribution over from -> hash *)
op dfhash : (from -> hash) distr = dfun (fun _ => dhash).

lemma dfhash_ll: is_lossless dfhash.
proof. apply dfun_ll => ?;apply dhash_ll. qed.

lemma dfhash_uni: is_uniform dfhash.
proof. apply dfun_uni => ?; apply dhash_uni. qed.

lemma dfhash_fu: is_full dhash => is_full dfhash.
proof. move=> dhash_fu; apply dfun_fu => ?; apply dhash_fu. qed.

hint solve 0 random : dfhash_ll dfhash_uni dfhash_fu.

module type QRO_i = {
  proc init () : unit
  quantum proc h {_:from} : hash 
}.


module type QRO = {
  include QRO_i [h]
}.

module QRO : QRO_i = {
  var  h : from -> hash
  var ch : int

  proc init() = { ch <- 0; h <$ dfhash; }

  quantum proc h {x:from} = { ch <- ch + 1; return h x; }
}.

require import DJoin.

theory CLASSICAL.

  (* Counting oracle calls using QRO.ch *)
  module WrapCtr(O : ROM_.Oracle) : ROM_.Oracle = {
    proc init() : unit = {
        O.init();
        QRO.ch <- 0;
    }

    proc o(x : from) : hash = {
        var r;
        r <@ O.o(x);
        QRO.ch <- QRO.ch + 1;
        return r;
    }
  }.

  section.

  local clone import JoinMapSampling with 
    type ta <- from, type tb <- hash
   proof *.

  local module M = { 
    proc init() = { 
      var l; 
      l <$ djoinmap (fun (_ : from) => dhash) FinT.enum;    
      QRO.h <- tofun l;  
    }
    
    proc init1() = {
      var l;
      l <@ S.sample((fun (_ : from) => dhash), FinT.enum);
      QRO.h <- tofun l;
    }

    proc init2() = {
      var l;
      l <@ S.loop_first((fun (_ : from) => dhash), FinT.enum);
      QRO.h <- tofun l;
    }

  }.

  equiv init_eager : QRO.init ~ LE.ERO.init :
       true ==> 
          forall x, x \in LE.ERO.m{2} /\
                 oget (LE.ERO.m{2}.[x]) = QRO.h{1} x.
  proof.
    transitivity M.init 
      (true ==> ={QRO.h} )
      (true ==> forall x, x \in LE.ERO.m{2} /\ oget (LE.ERO.m{2}.[x]) = QRO.h{1} x) => //.
    + proc.
      sp 1 0; rndsem{2} 0.
      rnd (fun f => (map f (FinT.enum), f)) (fun lf: _ * _ => lf.`2); skip.
      move=> &1 _ _; split.
      + move=> lh /supp_dmap [l] /= [/supp_djoinmap [hsz /allP /= hall]] -> /=.
        apply (eq_from_nth witness); 1: by rewrite size_map hsz.
        move=> i hi; rewrite (nth_map witness) 1:hsz 1://.
        by rewrite /tofun index_uniq 1:hsz // FinT.enum_uniq.
      move=> _; split. 
      + move=> [l f] /supp_dmap [l1 ] /= [] /supp_djoinmap [hsz /allP /= hall] [<<- ->>].
        rewrite (in_dmap1E_can _ _ (fun lf: _ * _ => lf.`1)) //.
        rewrite /dfhash dfun1E_djoin; congr; apply fun_ext => x /=.
        rewrite /pred1 /tofun; congr.
        rewrite -{2}(map_nth_range witness FinT.enum)  -{1}(map_nth_range witness l).
        rewrite -map_comp /(\o) /= hsz; apply eq_in_map => i /mem_range hi /=.
        rewrite index_uniq 1:hsz // FinT.enum_uniq.
      move=> _ f /dfun_supp /= hin; apply/supp_dmap => /=; exists (map f FinT.enum) => /=; split.
      + apply/supp_djoinmap; rewrite size_map /=; apply /allP.
        by move=> [x y] /mem_zip /= [? /mapP [x' [? ->]]]; apply hin.
      rewrite /tofun; apply fun_ext => x.
      rewrite (nth_map witness); 1: by rewrite index_mem index_ge0 FinT.enumP.
      by rewrite nth_index // FinT.enumP.
    transitivity M.init1 
      (true ==> ={QRO.h} )
      (true ==> forall x, x \in LE.ERO.m{2} /\ oget (LE.ERO.m{2}.[x]) = QRO.h{1} x) => //.
    + by proc; inline *; auto.
    transitivity M.init2 
      (true ==> ={QRO.h} )
      (true ==> forall x, x \in LE.ERO.m{2} /\ oget (LE.ERO.m{2}.[x]) = QRO.h{1} x) => //.
    + by proc; wp; call Sample_Loop_first_eq; auto.
    proc; inline *; wp.
    while (xs{1} = w{2} /\ d{1} = (fun _ => dhash) /\
           exists hd, 
             FinT.enum = hd ++ xs{1} /\ 
             (forall x, x \in hd <=> x \in LE.ERO.m{2}) /\
             map (fun x => oget LE.ERO.m{2}.[x]) hd = l0{1}).
    + wp; auto => |> &2; case: (w{2}) => //= x w hd heq hin r _.
      exists (rcons hd x); rewrite heq cat_rcons /= map_rcons /=; split.
      + by move=> x'; rewrite mem_rcons /= mem_set /#.
      congr.
      + apply eq_in_map => /= x' hx'; rewrite get_set_neqE //.
        by apply/negP => ->>; have := FinT.enum_uniq; rewrite heq cat_uniq => />; rewrite hx'.
      by rewrite get_set_eqE. 
    auto => />; split; 1: by exists [] => /= x; rewrite mem_empty.
    move=> m ?; rewrite cats0 => <<- hin x.
    rewrite -hin FinT.enumP /= /tofun (nth_map witness) /=.
    + by rewrite index_mem index_ge0 FinT.enumP.
    rewrite nth_index // FinT.enumP.
  qed.

  end section.

  equiv init_eager_ctr : QRO.init ~ WrapCtr(LE.ERO).init :
       true ==> ={QRO.ch} /\ QRO.ch{1} = 0 /\
          forall x, x \in LE.ERO.m{2} /\
                 oget (LE.ERO.m{2}.[x]) = QRO.h{1} x.
  conseq (_: true ==> 
          forall x, x \in LE.ERO.m{2} /\
                 oget (LE.ERO.m{2}.[x]) = QRO.h{1} x) 
          (_: true ==> QRO.ch = 0) 
          (_: true ==> QRO.ch = 0).  
  + by smt().
  + by proc; auto => />.
  + by proc; auto => />.
  + by proc*; inline{2} 1; wp; conseq />; call init_eager => />.
  qed.

end CLASSICAL.

abstract theory Collision.
   
  op q : { int | 0 <= q } as ge0_q.  
  type input.

  quantum module type AdvCol_Aux (H:QRO) = {
    proc main(i:input) : from * from
  }.

  quantum module type AdvCol (H:QRO) = {
    proc main() : from * from
  }.
  
  module Col_Aux(A:AdvCol_Aux) = {
    proc main(i:input) = {
      var xx;
      QRO.init();
      xx <@ A(QRO).main(i);
      return (xx.`1 <> xx.`2 && QRO.h xx.`1 = QRO.h xx.`2);
    }
  }.

  module Col(A:AdvCol) = {
    proc main() = {
      var xx;
      QRO.init();
      xx <@ A(QRO).main();
      return (xx.`1 <> xx.`2 && QRO.h xx.`1 = QRO.h xx.`2);
    }
  }.

  (* Thm 3.9 in MZ Thesis: N is the card of hash type. *)
  (* This version allows auxilliary information and q
     to be set interdependently *)
  (* Thm 2.1 in qrom_axioms.pdf *)
  axiom pr_col_aux i_ q (A<:AdvCol_Aux{-QRO}) &m:
    let r = mu1 dhash witness in
    hoare [Col_Aux(A).main : i = i_ /\ QRO.ch = 0 ==> QRO.ch <= q] =>
    Pr[Col_Aux(A).main(i_) @ &m : res] <= (27 *(q +2)^3)%r * r. 

  (* Thm 3.9 in MZ Thesis: N is the card of hash type. *)
  (* Thm 2.1 in qrom_axioms.pdf *)
  axiom pr_col (A<:AdvCol{-QRO}) &m:
    let r = mu1 dhash witness in
    hoare [Col(A).main :QRO.ch = 0 ==> QRO.ch <= q] =>
    Pr[Col(A).main() @ &m : res] <= (27 *(q +2)^3)%r * r. 

theory CLASSICAL.
  import ROM_.
  import LE.
  import CLASSICAL.

  module type AdvCol_C (H: POracle) = {
    proc main() : from * from
  }.
  
  module Col_C(A:AdvCol_C) = {
    proc main() = {
      var xx;
      WrapCtr(ERO).init();
      xx <@ A(WrapCtr(ERO)).main();
      return (xx.`1 <> xx.`2 && ERO.m.[xx.`1] = ERO.m.[xx.`2]);
    }
  }.

module (D(A : AdvCol_C): Distinguisher) (H : POracle)   = {

  module HC = {
    proc o(x : from) : hash = {
        var r;
        r <@ H.o(x);
        QRO.ch <- QRO.ch + 1;
        return r;
    }
  }

  proc run(i : d_in_t): bool = {
      var xx,h1,h2;
      QRO.ch <- 0;
      xx <@ A(HC).main();
      h1 <@ H.o(xx.`1);
      h2 <@ H.o(xx.`2);
      return (xx.`1 <> xx.`2 && h1 = h2);

  } 
}.

(* The following was a dirty copy from RP_RF *)
section CollisionProbability.
  declare module A <:AdvCol_C{-ERO, -QRO, -Lazy.LRO}.


  declare axiom A_ll (O <: POracle {-A}): islossless O.o => islossless A(O).main.
  declare axiom A_Bounded : hoare [A(D(A, Lazy.LRO).HC).main : QRO.ch = 0 ==> QRO.ch <= q].

  local clone import Birthday as BBound with
    op   q <- q + 2,
    type T <- hash,
    op   uT <- dhash,
    op maxu <- witness
  proof *.
  realize ge0_q by smt(ge0_q).
  realize maxuP by smt(dhash_fu dhash_ll dhash_uni is_full_funiform). 

  (* We construct a Birthday Bound adversary from the Coll
     experiment. *)
  local module (AB:Adv) (S:ASampler) = {
    (* We simulate an f-oracle using the s-oracle *)
    module HC = {
      proc init = Lazy.LRO.init

      proc o(x:from): hash = {
        var r;
        if (x \notin Lazy.LRO.m) {
          r <@ S.s();
          Lazy.LRO.m.[x] <- r;
        }
        return oget Lazy.LRO.m.[x];
      }
    }

    proc a(): unit = {
      var xx,h1,h2;
      HC.init();
      xx <@ A(HC).main();
      h1 <@ HC.o(xx.`1);
      h2 <@ HC.o(xx.`2);
    }
  }.

  pred collision (m:(from,hash) fmap) = exists x x',
    x' <> x /\
    x \in m /\ x' \in m /\ m.[x] = m.[x'].

  (* Some useful facts about the bad event *)
  lemma no_collision (m:(from,hash) fmap):
    !collision m <=>
    forall x x',
      x' = x \/
      !x \in m  \/
      !x' \in m \/
      m.[x] <> m.[x'].
  proof.
  rewrite /collision negb_exists /=; apply/forall_iff=> /= x.
  by rewrite negb_exists /=; apply/forall_iff=> /= x'; rewrite !negb_and.
  qed.

  lemma collision_add (m:(from,hash) fmap) x y:
    !x \in m =>
    collision m.[x <- y] <=> collision m \/ rng m y.
  proof.
  move=> x_notin_m; split=> [[z z' [z'_neq_z]]|].
  + rewrite mem_set=> -[z_in_m] [z'_in_m] mz_eq_mz'.
    case (rng m y)=> //= y_notin_rngm.
    by exists z z'; smt(@SmtMap).
  move=> [[z z' [z'_neq_z] [z_in_m] [z'_in_m] mz_eq_mz']|].
  + exists z z'; rewrite z'_neq_z !mem_set !get_setE mz_eq_mz' z_in_m z'_in_m /=.
    move/contra: (congr1 (dom m) z x); rewrite x_notin_m z_in_m=> -> //=.
    by move/contra: (congr1 (dom m) z' x); rewrite x_notin_m z'_in_m=> -> //=.
  rewrite rngE=> - /= [x'] mx'_y.
  by exists x x'; smt(@SmtMap).
  qed.

  lemma collision_stable (m:(from,hash) fmap) y y':
    collision m =>
    y \notin m =>
    collision m.[y <- y'].
  proof. by move=> h /collision_add /= ->; rewrite h. qed.

  local equiv Col_Exp : 
     AB(Sample).a ~ ROM_.Exp(Lazy.LRO, D(A)).main : 
       ={glob A} /\ size Sample.l{1} = 0 ==>
         (res{2} => !uniq Sample.l{1}) /\
         size Sample.l{1} = card (fdom Lazy.LRO.m){2}.
  proof.
  proc; inline*.
  sp;seq 1 1:  (={Lazy.LRO.m, glob A,xx} /\
           size Sample.l{1} = card (fdom Lazy.LRO.m){2} /\
           (forall x, mem (frng Lazy.LRO.m) x <=> mem Sample.l x){1} /\
           (collision Lazy.LRO.m{2} => !uniq Sample.l{1})).
  + call (_: ={Lazy.LRO.m} /\
           size Sample.l{1} = card (fdom Lazy.LRO.m){2} /\
           (forall x, mem (frng Lazy.LRO.m) x <=> mem Sample.l x){1} /\
           (collision Lazy.LRO.m{2} => !uniq Sample.l{1})).
    + proc; inline*;wp;if{1}.
      + auto => /> &1 &2 h1 h2 h3 h4 r _.
        rewrite fdom_set fcardUI_indep 2:fcard1; 1: by rewrite fsetI1 mem_fdom h4.
        + by do split;smt(get_setE mem_frng rngE collision_add).
        by auto; smt (size_eq0 fdom0 fcards0 frng0 in_fset0 mem_empty).
    by auto => />; smt (size_eq0 fdom0 fcards0 frng0 in_fset0 mem_empty).
  sp; if{1}.
  + rcondt{2} 2; 1: by auto => />. 
    seq 1 1 : (#pre /\ r1{1} = r0{2}); 1 : by auto.
    seq 4 2 : (#{/~x{1}}pre /\ xx.`1{2} \in Lazy.LRO.m{2} /\ h1{2} = oget (Lazy.LRO.m{2}.[xx{2}.`1])); 
       1: by auto => /> &1 &2 *; do split;smt(@SmtMap @FSet get_setE mem_frng rngE collision_add).   
    sp; if{1}.
    + rcondt{2} 2; 1: by auto => />. 
      seq 1 1 : (#pre /\ r2{1} = r1{2}); 1 : by auto.
      seq 4 2 : (#{/~x0{1}}pre /\ xx.`2{2}  \in Lazy.LRO.m{2} /\ h2{2} = oget (Lazy.LRO.m{2}.[xx{2}.`2])); 
       1: by auto => /> &1 &2 *; do split;smt(@SmtMap @FSet get_setE mem_frng rngE collision_add).
      by auto => /> &1 &2  /> /#. 
    rcondf{2} 2; 1: by auto => />. 
    seq 0 1 : (#pre); 1 : by auto.
    by auto => /> &1 &2  /> /#. 
  rcondf{2} 2; 1: by auto => />. 
  seq 0 1 : (#pre); 1 : by auto.
  seq 1 1 : (#{/~x{1}}pre /\ xx.`1{2} \in Lazy.LRO.m{2} /\ h1{2} = oget (Lazy.LRO.m{2}.[xx{2}.`1])); 
       1: by auto => /> &1 &2 *; do split;smt(@SmtMap @FSet get_setE mem_frng rngE collision_add).   
    sp; if{1}.
    + rcondt{2} 2; 1: by auto => />. 
      seq 1 1 : (#pre /\ r2{1} = r1{2}); 1 : by auto.
      seq 4 2 : (#{/~x0{1}}pre /\ xx.`2{2}  \in Lazy.LRO.m{2} /\ h2{2} = oget (Lazy.LRO.m{2}.[xx{2}.`2])); 
       1: by auto => /> &1 &2 *; do split;smt(@SmtMap @FSet get_setE mem_frng rngE collision_add).
      by auto => /> &1 &2  /> /#. 
    rcondf{2} 2; 1: by auto => />. 
    seq 0 1 : (#pre); 1 : by auto.
    by auto => /> &1 &2  /> /#. 
 qed.

  local lemma HCo_ll (S <: ASampler{-AB}) : 
    islossless S.s =>
    islossless AB(S).HC.o by 
      move => S_ll; proc;  if; wp; [call (_: true) => /= | auto] =>//. 

  local lemma AB_ll (S <: ASampler {-AB}): islossless S.s => islossless AB(S).a.
  proof.
  move=> S_ll; proc; inline*; wp.
 seq 1 : true  => //; 1: by auto. 
 seq 1 : true => //.
 + call(_: true) => //. 
   + move => H Hl; apply (A_ll H Hl).  
     by apply (HCo_ll S);apply S_ll.
 seq 1 : true  => //; 1: by auto.
 seq 1 : true => //.
+  if; auto => />; 1: by conseq(_: true ==> _)=> //; call S_ll => />.
 seq 2 : true => //; 1: by auto.
+  if; auto => />;1: by conseq(_: true ==> _)=> //; call S_ll => />.
  qed.



  local hoare LRO_bounded : ROM_.Exp(Lazy.LRO, D(A)).main : 
       true ==> card (fdom Lazy.LRO.m) <= q + 2.
  proof. proc; inline *;wp;rnd;wp;rnd;wp.
    call (_:  Lazy.LRO.m = empty /\ QRO.ch = 0 ==> QRO.ch <= q /\ card (fdom Lazy.LRO.m) <= QRO.ch). 
  conseq (:  QRO.ch = 0 ==> QRO.ch <= q)
          (_: card (fdom Lazy.LRO.m) <= QRO.ch ==> card (fdom Lazy.LRO.m) <= QRO.ch). 
    smt(@SmtMap). 
    + proc(  card (fdom Lazy.LRO.m) <= QRO.ch); 1,2: smt().
      by proc; inline *; auto => />;smt(@SmtMap).
    apply (A_Bounded).
    auto => /> ; smt(@SmtMap).
  qed.

  lemma pr_collision &m i_:
    Pr[ROM_.Exp(Lazy.LRO, D(A)).main(i_) @ &m: res]
        <= ((q+2)*(q+1))%r/2%r * mu1 dhash witness.
  proof.
  apply (ler_trans (Pr[Exp(Sample,AB).main() @ &m: !uniq Sample.l])).
  + byequiv => //. 
    symmetry; proc *; inline Exp(Sample, AB).main.
    call (Col_Exp); 1: by inline *; auto.
  have /=  := (pr_collision AB _ _ &m); last by smt().
  + by move => S S_ll; apply (AB_ll S S_ll).
  conseq (Col_Exp ) (LRO_bounded); by smt(). 
  qed.

  lemma Conclusion &m i_:
    `|Pr[ROM_.Exp(Lazy.LRO, D(A)).main(i_) @ &m: res]|
      <= ((q+2)*(q+1))%r/2%r * mu1 dhash witness.
  proof.
    by move:  (pr_collision &m i_);smt(mu_bounded).
  qed.

end section CollisionProbability.


  lemma pr_col (A<:AdvCol_C{-ERO, -QRO, -Lazy.LRO}) &m:
    (forall (O <: POracle {-A}), islossless O.o => islossless A(O).main) =>
    (hoare [A(D(A, Lazy.LRO).HC).main : QRO.ch = 0 ==> QRO.ch <= q]) =>
    Pr[Col_C(A).main() @ &m : res] <= ((q+2)*(q+1))%r/2%r * mu1 dhash witness.
move => A_ll A_Bounded.
have ->  : Pr[Col_C(A).main() @ &m : res] =
          Pr[ Exp(Lazy.LRO, D(A)).main(witness) @ &m : res].
+ have -> : Pr[Col_C(A).main() @ &m : res] =
          Pr[ Exp(ERO, D(A)).main(witness) @ &m : res].
  byequiv => //.
  proc; inline *;wp;call(_: ={glob ERO}); 1: by sim.
  wp;conseq (_: _ ==> ={glob ERO} /\ forall x, x \in ERO.m{1}); 1: by smt(). 
  while (w{1} = drop (FinT.card - size w{1}) FinT.enum /\
         ={glob ERO, w} /\ forall x, x \in ERO.m{2} <=> 
              x \in take (FinT.card - size w{1}) FinT.enum); last first.
  + auto => />; do split.
    + by rewrite /FinT.card /= drop0.
    + by move => x2;  rewrite mem_empty /= /#. 
    by move => mr ?;  smt(take_size FinT.enumP).
  auto => /> &2 Hs Hx Hl y ym; rewrite Hs.
  have H1 /= : size (behead (drop (FinT.card - size w{2}) FinT.enum)) = 
              size (drop (FinT.card - size w{2}) FinT.enum) -1 by smt().
  have H2 /= : FinT.card - (size (drop (FinT.card - size w{2}) FinT.enum) - 1) = 
              ( FinT.card - (size (drop (FinT.card - size w{2}) FinT.enum))) + 1 by ring.
  split; 1: by rewrite H1 H2 {1}(drop_nth witness  (FinT.card - size w{2}) FinT.enum) /=;  smt(size_ge0).
  move => xx; rewrite !H1;rewrite 
     (drop_nth witness  (FinT.card - size w{2}) FinT.enum) /=; 1: by smt(size_ge0). 
  have -> : (FinT.card - size (drop (FinT.card - size w{2} + 1) FinT.enum))  = 
            FinT.card - size w{2} +1  by smt(size_drop).  
  rewrite mem_set; split. 
  + move => H; elim H;  smt(@List) . 
  rewrite (take_nth witness) /=; 1: smt(size_ge0). 
  by rewrite mem_rcons /=; smt(@List).
   
  byequiv  (: ={QRO.ch, glob A} /\ ={arg}  ==> ={res}) => //.
  symmetry; conseq (: ={QRO.ch, glob A} /\ ={arg}  ==> ={res}) => //.
  by apply (eq_eager_sampling (D(A)) _);1:by move => *;apply dhash_ll.
  move:  (Conclusion A _ _ &m).
  + by move => O Oll; apply (A_ll O Oll). 
  + apply A_Bounded.
  by smt(mu_bounded).
qed.

end CLASSICAL.

end Collision.

(* -------------------------------------------------------------------------- *)
(* Biased distribution over boolean return true with probability p *)   


(* -------------------------------------------------------------------------- *)
(* Semi Constant Definition Property *)
abstract theory SemiConstDistr.

clone import DFunBiasedSingle with
   type X <- from,
   theory MUFF <- MUFF
   proof *.

op k : int.

type result = bool * from * from list.

op good(bf : from -> bool, x : from, l : from list) = 
     bf x /\ (forall x', x' \in l => !bf x') /\ size l <= k.

quantum module type AdvSCD (H:QRO) = {
  proc main() : result
}.
 
module SCD (A:AdvSCD) = {
  var bf : from -> bool
  var x : from
  var l : from list

  proc _F0(p:real) = {
    var c, y;
    bf <$ dbfun p;
    QRO.init();
    y  <$ dhash; 
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }

  proc _F1(p:real) = {
    var c, y;
    bf <$ dbfun p;
    QRO.init();
    y  <$ dhash; 
    QRO.h <- fun m => if bf m then y else QRO.h m;
    (c,x,l)  <@ A(QRO).main();
    return (c /\ good bf x l);
  }
}.

  (* Thm 4.1 in qrom_axioms.pdf *)
axiom advantage q lambda (A<:AdvSCD{-SCD,-QRO}) &m:
  0%r <= lambda <= 1%r =>
  hoare [SCD(A)._F0 : p = lambda ==> QRO.ch <= q] =>
  `| Pr[SCD(A)._F0(lambda) @ &m : res] - Pr[SCD(A)._F1(lambda) @ &m: res] | 
   <= (2%r * q%r + k%r + 1%r)^4/ 6%r * lambda^2.

end SemiConstDistr.

abstract theory SmallRange.

clone import DFunSmallRange with 
    type X <- from,
    theory MUFF <- MUFF
    proof *.

type R.

clone import MFinite as Rt with
  type t <- R.

op _r =  Rt.Support.card.

op r2i(r : R) = find (pred1 r) Rt.Support.enum.

lemma r2i_range x : 0 <= r2i x < _r.
rewrite /r2i;split; first by smt(find_ge0). 
move => *;have <- := has_find (pred1 x) Support.enum. 
rewrite has_pred1; apply Support.enumP.
qed.

module type SR_i = {
  proc init () : unit
  quantum proc h {_:from} : hash    
}.

module type SR = {
  include SR_i [-init]
}.


quantum module type AdvSR (H:SR) = {
  proc main() : bool
}.


op difun_R = dfun (fun _=> dunifin).

module SR : SR_i = {
  var rh : hash list
  var fr : from -> R
  proc init () = {
    rh <$ dlist dhash _r;
    fr <$ difun_R; 
    QRO.ch <- 0;
    QRO.h <- fun x => nth witness rh (r2i (fr x)); 
  } 

  include QRO [h]
}.

module SRO : SR_i = {
  proc init () = {
    SR.fr <$ difun_R; 
    QRO.init();
  } 

  include QRO [h]
}.

module IND_SR (H:SR_i, A:AdvSR) = {
  proc main() : bool = {
    var b;

    H.init();
    b <@ A(H).main();
    return b;
  }
}.

(* This bound comes from Corollary 4.15 of Mark Zhandry's thesis *)
  (* Thm 5.1 in qrom_axioms.pdf *)
axiom advantage (q:int)  (A<:AdvSR{-SR,-QRO}) &m:
  0 < _r => 
  hoare [IND_SR(SRO,A).main : true ==> QRO.ch <= q] => 
  `| Pr[IND_SR(SRO,A).main() @ &m : res] - Pr[IND_SR(SR,A).main() @ &m : res] | <= 
      (27 * q^3)%r / _r%r.



module type SRr_i = {
  proc init () : unit
  quantum proc h {_:from} : R * hash    
}.

realize typing__0.
apply Finite.finite_type_pair. 
+ apply Rt.Support.is_finite.
apply MUFFH.FinT.is_finite.
qed.

module type SRr = {
  include SRr_i [-init]
}.

module SRr: SRr_i = {
  import var SR
  proc init () = {
    rh <$ dlist dhash _r;
    fr <$ difun_R; 
    QRO.ch <- 0;
    QRO.h <- fun x => nth witness rh (r2i (fr x)); 
  } 

  quantum proc h {x:from} = {
    QRO.ch <- QRO.ch + 1;
    return (fr x, QRO.h x);
  }
}.

realize typing__0.
apply Finite.finite_type_pair. 
+ apply Rt.Support.is_finite.
apply MUFFH.FinT.is_finite.
qed.


module SROr : SRr_i = {
  import var SR
  proc init () = {
    fr <$ difun_R; 
    QRO.init();
  } 

  include SRr [h]

}.

quantum module type AdvSRr (H:SRr) = {
  proc main() : bool
}.

module IND_SRr (H:SRr_i, A:AdvSRr) = {
  proc main() : bool = {
    var b;

    H.init();
    b <@ A(H).main();
    return b;
  }
}.

(* The proof of Theorem 4.16  gives a bound that is the summation
   of that in Corollary 4.15 and that in Theorem 4.9
   ( C(q + 2)^3/N) where C <= 27 is a constant and N=r. *)
  (* Thm 5.2 in qrom_axioms.pdf *)

axiom advantage_r (q:int)  (A<:AdvSRr{-SR,-QRO}) &m:
  0 < _r => 
  hoare [IND_SRr(SROr,A).main : true ==> QRO.ch <= q] => 
  `| Pr[IND_SRr(SROr,A).main() @ &m : res] - Pr[IND_SRr(SRr,A).main() @ &m : res] | <= 
      (54 * (q+2)^3)%r / _r%r.

end SmallRange.

(* 
    Mark Zhandry
    Secure Identity-Based Encryption in the Quantum Random Oracle Model
    https://eprint.iacr.org/2012/076.pdf
    Theorem 3.1.  *)
abstract theory QROM_Fundamental_Lemma.

clone import Tuple as TupleXY with 
  type t <- from * hash.

type result.

quantum module type AdvRO (H:QRO) = {
  proc main() : result
}.

module QRO_main_D(A : AdvRO) = {
  proc main(adfhash : (from -> hash) distr) = {
    var r;
    QRO.ch <- 0;
    QRO.h <$ adfhash;
    r <@ A(QRO).main();
    return r;
  }
}.

(* Thm 3.1 in qrom_axioms.pdf *)
axiom dA_split q (A<:AdvRO{-QRO}) &m:
   hoare [ QRO_main_D(A).main : true ==> QRO.ch <= q] => 
   exists (C : (from * hash) list -> result -> real),
   forall (adfhash: (from -> hash) distr) (r:result),
    Pr[ QRO_main_D(A).main(adfhash) @ &m : res = r] = 
    big predT (fun l => 
      C l r * mu adfhash (fun fx => all (fun (xr:_*_) => fx xr.`1 = xr.`2) l))
        (wordn (2*q)).

end QROM_Fundamental_Lemma.

(* This is a PRF assumption against quantum adversaries,
   with quantum access to the prf *)
abstract theory T_PRF.

type key.
op dkey : key distr.
op F : key -> from -> hash.

quantum module type AdvRO (H:QRO) = {
  proc main() : bool
}.

module PRF : QRO_i = {
  var k : key
  proc init() = { QRO.ch <- 0; k <$ dkey; }
  quantum proc h{x:from} = { QRO.ch <- QRO.ch + 1; return F k x; } 
}.

module IND_QRO (R:QRO_i, A: AdvRO) = {
  proc main() : bool = {
    var b;
    R.init();
    b <@ A(R).main();
    return b;
  }
}.

(* The PRF-advantage is defined as :
   `| Pr[IND_QRO(PRF, A).main() @ &m : res] - Pr[IND_QRO(QRO, A).main() @ &m : res] | 
  The restriction on the number of queries can be obtained by adding the hypothesis:
   hoare [IND_QRO(QRO, A).main : true ==> QRO.ch <= q] or
   hoare [IND_QRO(PRF, A).main : true ==> QRO.ch <= q] 
  
*)

end T_PRF.

(* -------------------------------------------------------------------- *)
(* Finding q+1 distinct queries                                         *)
(* ---------------------------------------------------------------------*)

abstract theory T_Distinct.

(* This assume that the type hash is finite and contains "card" elements *)
clone export FinType.FinType with 
  type t <- hash.

quantum module type Adv_DistinctQueries (H:QRO) = {
  proc main(q:int) : (from * hash) list
}.

module DistinctQueries(A:Adv_DistinctQueries) = {
  proc main(q:int) : bool = {
    var fh : (from * hash) list;
    QRO.init();
    fh <@ A(QRO).main(q);
    return size fh = q + 1 /\ all (fun (p: from * hash) => QRO.h p.`1 = p.`2) fh; 
  }
}.

  (* Thm 6.1 in qrom_axioms.pdf *)
axiom bound_distinct (q_:int) (A<:Adv_DistinctQueries{-QRO}) &m :  
  hoare [DistinctQueries(A).main : q = q_ ==> QRO.ch <= q_] => 
    Pr[DistinctQueries(A).main(q_) @ &m : res] <= (q_ + 1)%r / FinT.card%r.

end T_Distinct.

(*
abstract theory T_PRG.

type seed.
op G : seed -> hash.

abstract theory T_OracleSecurePRG.

op [lossless uniform full] dF : (from -> seed) distr.

(* G is an oracle-secure PRG if (G ∘ F) is a PRF for random F. *)
module PRF : QRO_i = {
  var f : from -> seed
  proc init() = { f <$ dF; }
  quantum proc h {x : from} = { return G (f x); }
}.

(* G is oracle-secure if for polynomial q,
axiom advantage q (A <: AdvRO[main: `{Inf, #H.h : q}]) &m:
`| Pr[IND_QRO(PRF, A).main() @ &m : res] - Pr[IND_QRO(QRO, A).main() @ &m : res] | <= negl.
*)

end T_OracleSecurePRG.

abstract theory T_StandardSecurePRG.

op [lossless uniform full] dseed : seed distr.

(* random number generation *)
module type RGi = {
  proc init() : unit
  proc sample() : hash
}.

module type RG = {
  include RGi [sample]
}.

(* adversary *)
quantum module type AdvPRG (G : RG) = {
  proc main() : bool
}.

module IND_PRG(G : RGi, D : AdvPRG) = {
  proc main() : bool = {
    var b;
    G.init();
    b <@ D(G).main();
    return b;
  }
}.

module PRG : RGi = {
  var s : seed
  proc init() = {
    s <$ dseed;
  }
  proc sample() = {
    return G s;
  }
}.

module RG : RGi = {
  var r : hash
  proc init() = {
    r <$ dhash;
  }
  proc sample() = {
    return r;
  }
}.

(* G is standard-secure if for polynomial q,
axiom advantage q (A <: AdvPRG[main: `{Inf, #G.sample : q}]) &m:
`| Pr[IND_PRG(PRG, A).main() @ &m : res] - Pr[IND_PRG(RG, A).main() @ &m : res] | <= negl.
*)

end T_StandardSecurePRG.

end T_PRG.

*)

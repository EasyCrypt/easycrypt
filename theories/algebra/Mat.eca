(* This theory contains a formalization of vectors and matrices with          *)
(* arbitrary and dynamic size.                                                *)

(* Many operations conventionally have requirements on the sizes of their     *)
(* operands. Matrix addition, for example, only makes sense if the matrices   *)
(* have the same size. The user is responsible for making sure that the       *)
(* parameters are valid. Many operators return the empty matrix/vector on     *)
(* malformed input, but not all, so checking the output is not a reliable way *)
(* to check that the parameters are valid.                                    *)

require import AllCore List Distr DBool DList.
import StdBigop.Bigreal StdOrder.IntOrder.

(* -------------------------------------------------------------------------- *)
require (*--*) Quotient StdOrder Bigalg.

(* -------------------------------------------------------------------------- *)
clone import Ring.ComRing as ZR.

type R = t.

(* -------------------------------------------------------------------------- *)
clone import Bigalg.BigComRing as Big with theory CR <- ZR proof *.
import BAdd.

(* -------------------------------------------------------------------------- *)

theory Vectors.

type vector.

type prevector = (int -> R) * int.

op vclamp (pv: prevector): prevector =
  ((fun i => if 0 <= i < pv.`2 then pv.`1 i else zeror), max 0 pv.`2).

lemma nosmt vclamp_idemp pv: vclamp (vclamp pv) = vclamp pv.
proof. rewrite /vclamp /#. qed.

op eqv (pv1 pv2: prevector) =
  vclamp pv1 = vclamp pv2.

lemma nosmt eqv_vclamp pv: eqv pv (vclamp pv). 
proof. by rewrite /eqv vclamp_idemp. qed.

clone import Quotient.EquivQuotient as QuotientVec with
  type T <- prevector,
  type qT <- vector,
  op eqv <- eqv
  proof EqvEquiv.* by smt().

op tofunv v = vclamp (repr v).

op offunv pv = pi (vclamp pv).

lemma tofunvK: cancel tofunv offunv.
proof. 
rewrite /tofunv /offunv /cancel => v; rewrite vclamp_idemp.
by rewrite -{2}[v]reprK -eqv_pi /eqv vclamp_idemp. 
qed.

lemma offunvK pv: tofunv (offunv pv) = vclamp pv.
proof. rewrite /tofunv /offunv eqv_repr /#. qed.

lemma vectorW (P : vector -> bool): 
  (forall pv, P (offunv pv)) => forall v, P v by smt(tofunvK).

(* Dimension of the vector *)
op size v = (tofunv v).`2.

lemma nosmt size_ge0 v: 0 <= size v by smt().

lemma nosmt max0size v: max 0 (size v) = size v by smt().

hint simplify max0size.

lemma offunv_max f n: offunv (f, max 0 n) = offunv (f, n).
proof. rewrite /offunv -eqv_pi /eqv /vclamp /#. qed.

lemma size_offunv f n: size (offunv (f, n)) = max 0 n.
proof. by rewrite /size offunvK /#. qed.

hint simplify size_offunv.

(* Getting the i-th element of a vector *)
op "_.[_]" (v: vector) (i : int) = (tofunv v).`1 i.

lemma offunvE f n (i : int) : 0 <= i < n =>
  (offunv (f, n)).[i] = f i.
proof. by rewrite /("_.[_]") /= offunvK /vclamp /= => ->. qed.

lemma getv0E (v: vector) (i: int) :
  !(0 <= i < size v) => v.[i] = zeror.
proof. rewrite /("_.[_]") /size /tofunv /#. qed.

lemma offunv0E f n (i : int) : !(0 <= i < n) =>
  (offunv (f, n)).[i] = zeror.
proof. move => ioutn. rewrite getv0E /= /#. qed.

lemma eq_vectorP (v1 v2 : vector) : (v1 = v2) <=> 
  (size v1 = size v2 /\ forall i, 0 <= i < size v1 => v1.[i] = v2.[i]).
proof. 
split => [->//|[eq_size eq_vi]].
have: tofunv v1 = tofunv v2 by rewrite /tofunv /vclamp /#.
smt(tofunvK). 
qed.

(* Constant valued vector of dimension n *)
op vectc n c = offunv ((fun _ => c), n).

lemma size_vectc n c: size (vectc n c) = max 0 n by done.

lemma vectcE n c i: 0 <= i < n => (vectc n c).[i] = c by smt(offunvE).

hint simplify size_vectc.

(* Zero-vector of dimension n *)
op zerov n = vectc n zeror.

lemma size_zerov n: size (zerov n) = max 0 n.
proof. by rewrite size_offunv. qed.

lemma zerovE n i: (zerov n).[i] = zeror.
proof.
case (0 <= i < n) => i_bound; first by rewrite offunvE. 
by rewrite getv0E ?size_zerov /#.
qed.

hint simplify size_zerov, zerovE.

(* The unique 0-size vector *)
op emptyv = zerov 0.

lemma size_emptyv: size emptyv = 0 by done.

lemma emptyvE i: emptyv.[i] = zeror by done.

hint simplify size_emptyv, emptyvE.

lemma emptyv_unique v: size v = 0 => v = emptyv.
proof. move => size_eq. apply eq_vectorP => /#. qed.

lemma size_vectc2 n c1 c2: vectc (size (vectc n c1)) c2 = vectc n c2.
proof. case (0 < n) => [/# | bd]. rewrite 2!(emptyv_unique (vectc _ _)) /#. qed.

lemma size_zerov2 n: zerov (size (zerov n)) = zerov n.
proof. rewrite /zerov. apply size_vectc2. qed.

(* Vector addition *)
op (+) (v1 v2 : vector) = if size v1 = size v2 then 
  offunv ((fun i => v1.[i] + v2.[i]), size v1) else emptyv.

lemma size_addv v1 v2: size (v1 + v2) = 
  if size v1 = size v2 then size v1 else 0.
proof. rewrite /(+). by case (size v1 = size v2). qed.

lemma size_addv_neq v1 v2: size v1 <> size v2 => v1 + v2 = emptyv. 
proof. by rewrite /(+) => ->. qed.

lemma getvD (v1 v2 : vector) i :
  size v1 = size v2 => (v1 + v2).[i] = v1.[i] + v2.[i].
proof.
case (0 <= i < size v2) => bound size_eq. 
- by rewrite /(+) size_eq /= offunvE.
- by rewrite !getv0E ?size_addv ?size_eq //= addr0.
qed.

(* Addition for some special vectors *)
lemma addv_emptyl v: emptyv + v = emptyv.
proof. apply emptyv_unique; smt(size_emptyv size_addv). qed.

lemma addv_emptyr v: v + emptyv = emptyv.
proof. apply emptyv_unique; smt(size_emptyv size_addv). qed.

hint simplify addv_emptyl, addv_emptyr.

(* Additive inverse of vector *)
op [-] (v: vector) = offunv ((fun i => -v.[i]), size v).

lemma getvN (v : vector) i : (-v).[i] = - v.[i].
proof.
case: (0 <= i < size v) => bound; 1: by rewrite /([-]) offunvE. 
by rewrite !getv0E /([-]) //= oppr0.
qed.

lemma nosmt sizeN v: size (-v) = size v by done.

hint simplify getvN, sizeN.

(* Simplifications for some special vectors *)
lemma zerovN n: -(zerov n) = zerov n.
proof. apply eq_vectorP => /= i bound. by rewrite oppr0. qed.

lemma emptyvN: - emptyv = emptyv by apply zerovN.

hint simplify zerovN, emptyvN.

(* Module-like properties of vectors *)
lemma addvA: associative Vectors.(+).
proof.
move => v1 v2 v3; case (size v1 = size v2) => size_eq1.
- case (size v2 = size v3) => size_eq2.
  + apply eq_vectorP => /=. 
    rewrite !size_addv size_eq1 size_eq2 /= => i bound.
    rewrite !getvD /= ?size_addv ?size_eq1 ?size_eq2 //.
    apply addrA.
  + rewrite (size_addv_neq _ v3) //= eq_sym.
    apply emptyv_unique.
    by rewrite 2!size_addv size_eq1 size_eq2.
- rewrite (size_addv_neq v1 v2) //=.
  apply emptyv_unique.
  rewrite 2!size_addv.
  case (size v2 = size v3) => /#. 
qed.

lemma addvC: commutative Vectors.(+).
proof.
move => v1 v2; case (size v1 = size v2) => size_eq; last first.
- by rewrite !size_addv_neq /#. 
apply eq_vectorP; rewrite !size_addv ?size_eq /= => i bound.
by rewrite !getvD 1,2:/# addrC.
qed.

lemma add0v v: zerov (size v) + v = v.
proof.
rewrite eq_vectorP size_addv /= => i bound. 
by rewrite getvD //= add0r.
qed.

hint simplify add0v.

lemma addv0 v: v + zerov (size v) = v by rewrite addvC.

abbrev (-) v1 v2 = v1 + (-v2).

lemma addNv v: v - v = zerov (size v).
proof. rewrite eq_vectorP size_addv /= => i bd. by rewrite getvD //= addrN. qed.

hint simplify addv0.

lemma oppvD (v1 v2: vector): -(v1 + v2) = -v1 + -v2.
proof.
case (size v1 = size v2) => size_eq; last by rewrite !size_addv_neq.
rewrite eq_vectorP; rewrite !(sizeN,size_addv) size_eq /= => i bound.
by rewrite !(getvN,getvD) // opprD.
qed.

lemma oppvK (v: vector): - (- v) = v.
proof.
rewrite eq_vectorP. 
split => [|i bound]; 1: by rewrite 2!sizeN.
by rewrite 2!getvN opprK.
qed.

(* Inner product *)
op dotp (v1 v2 : vector) = if size v1 = size v2 then 
  bigi predT (fun i => v1.[i] * v2.[i]) 0 (size v1) else zeror.

lemma dotp_size_diff (v1 v2: vector): size v1 <> size v2 =>
    dotp v1 v2 = zeror.
proof. by rewrite /dotp => ->. qed.

lemma dotpE v1 v2: dotp v1 v2 = if size v1 = size v2 then 
  bigi predT (fun i => v1.[i] * v2.[i]) 0 (size v1) else zeror by done.

lemma dotpC : commutative dotp.
proof.
move => v1 v2. 
case (size v1 = size v2) => [size_eq | size_neq].
- rewrite 2!dotpE size_eq /=. 
  apply eq_bigr => /= i _. 
  by rewrite mulrC.
- by rewrite 2!dotpE size_neq //= (eq_sym (size v2)) size_neq. 
qed.

lemma dotpNv v1 v2: dotp (-v1) v2 = - dotp v1 v2.
proof.
rewrite 2!dotpE /=.
case (size v1 = size v2) => _; last by rewrite oppr0.
rewrite sumrN.
apply eq_bigr => /= i _.
by rewrite mulNr.
qed.

hint simplify dotpNv.

lemma dotpDr v1 v2 v3 : size v2 = size v3 => 
  dotp v1 (v2 + v3) = dotp v1 v2 + dotp v1 v3.
proof.
move => size_eq1; rewrite 3!dotpE.
case (size v1 = size v2) => size_eq2.
- rewrite size_addv size_eq2 size_eq1 /= -big_split /=. 
  apply eq_bigr => /= i _.  
  by rewrite getvD // mulrDr.
- by rewrite size_addv -size_eq1 /= size_eq2 /= addr0.
qed.

lemma dotpDl v1 v2 v3 : size v1 = size v2 => 
  dotp (v1 + v2) v3 = dotp v1 v3 + dotp v2 v3.
proof. move => size_eq. by rewrite dotpC (dotpC v1) (dotpC v2) dotpDr. qed.

lemma dotp0r v n: dotp (zerov n) v = zeror.
proof.
case (size (zerov n) = size v) => size_eq; last by rewrite dotpE size_eq.
rewrite dotpE size_eq /=.
have ->: (fun (i : int) => zeror * v.[i]) = fun (_: int) => zeror.
- apply fun_ext => i. 
  apply mul0r.
apply big1_eq.
qed.

hint simplify dotp0r.

lemma dotpr0 v n: dotp v (zerov n) = zeror by rewrite dotpC.

hint simplify dotpr0.

(* Vector concatenation *)
op ( || ) (v1 v2: vector) = 
  offunv ((fun i => v1.[i] + v2.[i-size v1]), size v1 + size v2).

lemma size_concat (v1 v2: vector): size (v1 || v2) = (size v1 + size v2).
proof. rewrite /(||) /= /#. qed.

lemma concatE (v1 v2: vector) i: (v1 || v2).[i] = v1.[i] + v2.[i-size v1].
proof.
rewrite /(||).
case (0 <= i < size v1 + size v2) => range.
- rewrite offunvE //=.
- rewrite !getv0E 4:addr0 /#.
qed.

lemma get_catv (v1 v2: vector) i : 
  (v1 || v2).[i] = if i < size v1 then v1.[i] else v2.[i - size v1].
proof.
case (0 <= i < size v1 + size v2) => range; last first.
- rewrite !getv0E ?size_concat //; smt(size_ge0).
rewrite offunvE //=; case (i < size v1) => ?.
- by rewrite [v2.[_]]getv0E //= 1:/# addr0.
- by rewrite [v1.[_]]getv0E //= 1:/# add0r.
qed.

lemma get_catv_l (v1 v2: vector) i : 
  i < size v1 => (v1 || v2).[i] = v1.[i].
proof. smt(get_catv). qed. 

lemma get_catv_r (v1 v2: vector) i : 
  size v1 <= i => (v1 || v2).[i] = v2.[i - size v1].
proof. smt(get_catv). qed. 

lemma dotp_concat v1 v2 v3 v4: size v1 = size v3 => size v2 = size v4 =>
  dotp (v1 || v2) (v3 || v4) = (dotp v1 v3) + (dotp v2 v4).
proof.
move => size_eq1 size_eq2; rewrite /dotp !size_concat size_eq1 size_eq2 /=.
rewrite (range_cat (size v3)) 1:/# 1:/# big_cat; congr.
- by apply eq_big_seq => i /mem_range ? /=; smt(get_catv_l).
rewrite (big_addn 0 (size v3 + size v4) (size v3)) addzAC /=.
apply eq_big_seq => i /mem_range bound /=; smt(get_catv_r).
qed.

lemma addv_concat (v1 v2 v3 v4: vector): 
  size v1 = size v3 => size v2 = size v4 =>
  (v1 || v2) + (v3 || v4) = ((v1 + v3) || (v2 + v4)).
proof.
move => size_eq1 size_eq2; apply eq_vectorP. 
rewrite !(size_addv,size_concat) size_eq1 size_eq2 /= => i bound.
rewrite !getvD ?size_concat 1:/#. 
by rewrite !get_catv ?size_addv ?size_eq1 /= !getvD // /#.
qed.

lemma negv_concat (v1 v2: vector): - (v1 || v2) = (-v1 || -v2).
proof. by apply eq_vectorP => i bound /=; rewrite !concatE opprD. qed.

(* Splitting apart vectors *)
op subv (v: vector) (n m: int) = offunv ((fun i => v.[i+n]), m - n).

lemma size_subv (v: vector) (n m: int): size (subv v n m) = max 0 (m - n).
proof. by done. qed.

hint simplify size_subv.

lemma subvE (v: vector) (n m i: int): 0 <= i < m - n => 
  (subv v n m).[i] = v.[i+n].
proof. move => i_range; by rewrite /subv offunvE. qed.

(* Interactions between subv and concatenation *)
lemma subv_concatCl v1 v2: subv (v1 || v2) 0 (size v1) = v1.
proof.
rewrite eq_vectorP size_subv /= => i bound.
by rewrite subvE // concatE /= (getv0E v2) 1:/# addr0.
qed.

lemma subv_concatCr v1 v2: subv (v1 || v2) (size v1) (size v1 + size v2) = v2.
proof.
rewrite eq_vectorP size_subv. 
split => [/# | i bound].
rewrite subvE 1:/# concatE (getv0E v1) 1:/# add0r /#.
qed.

lemma concat_subvC v i: 0 <= i <= size v => 
  (subv v 0 i || subv v i (size v)) = v.
proof.
move => i_bound; rewrite eq_vectorP size_concat !size_subv /= -andaE. 
split => [/#|-> k k_bound]; case (k < i) => lt_i_k.
- rewrite get_catv_l; smt(subvE).
- rewrite get_catv_r; smt(subvE).
qed.
 
lemma subv_addv v1 v2 a b: size v1 = size v2 => 
    subv (v1 + v2) a b  = subv v1 a b + subv v2 a b.
proof.
move => size_eq; rewrite eq_vectorP ?size_addv /= => /= i bound.
rewrite subvE 1:/# !getvD // !subvE /#.
qed.

(* Updating one entry in a vector *)
op updv (v: vector) (n: int) (m: t) =
  offunv (fun i => if i = n then m else v.[i], size v).

lemma size_updv (v: vector) (n: int) (m: t): size (updv v n m) = size v by done.

lemma updvE (v: vector) (n i: int) (m: t): (0 <= i < size v) =>
    (updv v n m).[i] = if i = n then m else v.[i].
proof. rewrite /updv => i_bound. by rewrite offunvE. qed.

(* Multiplying vector by a scalar *)
op mulvs (v: vector) (s: t) = offunv(fun i => v.[i] * s, size v).

lemma size_mulvs (v: vector) (s: t): size (mulvs v s) = size v by done.

lemma mulvsE (v: vector) (s: t) (i: int): (mulvs v s).[i] = v.[i] * s.
proof.
case (0 <= i < size v) => bound; 1: by rewrite offunvE.
by rewrite offunv0E // getv0E // mul0r.
qed.

lemma mulvs0 (v: vector): mulvs v zeror = zerov (size v).
proof.
rewrite eq_vectorP. 
split => [| i bound]; 1: rewrite size_mulvs /#.
by rewrite zerovE mulvsE mulr0.
qed.

lemma mulvs1 (v: vector): mulvs v oner = v.
proof.
rewrite eq_vectorP.
split => [| i bound]; 1: by rewrite size_mulvs.    
by rewrite mulvsE mulr1.
qed.

lemma dotp_mulvs (v1 v2: vector) (s1 s2: t):
    (dotp v1 v2) * (s1 * s2) = dotp (mulvs v1 s1) (mulvs v2 s2).
proof.
rewrite 2!dotpE 2!size_mulvs.
case (size v1 = size v2) => size_eq; last apply mul0r.
rewrite mulr_suml. 
apply eq_bigr => i _ /=.
rewrite 2!mulvsE.
smt(mulrA mulrC).
qed.

(* List-vector isomorphism *)
op oflist (s : R list): vector = offunv (nth witness s, size s).

lemma size_oflist l: size (oflist l) = size l.
proof. rewrite size_offunv; 1: smt(List.size_ge0). qed.

lemma oflistE  w (l: R list) i: 0 <= i < size l => (oflist l).[i] = nth w l i.
proof. by move => bound; rewrite offunvE // (nth_change_dfl w). qed.

op tolist (v : vector): R list = map (fun i => v.[i]) (range 0 (size v)).

lemma size_tolist v: size (tolist v) = size v.
proof. rewrite size_map size_range /#. qed.

lemma nth_tolist w v i: 0 <= i < size v => nth w (tolist v) i = v.[i].
proof.
move => bound; rewrite (nth_map witness w) 1:size_range; 1: smt(List.size_ge0).
by rewrite /= nth_range.
qed.

lemma oflistK: cancel oflist tolist.
proof.
move => l; apply (eq_from_nth witness); rewrite size_tolist size_oflist //.
by move => i bound; rewrite nth_tolist 1:size_oflist // (oflistE witness).
qed.

lemma tolistK: cancel tolist oflist.
proof.
move => l; apply eq_vectorP.
rewrite size_oflist size_tolist /= => i bound.
rewrite (oflistE witness) 1:size_tolist // nth_tolist //.
qed.

lemma oflist_inj: injective oflist.
proof. smt(oflistK). qed.

(* Distribution of length n vectors sampled using d element-wise *)
op dvector (d: R distr) (n: int) = dmap (dlist d (max 0 n)) oflist.

lemma size_dvector d n v: v \in dvector d n => size v = max 0 n. 
proof.
move => /supp_dmap[a [a_in ->]]; rewrite size_oflist.
rewrite supp_dlist /# in a_in.
qed.

lemma dvector0E (d: R distr) (v: vector) n: size v <> max 0 n => 
  mu1 (dvector d n) v = 0%r.
proof.
move => size_ineq; apply supportPn. 
rewrite -implybF => /size_dvector v_in.
by apply size_ineq.
qed.

lemma dvector1E (d : R distr) (v : vector) : mu1 (dvector d (size v)) v =
  BRM.bigi predT (fun i => mu1 d v.[i]) 0 (size v).
proof.
rewrite -{2}[v]tolistK dmapE /(\o) /pred1. 
rewrite (@mu_eq _ _ (pred1 (tolist v))); 1: smt(oflist_inj).
rewrite dlist1E 1:/# size_tolist max0size /=.
by rewrite BRM.big_mapT /(\o) &BRM.eq_big.
qed.

lemma mu1_dvector_split d i (v: vector): 0 <= i <= size v => 
  mu1 (dvector d i) (subv v 0 i) * 
  mu1 (dvector d (size v - i)) (subv v i (size v)) =
  mu1 (dvector d (size v)) v. 
proof.
move => i_bound; have last_size: size v - i = size (subv v i (size v)).
- rewrite size_subv /#.
have first_size: i = size (subv v 0 i) by rewrite size_subv /#.
rewrite last_size {1}first_size !dvector1E.
rewrite (BRM.big_cat_int i 0 (size v)) 3:2!size_subv; first 2 smt().
have ->: max 0 (size v - i) = size v - i by smt().
have ->: max 0 i = i by smt().
congr.
- apply BRM.eq_big_int => k cont /=. 
  by rewrite subvE.
- have ->: i = 0 + i by algebra.
  rewrite (BRM.big_addn 0) /=. 
  apply BRM.eq_big_int => k cont /=.
  by rewrite subvE. 
qed.

lemma dvector_uni d n: is_uniform d => is_uniform (dvector d n).
proof.
move => uni_d; apply dmap_uni; 1: apply/(can_inj _ tolist)/oflistK.
by apply dlist_uni.
qed.

lemma dvector_ll d n: is_lossless d => is_lossless (dvector d n).
proof. by move => ll_d; apply/dmap_ll/dlist_ll. qed.

lemma dvector_fu d (v: vector): is_full d => v \in dvector d (size v).
proof.
move=> full_d; rewrite supp_dmap.
exists (tolist v).
rewrite tolistK /= -size_tolist dlist_fu => x /#.
qed.

lemma mu1_dvector_fu (d: R distr) (v: vector): is_funiform d =>
    mu1 (dvector d (size v)) v = (mu1 d witness)^(size v).
proof.
rewrite dvector1E => d_funi.
have ->: (fun (i : int) => mu1 d v.[i]) = fun (_: int) => mu1 d witness.
- rewrite fun_ext => i. 
  apply d_funi.
have: 0 <= size v by exact size_ge0. 
move: (size v); elim/ge0ind => [/# | _ | n bound IH _].
- by rewrite range_geq // BRM.big_nil RField.expr0.
- by rewrite BRM.big_int_recr // RField.exprS // RField.mulrC IH.
qed.

end Vectors.

export Vectors.

(* -------------------------------------------------------------------------- *)
theory Matrices.
type matrix.

type prematrix = (int -> int -> R) * int * int.

op mclamp (pm: prematrix): prematrix =
  ((fun i j => if 0 <= i < pm.`2 /\ 0 <= j < pm.`3 then pm.`1 i j else zeror),
   max 0 pm.`2, max 0 pm.`3).

lemma nosmt mclamp_idemp pm: mclamp (mclamp pm) = mclamp pm.
proof. by rewrite /mclamp /#. qed.

hint simplify mclamp_idemp.

op eqv (pm1 pm2: prematrix) = mclamp pm1 = mclamp pm2.


clone import Quotient.EquivQuotient as QuotientMat with
  type T <- prematrix,
  type qT <- matrix,
  op eqv <- eqv
  proof EqvEquiv.* by smt().

op tofunm m = mclamp (repr m).

op offunm pm = pi (mclamp pm).

lemma tofunmK : cancel tofunm offunm.
proof. 
rewrite /tofunm /offunm /cancel => m /=. 
have ->: pi (mclamp (repr m)) = pi (repr m) by rewrite -eqv_pi /eqv.
apply reprK.
qed.

lemma offunmK pm: tofunm (offunm pm) = mclamp pm.
proof. by rewrite /tofunm /offunm eqv_repr. qed.

hint simplify offunmK.

lemma matrixW (P : matrix -> bool) : (forall pm, P (offunm pm)) =>
  forall m, P m by smt(tofunmK).

(* Number of rows and columns of matrices *)
op rows m = (tofunm m).`2.

op cols m = (tofunm m).`3.

abbrev size m = (rows m, cols m).

lemma nosmt rows_ge0 m: 0 <= rows m by smt().

lemma nosmt cols_ge0 m: 0 <= cols m by smt().

lemma rows_offunm f r c: rows (offunm (f, r, c)) = max 0 r by done. 

lemma cols_offunm f r c: cols (offunm (f, r, c)) = max 0 c by done.

lemma size_offunm f r c: size (offunm (f, r, c)) = (max 0 r, max 0 c) by done.

hint simplify rows_offunm, cols_offunm.

lemma nosmt max0rows m: max 0 (rows m) = rows m by smt().

lemma nosmt max0cols m: max 0 (cols m) = cols m by smt(). 

hint simplify max0rows, max0cols.

(* Getting the element at position i, j *)
op "_.[_]" (m : matrix) (ij : int * int) = (tofunm m).`1 ij.`1 ij.`2.

abbrev mrange m (i j : int) = 0 <= i < rows m /\ 0 <= j < cols m.

lemma offunmE f r c (i j : int) : mrange (offunm (f, r, c)) i j => 
  (offunm (f, r, c)).[i, j] = f i j.
proof. rewrite /("_.[_]") /= /mclamp /= /#. qed.

lemma nosmt getm0E (m : matrix) (i j : int) : !mrange m i j => m.[i, j] = zeror.
proof. by smt(). qed.

lemma offunm0E f r c (i j: int) : !(0 <= i < r /\ 0 <= j < c) =>
    (offunm (f, r, c)).[i, j] = zeror.
proof. move => idx_out. rewrite getm0E /#. qed.
    
lemma eq_matrixP (m1 m2 : matrix) : (m1 = m2) <=> 
  size m1 = size m2 /\ (forall i j, mrange m1 i j => m1.[i, j] = m2.[i, j]).
proof. 
split=> [-> // | @/"_.[_]" /= eq_mi]. 
have: tofunm m1 = tofunm m2 by rewrite /tofunm /mclamp /#. 
smt(tofunmK).
qed.

(* Special matrices *)

(* Constant valued matrix with r rows and c columns *)
op matrixc (rows cols: int) (c : R) = offunm ((fun _ _ => c), rows, cols).

lemma nosmt rows_matrixc cst r c: rows (matrixc r c cst) = max 0 r by done.

lemma nosmt cols_matrixc cst r c: cols (matrixc r c cst) = max 0 c by done.

hint simplify rows_matrixc, cols_matrixc.

lemma nosmt size_matrixc cst r c: size (matrixc r c cst) = (max 0 r, max 0 c).
proof. by done. qed.

lemma matrixcE cst c r i j: mrange (matrixc r c cst) i j => 
  (matrixc r c cst).[i, j] = cst. 
proof. move => bound. by apply offunmE. qed.

(* Matrix with the values of v on the diagonal and zeror off the diagonal *)
op diagmx (v : vector) =
  offunm ((fun i j => if i = j then v.[i] else zeror), size v, size v).

lemma rows_diagmx v: rows (diagmx v) = size v by rewrite /diagmx /#.

lemma cols_diagmx v: cols (diagmx v) = size v by rewrite /diagmx /#.

hint simplify rows_diagmx, cols_diagmx.

lemma size_diagmx v: size (diagmx v) = (size v, size v) by done.

lemma diagmxE v i j: (diagmx v).[i, j] = if i = j then v.[i] else zeror.
proof. 
case (mrange (diagmx v) i j) => /= [[i_bound j_bound] | not_bound].
- by rewrite offunmE.
rewrite getm0E //.
case (i = j) => [idx_eq | //].
rewrite getv0E /#.
qed.

hint simplify diagmxE.

(* Matrix with constant values on the diagonal *)
abbrev diagc n (c : R) = diagmx (vectc n c).

lemma diagcE n c i j: (diagc n c).[i, j] = if i = j /\ 0 <= i < n then c else zeror.
proof. 
case (i = j) => /= -> //=. 
case (0 <= j < n) => j_bound; 1: by rewrite vectcE.
apply getv0E => /= /#.
qed.

hint simplify diagcE.

(* n by n identity matrix *)
abbrev onem n = diagc n oner.

lemma offun1E i j n: mrange (onem n) i j => (onem n).[i, j] =
  if i = j then oner else zeror.
proof. 
rewrite diagcE => bound.
suff: (0 <= i < n) by move => ->.
rewrite rows_diagmx cols_diagmx /= in bound => /#.
qed.


lemma offun1_neqE i j n: i <> j => (onem n).[i, j] = zeror.
proof. move=> ne_ij. by rewrite diagmxE ne_ij. qed.

(* r by c zero matrix*)
abbrev zerom r c  = matrixc r c zeror.

lemma zeromE r c i j: (zerom r c).[i, j] = zeror. 
proof.
case (mrange (zerom r c) i j) => range; last by rewrite getm0E.
by rewrite matrixcE.
qed.

hint simplify zeromE.

(* 0 by 0 matrix also used as error state when there is a size mismatch *)
op emptym = zerom 0 0.

lemma rows_emptym: rows emptym = 0 by done.

lemma cols_emptym: cols emptym = 0 by done.

lemma size_emptym: size emptym = (0, 0) by done.

lemma emptymE i j: emptym.[i,j] = zeror by done.

hint simplify rows_emptym, cols_emptym, emptymE.

lemma emptym_unique m: size m = (0, 0) => m = emptym.
proof. 
move => [rows_m cols_m]. 
apply eq_matrixP => /=. 
rewrite rows_m cols_m /= => i j /#.
qed.

(* Matrix addition *)
op (+) (m1 m2 : matrix) = if size m1 = size m2 then 
  offunm (fun i j => m1.[i, j] + m2.[i, j], rows m1, cols m1) else emptym.

lemma size_addm_diff (m1 m2: matrix): size m1 <> size m2 => m1 + m2 = emptym.
proof. by smt(). qed.

lemma rows_addm (m1 m2: matrix): size m1 = size m2 => rows (m1 + m2) = rows m1.
proof. by rewrite /(+) => ->. qed.

lemma cols_addm (m1 m2: matrix): size m1 = size m2 => cols (m1 + m2) = cols m1.
proof. by rewrite /(+) => ->. qed.

lemma size_addm (m1 m2: matrix): size m1 = size m2 => size (m1 + m2) = size m1.
proof. move => size_eq; by rewrite 1:rows_addm 2:cols_addm. qed.

lemma add_emptyR (m: matrix): m + emptym = emptym.
proof. 
case (size m = size emptym) => size_eq; last by rewrite size_addm_diff.
apply emptym_unique.
by rewrite size_addm. 
qed.

lemma add_emptyL (m: matrix): emptym + m = emptym.
proof.
case (size m = size emptym) => size_eq. 
- apply emptym_unique.
  by rewrite size_addm eq_sym.
- apply size_addm_diff.
  by rewrite eq_sym.
qed.

hint simplify add_emptyR, add_emptyL.

lemma add_mrangeR (m1 m2: matrix) i j: mrange (m1 + m2) i j => mrange m2 i j.
proof.
case (size m1 = size m2) => size_eq; last rewrite size_addm_diff /#.
rewrite rows_addm // cols_addm /#.
qed.

lemma add_mrangeL (m2 m1: matrix) i j: mrange (m1 + m2) i j => mrange m1 i j.
proof.
case (size m1 = size m2) => size_eq; last rewrite size_addm_diff /#.
rewrite rows_addm // cols_addm /#.
qed.

lemma mrange_addm_size_eq i j (m1 m2: matrix): 
  mrange (m1 + m2) i j => size m1 = size m2.
proof. case (size m1 = size m2) => [// | sz_nq]. rewrite size_addm_diff /#. qed.

lemma getmD (m1 m2 : matrix) i j : size m1 = size m2 =>
  (m1 + m2).[i, j] = m1.[i, j] + m2.[i, j].
proof.
move => [rows_eq cols_eq]; case: (mrange m1 i j) => rg_i. 
- by rewrite /(+) -rows_eq -cols_eq /= offunmE.
- rewrite !getm0E; first 3 smt(rows_addm cols_addm). 
  by rewrite addr0.
qed.


(* Matrix additive inverse *)
op [-] (m: matrix) = offunm (fun i j => -m.[i, j], rows m, cols m).

lemma rows_neg (m: matrix): rows (-m) = rows m by done.

lemma cols_neg (m: matrix): cols (-m) = cols m by done.

hint simplify rows_neg, cols_neg.

lemma size_neg (m: matrix): size (-m) = size m by done.

lemma getvN (m : matrix) i j : (-m).[i, j] = - m.[i, j].
proof.
case: (mrange m i j) => rg_i; 1: by rewrite offunmE.
by rewrite getm0E // getm0E // oppr0.
qed.

hint simplify getvN.

lemma emptymN: -emptym = emptym by apply emptym_unique.

hint simplify emptymN.

(* Module like properties of matrices *)
lemma addmA: associative Matrices.( + ).
proof. 
move => m1 m2 m3; apply eq_matrixP.
split => [| i j bound].
- case (size m1 = size m2); last smt(size_addm add_emptyR size_addm_diff).
  case (size m2 = size m3); smt(size_addm add_emptyR size_addm_diff).
have size_eq0: size m2 = size m3.
- apply add_mrangeR in bound. 
  by apply mrange_addm_size_eq in bound.
have size_eq2: size m1 = size m2.
- apply mrange_addm_size_eq in bound.
  rewrite bound.
  by apply size_addm.
rewrite !getmD; first 4 smt(size_addm).
apply addrA.
qed.

lemma addmC: commutative Matrices.( + ).
proof.
move => m1 m2.
apply eq_matrixP. 
case (size m1 = size m2) => size_eq; last smt(size_addm_diff).
split => [| i j]; 1: smt(size_addm).
rewrite rows_addm 1:// cols_addm 1://.
by move => bound; rewrite getmD 1:// getmD 1:eq_sym 2:addrC.
qed.

lemma add0m m: zerom (rows m) (cols m) + m = m.
proof.
apply eq_matrixP.
rewrite size_addm /= 1://.
move => i j bound; rewrite getmD //=.
apply add0r.
qed.

abbrev (-) (m1 m2: matrix) = m1 + (-m2).

lemma addNm (m: matrix) : m - m = zerom (rows m) (cols m).
proof.
apply eq_matrixP. 
split => [| i j bound]; 1: by rewrite size_addm.
by rewrite getmD //= addrN.
qed.

lemma oppmD (m1 m2: matrix): -(m1 + m2) = -m1 + -m2.
proof.
case (size m1 = size m2) => eq_size; last by rewrite !size_addm_diff.
rewrite eq_matrixP; split => [| i j bound].
- rewrite size_neg size_addm 1:// rows_addm; 1: by rewrite size_neg eq_size.
  rewrite cols_addm; 1: by rewrite size_neg eq_size.
  by rewrite rows_neg cols_neg.
- rewrite getvN getmD 1:eq_size 1://.
  rewrite getmD; 1: by rewrite 2!size_neg eq_size.
  by rewrite opprD !getvN.
qed.

lemma oppmK (m: matrix): - (- m) = m.
proof.
rewrite eq_matrixP. 
split => [| i j bound]; 1: by rewrite !size_neg.
- by rewrite !getvN opprK.
qed.

(* matrix transposition *)
op trmx (m : matrix) = offunm (fun i j => m.[j, i], cols m, rows m).

lemma rows_tr m: rows (trmx m) = cols m by done.

lemma cols_tr m: cols (trmx m) = rows m by done.

hint simplify rows_tr, cols_tr.

lemma size_tr m: size (trmx m) = (cols m, rows m) by done.

lemma trmxE (m : matrix) i j : (trmx m).[i, j] = m.[j, i].
proof. 
case: (mrange m j i) => bound. 
- rewrite offunmE /#.
- rewrite getm0E /#.
qed.

hint simplify trmxE.

lemma trmxK: involutive trmx.
proof.
move => m. 
by apply eq_matrixP.
qed.

lemma trmx_inj: injective trmx by apply inv_inj; apply trmxK.

lemma trmxD (m1 m2 : matrix) : trmx (m1 + m2) = trmx m1 + trmx m2.
proof.
case (size m1 = size m2) => size_eq.
- apply eq_matrixP. 
  split => [/= | i j bound]; 1: smt(rows_addm cols_addm cols_tr rows_tr).
  rewrite trmxE !getmD /#. 
- rewrite size_addm_diff // eq_sym. 
  apply emptym_unique.
  rewrite size_addm_diff /#.
qed.

hint simplify trmxD.

lemma trmxN (m: matrix): trmx (-m) = - trmx m by apply eq_matrixP.

hint simplify trmxN.

lemma trmx_empty: trmx emptym = emptym by apply emptym_unique.

lemma trmx1 n: trmx (onem n) = (onem n).
proof.
apply eq_matrixP => i j bound /= /#. 
qed.

hint simplify trmx1, trmx_empty.

lemma trmx_matrixc c n m: trmx (matrixc n m c) = matrixc m n c.
proof.
rewrite eq_matrixP /= => i j bound. 
rewrite !matrixcE /#.
qed.

hint simplify trmx_matrixc.

(* Gets the n-th row of m as a vector *)
op row m n = offunv (fun i => m.[n, i], cols m).

lemma size_row m i: size (row m i) = cols m by done.

lemma rowE m i j: (row m i).[j] = m.[i, j].
proof.
case (0 <= j < cols m) => bound; 1: by apply offunvE.
rewrite getv0E // getm0E /#.
qed.

hint simplify size_row, rowE.

lemma row0E m i: !(0 <= i < rows m) => row m i = zerov (cols m). 
proof. move => n_bound; rewrite eq_vectorP => j bd /=. rewrite getm0E /#. qed.

lemma rowD m1 m2 n: size m1 = size m2 => 
  (row (m1 + m2) n) = row m1 n + row m2 n.
proof. 
move => size_eq; rewrite eq_vectorP /=. 
rewrite cols_addm 1:// size_addv /=.
have ->: cols m1 = cols m2 by elim size_eq.
move => i bound; rewrite getmD // getvD /#.
qed.

lemma row_matrixc m n c i: 0 <= i < m => row (matrixc m n c) i = vectc n c.
proof.
move => i_bound; apply eq_vectorP => /= j j_bound.
rewrite vectcE 1:/# matrixcE /#.
qed.

(* Gets the n-th column of m as a vector *)
op col m n = offunv (fun i => m.[i, n], rows m).

lemma size_col m n: size (col m n) = rows m by done.

lemma colE m i j: (col m j).[i] = m.[i, j].
proof.
case (0 <= i < rows m) => bound; 1: by apply offunvE.
rewrite getv0E // getm0E /#.
qed.

hint simplify size_col, colE.

lemma row_trmx m n: row (trmx m) n = col m n by rewrite eq_vectorP.

lemma col_trmx m n: col (trmx m) n = row m n by rewrite eq_vectorP.

hint simplify row_trmx, col_trmx.

lemma col0E m n: !(0 <= n < cols m) => col m n = zerov (rows m).
proof.
rewrite -trmxK cols_tr col_trmx => bound. 
rewrite rows_tr. 
by apply row0E.
qed.

lemma colD m1 m2 i: size m1 = size m2 => 
  (col (m1 + m2) i) = col m1 i + col m2 i.
proof. 
rewrite -(trmxK (m1 + m2)) -{4}(trmxK m1) -{4}(trmxK m2) => bound.
rewrite !col_trmx trmxD rowD /#.
qed.

lemma col_matrixc m n c i: 0 <= i < n => col (matrixc m n c) i = vectc m c.
proof.
move => bound; rewrite -(trmxK (matrixc _ _ _)) col_trmx /=. 
by apply row_matrixc.
qed.

(* Matrix multiplication *)
op ( * ) (m1 m2 : matrix) = if cols m1 = rows m2 then
  offunm (fun i j => dotp (row m1 i) (col m2 j), rows m1, cols m2) else 
  emptym.

lemma rows_mulmx m1 m2: cols m1 = rows m2 => rows (m1 * m2) = rows m1.
proof. move => cols_eq; by rewrite /( * ) cols_eq. qed.

lemma cols_mulmx m1 m2: cols m1 = rows m2 => cols (m1 * m2) = cols m2.
proof. move => cols_eq; by rewrite /( * ) cols_eq. qed.

lemma size_mulmx m1 m2: cols m1 = rows m2 => 
  size (m1 * m2) = (rows m1, cols m2).
proof. move => cols_eq; by rewrite rows_mulmx // cols_mulmx. qed.

lemma size_mulmx_diff m1 m2: cols m1 <> rows m2 => m1 * m2 = emptym.
proof. by rewrite /( * ) /#. qed.

lemma mulmxE m1 m2 i j: (m1 * m2).[i,j] = dotp (row m1 i) (col m2 j).
proof.
case (cols m1 = rows m2) => cols_eq.
- case (mrange (m1 * m2) i j) => /=.
  + rewrite rows_mulmx 1:// cols_mulmx 1:// => bound. 
    by rewrite /( * ) cols_eq /= offunmE.
  + move => bound.
    rewrite getm0E 1://.
    rewrite andaE negb_and rows_mulmx 1:// cols_mulmx 1:// in bound.
    elim bound => boundN.
    * suff: row m1 i = zerov (cols m1) by move => ->. 
      rewrite row0E /#.
    * suff: col m2 j = zerov (rows m2) by move => ->. 
      rewrite col0E /#.
- rewrite getm0E 1:size_mulmx_diff 3:dotpE /#.
qed.

lemma mulmx_emptym: emptym * emptym = emptym by apply/emptym_unique/size_mulmx.

hint simplify mulmx_emptym.

lemma trmxM (m1 m2 : matrix) : trmx (m1 * m2) = trmx m2 * trmx m1.
proof.
case (cols m1 = rows m2) => cols_eq; last by rewrite !size_mulmx_diff /#.
apply eq_matrixP.
rewrite size_mulmx /= 1:/# cols_mulmx 1:// rows_mulmx 1:// /= => i j bound.
by rewrite !mulmxE dotpC.
qed.

hint simplify trmxM.

lemma mulmxDl (m1 m2 m : matrix) :
  size m1 = size m2 => (m1 + m2) * m = (m1 * m) + (m2 * m).
proof.
case (cols m1 = rows m) => cols_eq => size_eq_add.
- apply eq_matrixP. 
  split => [| i j bound]; 1: smt(cols_addm rows_addm size_mulmx).
  rewrite getmD /=; 1: smt(cols_addm rows_addm cols_mulmx rows_mulmx).
  rewrite 3!mulmxE rowD 1:// dotpDl /#.
- rewrite !size_mulmx_diff; smt(cols_addm rows_addm cols_mulmx rows_mulmx).
qed.

lemma mulmxDr (m1 m2 m : matrix) :
  size m1 = size m2 => m * (m1 + m2) = (m * m1) + (m * m2).
proof. move => bound; apply trmx_inj => /=. apply mulmxDl => /#. qed.

lemma mulmxA m1 m2 m3: cols m1 = rows m2 => cols m2 = rows m3 => 
  m1 * (m2 * m3) = m1 * m2 * m3.
proof.
move => cols_eq0 cols_eq1; apply eq_matrixP. 
split => [| i j bound]; 1: smt(rows_mulmx cols_mulmx).
rewrite !mulmxE !dotpE /=.
have -> /=: cols m1 = rows (m2 * m3) by smt(rows_mulmx cols_mulmx).
have -> /=: cols (m1 * m2) = rows m3 by smt(rows_mulmx cols_mulmx).
have ->: (fun (i0 : int) => m1.[i, i0] * (m2 * m3).[i0, j]) = 
         (fun (i0 : int) => bigi predT (fun (j0 : int) => 
              m1.[i, i0] * (m2.[i0,j0] * m3.[j0,j])) 0 (rows m3)).
- apply fun_ext => /= k.
  rewrite mulmxE /dotp /= cols_eq1 /= mulr_sumr.
  by apply eq_bigr.
have ->: (fun (i0 : int) => (m1 * m2).[i,i0] * m3.[i0,j]) = 
         (fun (i0 : int) => bigi predT 
          (fun (j0 : int) => m1.[i,j0] * (m2.[j0,i0] * m3.[i0,j])) 0 (rows m2)).
- apply fun_ext => /= k.
  rewrite mulmxE /dotp /= cols_eq0 /= mulr_suml.
  apply eq_bigr => l /= _.
  by rewrite mulrA.
- by rewrite exchange_big rows_mulmx.
qed.

lemma mulmxm0 n m: m * zerom (cols m) n = zerom (rows m) n.
proof.
rewrite eq_matrixP /= rows_mulmx 1:// cols_mulmx 1:// => i j /= bound.
by rewrite mulmxE /= col_matrixc 1:/# dotpr0.
qed.

lemma mul0m n m: zerom n (rows m) * m = zerom n (cols m).
proof. apply trmx_inj => /=. apply mulmxm0. qed.

lemma mulmx1 m: m * onem (cols m) = m.
proof.
apply eq_matrixP. 
rewrite size_mulmx 1:// /= => i j bound.
rewrite rows_mulmx // cols_mulmx //= in bound.
rewrite mulmxE dotpE (bigD1 _ _ j) 1:mem_range 1:/# 1:range_uniq.
rewrite big1 /= => [k |]; last by rewrite vectcE 1:/# mulr1 addr0.
rewrite /predC1 => -> /=. 
by rewrite mulr0.
qed.

lemma mul1mx m: onem (rows m) * m = m by apply trmx_inj => /=; apply mulmx1.

(* Turns row vector into matrix *)
op rowmx (v: vector) = offunm ((fun _ i => v.[i]), 1, size v).

lemma rows_rowmx v: rows (rowmx v) = 1 by done.

lemma cols_rowmx v: cols (rowmx v) = size v by done.

hint simplify rows_rowmx, cols_rowmx.

lemma size_rowmx v: size (rowmx v) = (1, size v) by done.

lemma rowmxE v i: (rowmx v).[0,i] = v.[i].
proof.
case (0 <= i < size v) => bound.
- rewrite offunmE //= /#. 
- by rewrite getm0E //= getv0E.
qed.

hint simplify rowmxE.

lemma rowK v: row (rowmx v) 0 = v by rewrite eq_vectorP.

hint simplify rowK.

lemma rowmx_row m: rows m = 1 => rowmx (row m 0) = m.
proof.
move => rws; rewrite eq_matrixP /= rws => i j bound.
case (i = 0) => [->//| i_neq0].
rewrite !getm0E /#.
qed.

lemma rowmxD (v1 v2: vector): size v1 = size v2 => 
    rowmx (v1 + v2) = rowmx v1 + rowmx v2.
proof.
move => size_eq.
rewrite -(rowmx_row (rowmx (v1 + v2))) 1://. 
by rewrite -(rowmx_row (rowmx v1 + rowmx v2)) 1:rows_addm 3:rowD.
qed.

lemma rowmxc n c: rowmx (vectc n c) = matrixc 1 n c.
proof.
apply eq_matrixP => /= i j bound. 
case (i = 0) => [->/=|i_neq0 /#].
rewrite matrixcE /= 1:/# vectcE /#.
qed.

hint simplify rowmxc.

(* turns column vector into matrix *)
op colmx (v: vector) = offunm ((fun i _ => v.[i]), size v, 1).

lemma rows_colmx v: rows (colmx v) = size v by done.

lemma cols_colmx v: cols (colmx v) = 1 by done.

hint simplify rows_colmx, cols_colmx.

lemma size_colmx v: size (colmx v) = (size v, 1) by done.

lemma colmxE v i: (colmx v).[i,0] = v.[i].
proof.
case (0 <= i < size v) => bound; first rewrite offunmE //= /#.
by rewrite getm0E //= getv0E.
qed.

hint simplify colmxE.

lemma colK v: col (colmx v) 0 = v by rewrite eq_vectorP.

hint simplify colK.

lemma colmx_col m: cols m = 1 => colmx (col m 0) = m.
proof.
move => cls; rewrite eq_matrixP /= cls => i j bound.
case (j = 0) => [->// | /#].
qed.

lemma trmx_rowmx v: trmx (rowmx v) = colmx v.
proof.
rewrite eq_matrixP /= => i j bound.
case (j = 0) => [->// | /#].
qed.

hint simplify trmx_rowmx.

lemma trmx_colmx v: trmx (colmx v) = rowmx v.
proof. by apply trmx_inj => /=; rewrite trmxK. qed.

hint simplify trmx_colmx.

lemma rowmx_col m: cols m = 1 => rowmx (col m 0) = trmx m.
proof. move => rws; apply trmx_inj => /=. by rewrite trmxK colmx_col. qed.

lemma colmx_row m: rows m = 1 => colmx (row m 0) = trmx m.
proof. move => rws; apply trmx_inj => /=. by rewrite trmxK rowmx_row. qed.

lemma colmxD (v1 v2: vector): size v1 = size v2 => 
    colmx (v1 + v2) = colmx v1 + colmx v2.
proof. move => size_eq; apply trmx_inj => /=. exact rowmxD. qed.

lemma colmxc n c: colmx (vectc n c) = matrixc n 1 c by apply trmx_inj.

hint simplify colmxc.

(* Matrix and vector multiplication *)
abbrev ( *^ ) (m : matrix) (v : vector) : vector = col (m * colmx v) 0.

lemma size_mulmxv m (v: vector): cols m = size v => size (m *^ v) = rows m.
proof. by move => cols_eq; rewrite /= rows_mulmx. qed.

lemma mulmxvE m v i: (m *^ v).[i] = dotp (row m i) v by rewrite /= mulmxE.

lemma colmx_mulmxv (m : matrix) (v : vector) : 
  cols m = size v => colmx (m *^ v) = m * colmx v.
proof. by move => cols_eq; rewrite colmx_col 2:// cols_mulmx. qed.

lemma mulmxvDl (m1 m2 : matrix) (v : vector) :
 size m1 = size m2 =>
  (m1 + m2) *^ v = m1 *^ v + m2 *^ v.
proof. move => sz_eq; rewrite -colD 2:mulmxDl; smt(size_mulmx size_colmx). qed.

lemma mulmxvDr (m : matrix) (v1 v2 : vector) :
  size v1 = size v2 => m *^ (v1 + v2) = m *^ v1 + m *^ v2.
proof.
move => size_eq; rewrite -colD; 1: smt(size_mulmx size_colmx).
by rewrite colmxD 1:// mulmxDr.
qed.

lemma mulmxvA (m1 m2 : matrix) (v : vector) :
  cols m1 = rows m2 => cols m2 = size v => m1 *^ (m2 *^ v) = (m1 * m2) *^ v.
proof. move => cols_eq cols_eq1; by rewrite colmx_mulmxv 1:// mulmxA. qed.

lemma mulmxv0 (m : matrix) : m *^ (zerov (cols m)) = zerov (rows m).
proof. by rewrite colmxc /= mulmxm0 col_matrixc. qed.

lemma mulmx1v (v : vector): onem (size v) *^ v = v.
proof.
rewrite -{3}colK.
congr.
have ->: size v = rows (colmx v) by done.
by rewrite mul1mx.
qed.

(* Vector and matrix multiplication *)
abbrev ( ^* ) (v : vector) (m : matrix) : vector = row (rowmx v * m) 0.

lemma size_mulvmx (v: vector) m: size v = rows m => size (v ^* m) = cols m.
proof. move => size_eq; by rewrite /= cols_mulmx. qed.

lemma mulvmxE v m i: (v ^* m).[i] = dotp v (col m i) by rewrite /= mulmxE.

lemma mulmxTv (m : matrix) (v : vector) : (trmx m) *^ v = v ^* m.
proof. by rewrite -col_trmx trmxM. qed.

hint simplify mulmxTv.

lemma mulvmxT (v : vector) (m : matrix) : v ^* (trmx m) = m *^ v.
proof. by rewrite -{2}(trmxK m) /#. qed.

hint simplify mulvmxT.

lemma mulvmxDr (v : vector) (m1 m2 : matrix) :
  size m1 = size m2 => v ^* (m1 + m2) = v ^* m1 + v ^* m2.
proof. move => size_eq; rewrite -mulmxTv trmxD mulmxvDl /#. qed.

lemma mulvmxDl (v1 v2 : vector) (m : matrix) :
  size v1 = size v2 => (v1 + v2) ^* m = v1 ^* m + v2 ^* m.
proof. move => size_eq; by rewrite -mulmxTv mulmxvDr. qed.

lemma mulvmxA (v : vector) (m1 m2 : matrix) :
  cols m1 = rows m2 => size v = rows m1 => v ^* (m1 * m2) = (v ^* m1) ^* m2.
proof. move => s1 s2; rewrite -(trmxK (m1 * m2)) trmxM mulvmxT -mulmxvA /#. qed.

lemma mulv0mx (m : matrix): zerov (rows m) ^* m = zerov (cols m).
proof. by rewrite -mulmxTv -{2}trmxK rows_tr mulmxv0 -cols_tr trmxK. qed.

lemma rowmx_mulvmx (v : vector) (m : matrix) : 
  rows m = size v => rowmx (v ^* m) = rowmx v * m.
proof. 
by move => rows_eq; rewrite -trmx_colmx -mulmxTv colmx_mulmxv 1:// trmxM trmxK. 
qed.

lemma mulvmx1 (v : vector) : v ^* onem (size v) = v.
proof. by rewrite -mulmxTv trmx1 mulmx1v. qed.

lemma dotp_eqv_mul v1 v2 : dotp v1 v2 = (rowmx v1 * colmx v2).[0,0].
proof.
case (size v1 = size v2) => [size_eq | size_neq]; 1: by rewrite mulmxE.
rewrite size_mulmx_diff /= 1:// dotpE /#.
qed.

lemma dotp_mulmxv m (v1 v2: vector) : rows m = size v1 => cols m = size v2 =>
  dotp v1 (m *^ v2) = dotp (v1 ^* m) v2.
proof.
move => cols_eq rows_eq; rewrite 2!dotp_eqv_mul.
congr.
rewrite colmx_col; first rewrite cols_mulmx /#.
rewrite rowmx_row; first rewrite rows_mulmx /#.
apply mulmxA => /#.
qed.

(* Sideways matrix concatenation *)
op ( || ) (m1 m2: matrix) = if rows m1 = rows m2 then
  offunm ((fun i j => m1.[i, j] + m2.[i, j-cols m1]), 
          rows m1, cols m1 + cols m2) else 
  emptym.

lemma rows_concat_side (m1 m2: matrix): 
  rows m1 = rows m2 => rows (m1 || m2) = rows m1.
proof. by rewrite /(||) => ->. qed.

lemma cols_concat_side (m1 m2: matrix): rows m1 = rows m2 =>
  cols (m1 || m2) = cols m1 + cols m2.
proof. rewrite /(||) => -> /= /#. qed.

lemma size_concat_side (m1 m2: matrix): rows m1 = rows m2 => 
  size (m1 || m2) = (rows m1, cols m1 + cols m2).
proof. rewrite /(||) => -> /= /#. qed.

lemma concat_sideE (m1 m2: matrix) i j: rows m1 = rows m2 =>
  (m1 || m2).[i, j] = m1.[i, j] + m2.[i, j-cols m1].
proof.
rewrite /(||) => rows_eq. 
rewrite rows_eq /=.
case (mrange (m1 || m2) i j) => range.
- rewrite offunmE /=; smt(cols_concat_side rows_concat_side).
- rewrite !getm0E /=; first 3 smt(cols_concat_side rows_concat_side).
  by rewrite addr0.
qed.

lemma concat_side_diff m1 m2: rows m1 <> rows m2 => (m1 || m2) = emptym.
proof. by smt(). qed.

lemma col_concat_sideL m1 m2 i: rows m1 = rows m2 => i < cols m1 =>
  col (m1 || m2) i = col m1 i.
proof.
move => rows_eq bound1; rewrite eq_vectorP /=. 
split => [| j bound2]; 1: by rewrite rows_concat_side.
rewrite concat_sideE // (getm0E m2) 2:addr0; smt(rows_concat_side).
qed.

lemma col_concat_sideR m1 m2 i: rows m1 = rows m2 => cols m1 <= i =>
  col (m1 || m2) i = col m2 (i - cols m1).
proof.
move => rows_eq bound; rewrite eq_vectorP /=. 
split => [| j bound2]; 1: by rewrite rows_concat_side.
rewrite concat_sideE // (getm0E m1) 2:add0r; smt(rows_concat_side).
qed.

lemma row_concat_side m1 m2 i: rows m1 = rows m2 =>
  row (m1 || m2) i = (row m1 i || row m2 i).
proof.
move => rows_eq; rewrite eq_vectorP /=. 
rewrite cols_concat_side // size_concat /= => j bound.
by rewrite concat_sideE // concatE.
qed.

lemma concat_side_empty: (emptym || emptym) = emptym.
proof. apply emptym_unique. smt(size_concat_side size_emptym). qed.

hint simplify concat_side_empty.

lemma concat_sideA (m1 m2 m3: matrix): rows m1 = rows m2 => rows m2 = rows m3 =>
  ((m1 || m2) || m3) = (m1 || (m2 || m3)).
proof. 
move => rows_eq0 rows_eq1; rewrite eq_matrixP. 
split => [| i j bound]; 1: smt(rows_concat_side cols_concat_side).
rewrite !concat_sideE; first 4 smt(rows_concat_side).
rewrite cols_concat_side // addrA. 
algebra.
qed.

lemma concatDr (m1 m2 m3: matrix): rows m2 = rows m3 =>
  m1 * (m2 || m3) = ((m1 * m2) || (m1 * m3)).
proof.
move => rows_eq; case (cols m1 = rows m2) => cols_eq.
- rewrite eq_matrixP.
  split => [| i j bound].
  + smt(rows_mulmx cols_mulmx rows_concat_side cols_concat_side).
  rewrite concat_sideE 2:!mulmxE; 1:smt(rows_mulmx).
  case (j < cols m2) => bound2.
  + rewrite col_concat_sideL // (col0E m3); 1: smt(cols_mulmx).
    by rewrite dotpr0 addr0.
  + rewrite col_concat_sideR 1:/# 1:/# (col0E m2) 1:/# dotpr0 add0r.
    smt(cols_mulmx).
- by rewrite !size_mulmx_diff // 2:/# rows_concat_side.
qed.

lemma rowmx_concat (v1 v2: vector): rowmx (v1 || v2) = (rowmx v1 || rowmx v2).
proof.
apply eq_matrixP.
rewrite size_concat_side 1:rows_rowmx 1://.
rewrite !rows_rowmx !cols_rowmx size_concat /= => i j bound.
rewrite concat_sideE //. 
have ->: (i = 0) by smt().
by rewrite !rowmxE concatE cols_rowmx. 
qed.

lemma concat_side_addm (m1 m2 m3 m4: matrix): 
  size m1 = size m3 => size m2 = size m4 =>
  (m1 || m2) + (m3 || m4) = ((m1 + m3) || (m2 + m4)).
proof.
move => size_eq1 size_eq2; case (rows m1 = rows m2) => rows_eq1.
- rewrite eq_matrixP. 
  split => [| i j bound]. 
  + smt(rows_concat_side cols_concat_side rows_addm cols_addm).
  rewrite getmD; 1: smt(rows_concat_side cols_concat_side).
  rewrite !concat_sideE; first 3 smt(rows_addm cols_addm).
  rewrite !getmD // cols_addm //; smt(addrA addrC).
- rewrite !concat_side_diff /=; smt(rows_addm).
qed.

lemma negv_concat_side (m1 m2: matrix): 
  rows m1 = rows m2 => - (m1 || m2) = (-m1 || -m2).
proof.
move => rows_eq.
apply eq_matrixP => /=.
split => [| i j bound].
- rewrite !rows_concat_side // !cols_concat_side /#.
- by rewrite !concat_sideE // /= opprD. 
qed.

(* Downwards matrix concatenation *)
op ( / ) (m1 m2: matrix) = if cols m1 = cols m2 then 
  offunm ((fun i j => m1.[i, j] + m2.[i-rows m1, j]), 
          rows m1 + rows m2, cols m1) else 
  emptym.

lemma cols_concat_down (m1 m2: matrix): 
  cols m1 = cols m2 => cols (m1 / m2) = cols m1.
proof. by rewrite /(/) => ->. qed.

lemma rows_concat_down (m1 m2: matrix): cols m1 = cols m2 =>
  rows (m1 / m2) = rows m1 + rows m2.
proof. rewrite /(/) => -> /= /#. qed.

lemma size_concat_down (m1 m2: matrix): cols m1 = cols m2 => 
  size (m1 / m2) = (rows m1 + rows m2, cols m1).
proof. move => cols_eq; by rewrite cols_concat_down // rows_concat_down. qed.

lemma concat_downE (m1 m2: matrix) i j: cols m1 = cols m2 =>
  (m1 / m2).[i, j] = m1.[i, j] + m2.[i-rows m1, j].
proof.
rewrite /(/) => cols_eq. 
rewrite cols_eq /=.
case (mrange (m1 / m2) i j) => range.
- rewrite offunmE /=; smt(cols_concat_down rows_concat_down).
- rewrite !getm0E /= 4:addr0; smt(cols_concat_down rows_concat_down).
qed.

lemma concat_down_diff m1 m2: cols m1 <> cols m2 => (m1 / m2) = emptym by smt().

lemma concat_downT (m1 m2: matrix): trmx (m1 / m2) = (trmx m1 || trmx m2).
proof.
case (cols m1 = cols m2) => cols_eq.
- rewrite eq_matrixP /=.
  split => [| i j bound]. 
  + smt(size_tr size_concat_down size_concat_side).
  + by rewrite concat_downE // concat_sideE.
- by rewrite concat_side_diff // concat_down_diff.
qed.

hint simplify concat_downT.

lemma concat_sideT (m1 m2: matrix): trmx (m1 || m2) = trmx m1 / trmx m2.
proof. apply trmx_inj. by rewrite /= 3!trmxK. qed.

hint simplify concat_sideT.

lemma row_concat_downL m1 m2 i: 
  cols m1 = cols m2 => i < rows m1 => row (m1 / m2) i = row m1 i.
proof. move => cols_eq bound; by rewrite -col_trmx /= col_concat_sideL. qed.

lemma row_concat_downR m1 m2 i: cols m1 = cols m2 => rows m1 <= i =>
  row (m1 / m2) i = row m2 (i - rows m1).
proof. move => cols_eq bound; by rewrite -col_trmx /= col_concat_sideR. qed.

lemma col_concat_down m1 m2 i: cols m1 = cols m2 =>
  col (m1 / m2) i = (col m1 i || col m2 i).
proof. move => rows_eq; by rewrite -row_trmx /= row_concat_side. qed.

lemma concat_down_empty: (emptym || emptym) = emptym.
proof. apply emptym_unique. smt(size_emptym size_concat_down). qed.

hint simplify concat_down_empty.

lemma concat_downA (m1 m2 m3: matrix): 
  cols m1 = cols m2 => cols m2 = cols m3 => ((m1 / m2) / m3) = (m1 / (m2 / m3)).
proof. move => cols_eq0 cols_eq1; apply trmx_inj => /=. exact concat_sideA. qed.

lemma concatDl m1 m2 m3: cols m1 = cols m2 => 
  (m1 / m2) * m3 = (m1 * m3) / (m2 * m3).
proof. move => cols_eq; apply trmx_inj => /=. exact concatDr. qed.

lemma colmx_concat (v1 v2: vector): colmx (v1 || v2) = (colmx v1 / colmx v2).
proof. apply trmx_inj => /=. exact rowmx_concat. qed.

lemma concat_down_addm (m1 m2 m3 m4: matrix): 
  size m1 = size m3 => size m2 = size m4 =>
  (m1 / m2) + (m3 / m4) = ((m1 + m3) / (m2 + m4)).
proof.
move => size_eq1 size_eq2; apply trmx_inj => /=. 
rewrite concat_side_addm /#.
qed.

lemma negv_concat_down (m1 m2: matrix): 
  cols m1 = cols m2 => - (m1 / m2) = ((-m1) / -m2).
proof. move => cols_eq; apply trmx_inj => /=. by apply negv_concat_side. qed.


(* Taking a matrix from inside a matrix *)
op subm (m: matrix) (a b c d: int) = 
  offunm ((fun i j => m.[i+a,j+c]), b-a, d-c).

lemma rows_subm m a b c d: rows (subm m a b c d) = max 0 (b - a) by done.

lemma cols_subm m a b c d: cols (subm m a b c d) = max 0 (d - c) by done.

hint simplify rows_subm, cols_subm.

lemma size_subm m a b c d: 
   size (subm m a b c d) = (max 0 (b - a), max 0 (d - c)) by done.

lemma submE (m: matrix) (a b c d i j: int): 0 <= i < b - a => 0 <= j < d -c => 
  (subm m a b c d).[i,j] = m.[i+a,j+c].
proof. move => i_range j_range; rewrite /subm offunmE /#. qed.

lemma subm_id m: subm m 0 (rows m) 0 (cols m) = m.
proof. rewrite eq_matrixP /= => i j bound. rewrite submE /#. qed.

lemma submT m a b c d: trmx (subm m a b c d) = subm (trmx m) c d a b.
proof.
apply eq_matrixP => i j bound /=. 
rewrite !submE; smt(size_tr size_subm).
qed.

hint simplify submT.

lemma subm_concat_sideCl m1 m2: rows m1 = rows m2 => 
  subm (m1 || m2) 0 (rows m1) 0 (cols m1) = m1.
proof.
rewrite eq_matrixP => rows_eq i j bound.
rewrite submE; first 2 smt(size_subm).
rewrite concat_sideE // (getm0E m2) /= 2:addr0; smt(cols_subm). 
qed.

lemma subm_concat_downCl m1 m2: cols m1 = cols m2 => 
  subm (m1 / m2) 0 (rows m1) 0 (cols m1) = m1.
proof. move => cols_eq; apply trmx_inj => /=. exact subm_concat_sideCl. qed.

lemma subm_concat_sideCr m1 m2: rows m1 = rows m2 => 
  subm (m1 || m2) 0 (rows m1) (cols m1) (cols m1 + cols m2) = m2.
proof.
rewrite eq_matrixP => rows_eq. 
split => [/# | i j bound].
rewrite submE; first 2 smt(size_subm).
rewrite concat_sideE //= (getm0E m1) /= 2:add0r; smt(cols_subm).
qed.

lemma subm_concat_botCr m1 m2: cols m1 = cols m2 => 
  subm (m1 / m2) (rows m1) (rows m1 + rows m2) 0 (cols m1) = m2.
proof. move => cols_eq; apply trmx_inj => /=. exact subm_concat_sideCr. qed.

lemma rowmx_row_eq_subm r m: rowmx (row m r) = subm m r (r+1) 0 (cols m).
proof.
rewrite eq_matrixP /=. 
split => [/# | i j bound]. 
have ->: i = 0 by smt().
rewrite rowmxE submE 3:rowE /#.
qed.

lemma colmx_col_eq_subm c m: colmx (col m c) = subm m 0 (rows m) c (c+1).
proof.
apply trmx_inj => /=. 
rewrite -row_trmx.
apply rowmx_row_eq_subm.
qed.

lemma concat_side_subm m n: 0 <= n < cols m => 
  (subm m 0 (rows m) 0 n || subm m 0 (rows m) n (cols m)) = m.
proof.
move => n_bound; rewrite eq_matrixP /=.
split => [| i j bound]. 
- smt(size_concat_side cols_concat_side size_subm).
rewrite concat_sideE // cols_subm /=.
case (j < n) => j_bound.
- rewrite submE /=; first 2 smt(size_concat_side size_subm).
  rewrite (getm0E (subm _ _ _ _ _)).
  + smt(size_concat_side size_subm).
  by rewrite addr0.
- rewrite getm0E; 1: smt(size_concat_side size_subm).
  rewrite add0r submE; smt(size_concat_side size_subm).
qed.

lemma concat_down_subm m n: 0 <= n < rows m => 
  subm m 0 n 0 (cols m) / subm m n (rows m) 0 (cols m) = m.
proof. move => n_bound; apply trmx_inj => /=. by apply concat_side_subm. qed.

(* Updating one entry of a matrix *)
op updm (m: matrix) (r c: int) (p: t) =
  let a = offunm(fun i j => p - m.[r, c], 1, 1) in
  offunm (fun i j => m.[i, j] + a.[i-r, j-c], rows m, cols m).

lemma size_updm m r c p: size (updm m r c p) = size m by done.

lemma updmE (m: matrix) (r c i j: int) (p: t): mrange m r c => mrange m i j =>
  (updm m r c p).[i, j] = if (i, j) = (r, c) then p else m.[i, j].
proof.
rewrite /updm.
case (i = r) => /= [-> | neq_r bound1 bound2]. 
- case (j = c) => /= [-> bound _ | neq_col bound1 bound2]. 
  + by rewrite offunmE //= offunmE //= addrC subrK.
  + rewrite offunmE //= offunm0E //= 2:addr0; smt(leqn0).
- by rewrite offunmE //= offunm0E 1:/# neq_r addr0. 
qed.

(* Multplication with scalar for matrices and vectors *)
op mulmxs (m: matrix) (s: t) = m * diagc (cols m) s.

lemma rows_mulmxs (m: matrix) (s: t): rows (mulmxs m s) = rows m.
proof. by rewrite rows_mulmx. qed.

lemma cols_mulmxs (m: matrix) (s: t): cols (mulmxs m s) = cols m.
proof. by rewrite cols_mulmx. qed.

lemma mulmxs_mrange m s i j: mrange (mulmxs m s) i j = mrange m i j.
proof. by rewrite rows_mulmx // cols_mulmx. qed.

lemma size_mulmxs (m: matrix) (s: t): size (mulmxs m s) = size m.
proof. by rewrite rows_mulmxs cols_mulmxs. qed.
    
lemma mulmxsE (m: matrix) (s: t) (i j: int): mrange m i j =>
    (mulmxs m s).[i, j] = m.[i, j] * s.
proof.
move => bound; rewrite mulmxE /dotp 2!size_offunv rows_diagmx size_vectc.
rewrite 2!max0cols /= (bigD1 _ _ j) 1:mem_range 1:/# 1:range_uniq.
rewrite big1 /= 2:vectcE 2:/# 2:addr0 2:// => k.
rewrite /predC1 => -> /=.
apply mulr0.
qed.

lemma mulmxs_empty (s: t): mulmxs emptym s = emptym.
proof. apply emptym_unique. by rewrite cols_mulmx // rows_mulmx. qed.

hint simplify mulmxs_empty.

lemma mulmxs0 (m: matrix): mulmxs m zeror = zerom (rows m) (cols m).
proof.
rewrite eq_matrixP.
split => [| i j bound]; 1: rewrite size_mulmxs /#.
rewrite zeromE mulmxsE; 1: smt(size_mulmxs).
apply mulr0.
qed.

lemma mulmxs1 (m: matrix): mulmxs m oner = m.
proof.
rewrite eq_matrixP.
split => [| i j bound]; 1: by rewrite size_mulmxs.    
rewrite mulmxsE; 1: smt(size_mulmxs).
apply mulr1.
qed.

lemma mulmxsN (m: matrix): mulmxs m (- oner) = - m.
proof.
rewrite eq_matrixP.
split => [| i j bound]; 1: by rewrite size_mulmxs.    
rewrite mulmxsE; 1: smt(size_mulmxs).
by rewrite getvN mulrN mulr1.
qed.

lemma mulmxsAs m s1 s2: mulmxs (mulmxs m s1) s2 = (mulmxs m (s1 * s2)).
proof.
apply eq_matrixP. 
split => [| i j bound]; 1: by rewrite !size_mulmxs. 
rewrite 2!mulmxs_mrange in bound.
rewrite !mulmxsE 4:mulrA; smt(rows_mulmxs cols_mulmxs).
qed.

lemma mulmxsDmx m1 m2 s: mulmxs (m1 + m2) s = (mulmxs m1 s) + (mulmxs m2 s).
proof.
case (size m1 = size m2) => [size_eq | size_neq].
- apply eq_matrixP.
  rewrite rows_mulmxs rows_addm 1:// cols_mulmxs rows_addm 1:!size_mulmxs 1://.
  rewrite !cols_addm 1:// 1:!size_mulmxs 1:// size_mulmxs /= => i j bound.
  rewrite getmD 1:!size_mulmxs // !mulmxsE 1:rows_addm 1:// 1:cols_addm // 1:/#.
  by rewrite getmD // mulrDl.
- by rewrite !size_addm_diff 2:2!size_mulmxs.
qed.

lemma mulmxsDs m (s1 s2: t): mulmxs m (s1 + s2) = (mulmxs m s1) + (mulmxs m s2).
proof.
apply eq_matrixP.
rewrite rows_mulmxs cols_mulmxs.
split => [| i j bound]; 1: rewrite size_addm !size_mulmxs //.
by rewrite getmD 1:!size_mulmxs 1:// !mulmxsE // mulrDr.
qed.

(* Distribution of matrices sampled using d element-wise *)
op dmatrix (d : R distr) (r c: int) =
  dmap (dlist (dvector d r) (max 0 c)) (fun cs : vector list => 
    offunm (fun i j => (nth witness cs j).[i],r,c)).

lemma size_dmatrix d r c m: m \in dmatrix d r c => 
  0 <= r => 0 <= c => size m = (r, c). 
proof. rewrite supp_dmap => -[l [H0 -> /=]] /#. qed.

lemma dmatrix0E (d: R distr) (m: matrix) r c: 
  size m <> (r, c) => 0 <= r => 0 <= c => mu1 (dmatrix d r c) m = 0%r.
proof.
move => size_ineq r_ge0 c_ge0; apply supportPn.
case (m \in dmatrix d r c) => [cont | //].
apply size_ineq.
apply size_dmatrix in cont => /#.
qed.

lemma dmatrix1E d m : mu1 (dmatrix d (rows m) (cols m)) m =
  BRM.bigi predT (fun i => 
    BRM.bigi predT (fun j => mu1 d m.[i, j]) 0 (cols m)) 0 (rows m).
proof.
pose g (m: matrix) := mkseq (fun i => col m i) (cols m).
rewrite (in_dmap1E_can _ _ g).
- rewrite /g eq_matrixP /= => i j bound.
  by rewrite offunmE /= 1:/# nth_mkseq 1:/# colE.
- rewrite /g => y y_in <- /=.
  rewrite supp_dlist 1:/# in y_in.
  apply (eq_from_nth witness) => [| i i_bound]; 1: rewrite size_mkseq /#. 
  rewrite nth_mkseq /= 1:/# eq_vectorP size_col rows_offunm.
  rewrite -(all_nthP _ _ witness) in y_in.
  elim y_in => size_y.
  move => cont; have i_bound': 0 <= i && i < size y by done.
  apply cont in i_bound'; clear cont; move: i_bound'.
  move => nth_y_size; apply size_dvector in nth_y_size.
  split => [/# | j j_bound].
  rewrite colE offunmE /= /#.  
- rewrite dlist1E 1:/# size_mkseq /= (BRM.big_nth witness) predTofV.
  rewrite BRM.exchange_big /(\o) /= 2!BRM.big_seq /= size_mkseq max0cols. 
  apply BRM.eq_big => i // i_bound /=.
  rewrite mem_range in i_bound.
  have ->: rows m = size (nth witness (g m) i) by rewrite nth_mkseq //.
  rewrite dvector1E.
  congr; apply fun_ext => j.
  by rewrite nth_mkseq.
qed.

lemma dmatrix_uni d r c: is_uniform d => is_uniform (dmatrix d r c).
proof.
move=> uni_d; apply/dmap_uni_in_inj/dlist_uni/dvector_uni => //.
move=> xs ys xsin ysin /= eq_offunm.
apply/(eq_from_nth witness); 1: smt(supp_dlist). 
move => i i_bound; rewrite eq_vectorP. 
rewrite supp_dlist 1:/# -(all_nthP _ _ witness) in xsin.
rewrite supp_dlist 1:/# -(all_nthP _ _ witness) in ysin.
move: xsin ysin => [size_xs in_size_xs] [size_ys in_size_ys].
have ->: size (nth witness xs i) = max 0 r.
- by apply/(size_dvector d)/in_size_xs.
have -> /=: size (nth witness ys i) = max 0 r.
- by apply/(size_dvector d)/in_size_ys => /#.
move => j j_bound; apply (congr1 (fun m => m.[j, i])) in eq_offunm.
rewrite /= offunmE /= 1:/# in eq_offunm.
rewrite offunmE /= /# in eq_offunm.
qed.

lemma dmatrix_ll d r c: is_lossless d => is_lossless (dmatrix d r c).
proof. by move=> ll_d; apply/dmap_ll/dlist_ll/dvector_ll. qed.

lemma mu1_dmatrix_fu (d: R distr) (m: matrix): is_funiform d =>
    mu1 (dmatrix d (rows m) (cols m)) m = (mu1 d witness)^((rows m)*(cols m)).
proof.
move => d_funi.
rewrite dmatrix1E.
have ->: (fun (i : int) => (BRM.bigi predT 
           (fun (j : int) => mu1 d m.[i, j]) 0 (cols m))) = 
         (fun (_: int) => (mu1 d witness)^(cols m)).
- apply fun_ext => i.
  have ->: (fun (j : int) => mu1 d m.[i, j]) = fun (_: int) => mu1 d witness.
  + apply fun_ext => j. 
    exact d_funi.
  have: 0 <= cols m by exact cols_ge0. 
  move: (cols m).
  elim/ge0ind => [/# | _ | n bound IH _].
  + by rewrite range_geq //= BRM.big_nil RField.expr0.
  + by rewrite BRM.big_int_recr //= RField.exprS // RField.mulrC IH.
- have: 0 <= rows m by exact rows_ge0. 
  move: (rows m).
  elim/ge0ind => [/# | _ | n bound IH _].
  + by rewrite range_geq //= BRM.big_nil RField.expr0.
  + rewrite BRM.big_int_recr // RField.exprM RField.exprS // RField.mulrC.
    by rewrite RField.exprMn 1:/# /= IH // RField.exprM.
qed.

end Matrices.

export Matrices.

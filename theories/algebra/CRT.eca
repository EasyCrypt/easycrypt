(* -------------------------------------------------------------------- *)
require import AllCore List Ring Bigalg.

(* -------------------------------------------------------------------- *)
type t.

clone import IDomain as Domain with type t <- t.

clone import Bigalg.BigComRing as BigDom with
  type  t        <- t,
    op  CR.zeror <- Domain.zeror,
    op  CR.oner  <- Domain.oner,
    op  CR.(+)   <- Domain.(+),
    op  CR.([-]) <- Domain.([-]),
    op  CR.( * ) <- Domain.( * ),
    op  CR.invr  <- Domain.invr,
  pred  CR.unit  <- Domain.unit
  proof CR.*.

realize CR.addrA     by exact: Domain.addrA    .
realize CR.addrC     by exact: Domain.addrC    .
realize CR.add0r     by exact: Domain.add0r    .
realize CR.addNr     by exact: Domain.addNr    .
realize CR.oner_neq0 by exact: Domain.oner_neq0.
realize CR.mulrA     by exact: Domain.mulrA    .
realize CR.mulrC     by exact: Domain.mulrC    .
realize CR.mul1r     by exact: Domain.mul1r    .
realize CR.mulrDl    by exact: Domain.mulrDl   .
realize CR.mulVr     by exact: Domain.mulVr    .
realize CR.unitP     by exact: Domain.unitP    .
realize CR.unitout   by exact: Domain.unitout  .

(* -------------------------------------------------------------------- *)
abbrev "_.[_]" (xs : t list) (i : int) = nth zeror xs i.

(* -------------------------------------------------------------------- *)
op sth : t -> int.

op (%/) : t -> t -> t.
op (%%) : t -> t -> t.

axiom sth0     : sth zeror = 0.
axiom gt0_sth  : forall x, x <> zeror => 0 < sth x.
axiom mono_sth : forall x y, y <> zeror => sth y <= sth (x * y).

axiom divr0 : forall x, x %/ zeror = zeror.
axiom modr0 : forall x, x %% zeror = x.

axiom euclide :
  forall x y, y <> zeror =>
    x = (x %/ y) * y + x %% y /\ sth (x %% y) < sth x.

(* -------------------------------------------------------------------- *)
op (%|) (m d : t) = (d %% m = zeror).

op gcd (x y : t) = fun (d : t) =>
     (d %| x /\ d %| y)
  /\ (forall d', d' %| x => d' %| y => d' %| d).

lemma gcd_sym (x y d : t):
  gcd x y d => gcd y x d.
proof.
  by move => [[divdx divdy] Hd]; split => // d' divd'x divd'y; apply Hd.
qed.

op coprime (x y : t) = gcd x y oner.

lemma coprime_sym (x y : t):
  coprime x y => coprime y x.
proof. by apply gcd_sym. qed.

op coprimes (xs : t list) =
  forall i j, 0 <= i < size xs => 0 <= j < size xs => i <> j =>
    coprime xs.[i] xs.[j].

lemma coprimes_cons (x : t) (xs : t list):
  coprimes (x :: xs) =>
  coprimes xs /\
  (forall i, 0 <= i < size xs => coprime x xs.[i]).
proof.
  move => Hcps; split.
  + move => i j [le0i ltisxs] [le0j ltjsxs] neqij.
    move: (Hcps (i+1) (j+1)) => /=.
    (* Why is IntID.invr_neq0 ?*)
    have Hneqi:= (addz1_neqC0 _ le0i).
    have ->: (i + 1 <> 0) by smt().
    have Hneqj:= (addz1_neqC0 _ le0j).
    have ->: (j + 1 <> 0) by smt().
    move => /= -> //; smt().
  move => i [le0i ltisxs].
  move: (Hcps 0 (i+1)) => /=.
  have Hneqi:= (addz1_neqC0 _ le0i).
  have ->: (i + 1 <> 0) by smt().
  move => /= -> //; smt().
qed.

(* -------------------------------------------------------------------- *)
op duo_solution (x1 x2 c1 c2 : t) Y =
  Y %% x1 = c1 %% x1 /\
  Y %% x2 = c2 %% x2.

lemma duo_exists (x1 x2 : t) :
  coprime x1 x2 => forall c1 c2, exists Y, duo_solution x1 x2 c1 c2 Y.
proof.
admitted.

op crt_solution (xs : t list) (cs : t list) Y =
  forall i, 0 <= i < size xs =>
    Y %% xs.[i] = cs.[i] %% xs.[i].

lemma crt_exists (xs : t list) :
  coprimes xs => forall cs, exists Y, crt_solution xs cs Y.
proof.
  elim: xs => [|x xs IHxs] Hcps cs.
  + exists zeror => i /=.
    have:= (StdOrder.IntOrder.ler_lt_asym 0 i).
    smt().
  move: (coprimes_cons _ _ Hcps) => [{Hcps} Hcps Hcp].
  case: cs => [|c cs].
  + by exists zeror => i.
  move: (IHxs Hcps cs) => [Y] Hcrtsol.
  exists (c * zeror + x * Y).
  move => i; case: (i = 0) => [eqi|neqi].
  + rewrite eqi /= => _.
    admit.
  rewrite neqi /= => -[le0i ltissxs].
  rewrite -(Hcrtsol (i-1)).
  + split; smt().
  
qed.

lemma crt_unicity (xs cs : t list) (Y1 Y2 : t) :
  let M = BMul.big predT idfun xs in
    coprimes xs
  => crt_solution xs cs Y1
  => crt_solution xs cs Y2
  => Y1 %% M = Y2 %% M.
proof. admitted.

lemma crt_additive (xs cs cs1 cs2 : t list) (Y Y1 Y2 : t) :
  let M = BMul.big predT idfun xs in
     coprimes xs
  => crt_solution xs cs  Y
  => crt_solution cs cs1 Y1
  => crt_solution cs cs2 Y2
  =>

      Y %% M = (Y1 + Y2) %% M
  <=> (forall i, 0 <= i < size xs =>
         cs.[i] %% M = (cs1.[i] + cs2.[i]) %% M).
proof. admitted.

lemma crt_multiplicative (xs cs cs1 cs2 : t list) (Y Y1 Y2 : t) :
  let M = BMul.big predT idfun xs in
     coprimes xs
  => crt_solution xs cs  Y
  => crt_solution cs cs1 Y1
  => crt_solution cs cs2 Y2
  =>

      Y %% M = (Y1 + Y2) %% M
  <=> (forall i, 0 <= i < size xs =>
         cs.[i] %% M = (cs1.[i] * cs2.[i]) %% M).
proof. admitted.

(* -------------------------------------------------------------------- *)
require import AllCore List Ring StdOrder Bigalg Binomial.
(*---*) import IntOrder.

(* -------------------------------------------------------------------- *)
lemma size_eq1P ['a] (xs : 'a list) :
  (size xs = 1) <=> (exists x, xs = [x]).
proof.
split=> [|[x ->//]]; case: xs => // x [|y xs] sz.
- by exists x. - smt(size_ge0).
qed.

(* -------------------------------------------------------------------- *)
op fmin_spec ['a] (f : 'a -> int) (p : 'a -> bool) (x : 'a) =
  0 <= f x /\ p x /\ forall y, 0 <= f y => p y => f x <= f y.

op fmin ['a] f p = choiceb (fmin_spec<:'a> f p) witness.

lemma fminP ['a] (f : 'a -> int) (p : 'a -> bool) :
  (exists x, 0 <= f x /\ p x) =>
    0 <= f (fmin f p) /\ p (fmin f p) /\
      forall y, 0 <= f y => p y => f (fmin f p) <= f y.
proof.
case=> x [ge0_fx px]; apply: (choicebP (fmin_spec f p) witness).
suff h: forall n, 0 <= n => forall x, n = f x => p x =>
  exists y, fmin_spec f p y by apply: (h (f x) _ x).
elim/sintind=> {x ge0_fx px} i ge0_i ih x ->> px.
case: (exists y, 0 <= f y /\ p y /\ f y < f x) => [[y [# 3?]]|].
- by apply: (ih (f y) _ y).
rewrite negb_exists /= => hx; exists x; do! split => //.
by move=> y ge0_fy py; have := hx y; rewrite ge0_fy py /= ltrNge.
qed.

(* -------------------------------------------------------------------- *)
type t.

clone import IDomain as Domain with type t <- t.
clear [Domain.* Domain.AddMonoid.* Domain.MulMonoid.*].

clone import Bigalg.BigComRing as BigDom with
  type  t        <- t,
    op  CR.zeror <- Domain.zeror,
    op  CR.oner  <- Domain.oner,
    op  CR.(+)   <- Domain.(+),
    op  CR.([-]) <- Domain.([-]),
    op  CR.( * ) <- Domain.( * ),
    op  CR.invr  <- Domain.invr,
  pred  CR.unit  <- Domain.unit
  proof CR.*.

realize CR.addrA     by exact: Domain.addrA    .
realize CR.addrC     by exact: Domain.addrC    .
realize CR.add0r     by exact: Domain.add0r    .
realize CR.addNr     by exact: Domain.addNr    .
realize CR.oner_neq0 by exact: Domain.oner_neq0.
realize CR.mulrA     by exact: Domain.mulrA    .
realize CR.mulrC     by exact: Domain.mulrC    .
realize CR.mul1r     by exact: Domain.mul1r    .
realize CR.mulrDl    by exact: Domain.mulrDl   .
realize CR.mulVr     by exact: Domain.mulVr    .
realize CR.unitP     by exact: Domain.unitP    .
realize CR.unitout   by exact: Domain.unitout  .

clear [BigDom.* BigDom.BAdd.* BigDom.BMul.*].

(* -------------------------------------------------------------------- *)
abbrev "_.[_]" (xs : t list) (i : int) = nth zeror xs i.

(* -------------------------------------------------------------------- *)
op (%|) (x y : t) = (exists c, y = c * x).
op (%=) (x y : t) = (x %| y) /\ (y %| x).

(* -------------------------------------------------------------------- *)
lemma dvdrP x y : (x %| y) <=> (exists q, y = q * x).
proof. by rewrite /(%|). qed.

(* -------------------------------------------------------------------- *)
op ideal (I : t -> bool) =
     I zeror
  /\ (forall x y, I x => I y => I (x - y))
  /\ (forall a x, I x => I (a * x)).

lemma idealP (I : t -> bool) :
    I zeror
 => (forall x y, I x => I y => I (x - y))
 => (forall a x, I x => I (a * x))
 => ideal I.
proof. by move=> *; do! split. qed.

lemma idealW (P : (t -> bool) -> bool) :
  (forall I,
        I zeror
     => (forall (x y : t), I x => I y => I (x - y))
     => (forall a x, I x => I (a * x))
     => P I)
  => forall i, ideal i => P i.
proof. by move=> ih i [? [??]]; apply: ih. qed.

lemma ideal0 I : ideal I => I zeror.
proof. by case. qed.

lemma idealN I x : ideal I => I x => I (- x).
proof.
move=> ^iI [_ [+ _]] Ix - /(_ zeror x); rewrite sub0r.
by apply=> //; apply/ideal0.
qed.

lemma idealD I x y : ideal I => I x => I y => I (x + y).
proof.
move=> ^iI [_ [+ _] Ix Iy] - /(_ x (-y)); rewrite opprK.
by apply=> //; apply/idealN.
qed.

lemma idealB I x y : ideal I => I x => I y => I (x - y).
proof. by move=> iI Ix Iy; rewrite idealD -1:idealN. qed.

lemma idealMl I x y : ideal I => I y => I (x * y).
proof. by case=> _ [_ +]; apply. qed.

lemma idealMr I x y : ideal I => I x => I (x * y).
proof. by move=> iI Ix; rewrite mulrC; apply: idealMl. qed.

(* -------------------------------------------------------------------- *)
op id0 = pred1<:t> zeror.
op idT = predT<:t>.
op idI = predI<:t>.

op idD (I J : t -> bool) : t -> bool =
  fun x => exists i j, (I i /\ J j) /\ x = i + j.

op idR (I : t -> bool) : t -> bool =
  fun x => exists n, 0 <= n /\ I (Domain.exp x n).

(* -------------------------------------------------------------------- *)
lemma mem_id0 x : id0 x <=> x = zeror.
proof. by []. qed.

(* -------------------------------------------------------------------- *)
lemma ideal_id0 : ideal id0.
proof.
rewrite /id0 /pred1; apply/idealP => //.
- by move=> x y -> -> /=; rewrite subrr.
- by move=> a x -> /=; rewrite mulr0.
qed.

(* -------------------------------------------------------------------- *)
lemma ideal_idT : ideal idT.
proof. by []. qed.

(* -------------------------------------------------------------------- *)
lemma ideal_idI I J : ideal I => ideal J => ideal (idI I J).
proof.
move=> iI iJ @/idI @/predI; apply/idealP => //=.
- by rewrite !ideal0.
- by move=> x y [Ix Jx] [Iy Jy]; rewrite !idealB.
- by move=> a x [Ix Jx]; rewrite !idealMl.
qed.

(* -------------------------------------------------------------------- *)
lemma ideal_idD I J : ideal I => ideal J => ideal (idD I J).
proof.
move=> iI iJ; apply/idealP.
- by exists zeror zeror; rewrite addr0 !ideal0.
- move=> _ _ [xi xj [[Ixi Jxj] ->]] [yi yj [[Iyi Jyj] ->]].
  by rewrite subrACA; exists (xi - yi) (xj - yj) => /=; rewrite !idealB.
- move=> a _ [i j [[Ii Jj] ->]]; rewrite mulrDr.
  by exists (a * i) (a * j) => /=; rewrite !idealMl.
qed.

(* -------------------------------------------------------------------- *)
lemma idDC I J : idD I J = idD J I.
proof.
apply/fun_ext=> x @/idD; apply: eq_iff; split; 
  by case=> i j [? ->]; exists j i; rewrite addrC /= andbC.
qed.

lemma mem_idDl I J x : I x => ideal J => (idD I J) x.
proof.
by move=> Ix iJ; exists x zeror; rewrite Ix addr0 ideal0.
qed.

lemma mem_idDr I J x : J x => ideal I => (idD I J) x.
proof.
by move=> Jx iI; rewrite idDC; apply: mem_idDl.
qed.

(* -------------------------------------------------------------------- *)
op idgen (xs : t list) = fun (x : t) =>
  exists cs, x = BAdd.bigi predT (fun i => cs.[i] * xs.[i]) 0 (size xs).

lemma idgenP (xs : t list) (x : t) :
  idgen xs x => exists cs, size cs = size xs
    /\ x = BAdd.bigi predT (fun i => cs.[i] * xs.[i]) 0 (size xs).
proof.
case=> cs ->; exists (mkseq (fun i => cs.[i]) (size xs)); split.
- by rewrite size_mkseq ler_maxr // size_ge0.
rewrite !BAdd.big_seq &(BAdd.eq_bigr) /= => i /mem_range rg_i.
by rewrite nth_mkseq.
qed.

lemma ideal_idgen (xs : t list) : ideal (idgen xs).
proof. do! split.
- by exists []; rewrite BAdd.big1 //= => i _; rewrite mul0r.
- move=> x y /idgenP[cxs [szx ->]] /idgenP[cys [szy ->]].
  rewrite BAdd.sumrB /=; exists (mkseq (fun i => cxs.[i] - cys.[i]) (size xs)).
  rewrite !BAdd.big_seq &(BAdd.eq_bigr) /= => i /mem_range rg_i.
  by rewrite nth_mkseq //= mulrBl.
- move=> a x /idgenP[cs [sz ->]]; exists (mkseq (fun i => a * cs.[i]) (size xs)).
  rewrite BAdd.mulr_sumr !BAdd.big_seq &(BAdd.eq_bigr) /=.
  by move=> i /mem_range rg_i; rewrite nth_mkseq //= mulrA.
qed.

hint exact : ideal_idgen.

lemma mem_idgen1 x a : idgen [x] a <=> exists b, a = b * x.
proof. split => [/idgenP /= [cs]|].
- by case=> [/size_eq1P[c ->] ->]; exists c; rewrite BAdd.big_int1.
- by case=> c ->; exists [c] => /=; rewrite BAdd.big_int1.
qed.

lemma mem_idgen1_gen x : idgen [x] x.
proof.
by rewrite mem_idgen1; exists oner; rewrite mul1r.
qed.

(* -------------------------------------------------------------------- *)
lemma le_idDl (I1 I2 J : t -> bool) :
  ideal J => I1 <= J => I2 <= J => idD I1 I2 <= J.
proof.
move=> iJ le1 le2 x [x1 x2 [+ ->]].
by case=> [/le1 Jx1 /le2 Jx2]; apply: idealD.
qed.

(* -------------------------------------------------------------------- *)
op principal (I : t -> bool) =
  exists a : t, forall x, (I x <=> exists b, x = b * a).

lemma principal_ideal I : principal I => ideal I.
proof.
case=> a inI; suff ->: I = idgen [a] by apply/ideal_idgen.
by apply/fun_ext=> x; rewrite inI -mem_idgen1.
qed.

lemma principal_idgen1 x : principal (idgen [x]).
proof. by exists x=> y; rewrite mem_idgen1. qed.

lemma idgen1_0 : idgen [zeror] = id0.
proof.
apply/fun_ext=> x; rewrite mem_id0 mem_idgen1.
apply/eq_iff; split=> [[b ->]|->].
- by rewrite mulr0.
- by exists zeror; rewrite mulr0.
qed.

lemma principalP I : principal I <=> exists d, I = idgen [d].
proof.
split=> [|[d ->]]; last by apply/principal_idgen1.
by case=> d IE; exists d; apply/fun_ext => x; rewrite IE mem_idgen1.
qed.

lemma principal_id0 : principal id0.
proof. by rewrite -idgen1_0 &(principal_idgen1). qed.

(* -------------------------------------------------------------------- *)
lemma mem_idgen1_dvd x y : idgen [x] y <=> x %| y.
proof. by rewrite mem_idgen1 -dvdrP. qed.

lemma le_idgen1_dvd x y : x %| y <=> idgen [y] <= idgen [x].
proof.
split=> [[c ->>] y /mem_idgen1_dvd [d ->]|].
- by rewrite mulrA mem_idgen1_dvd; exists (d * c).
- move/(_ y); rewrite !mem_idgen1_dvd; apply.
  by exists oner; rewrite mul1r.
qed.

lemma in_idgen_mem xs x : x \in xs => idgen xs x.
proof. admitted.

lemma dvdrr x : x %| x.
proof. by rewrite -mem_idgen1_dvd mem_idgen1_gen. qed.

lemma dvdr_mull d x y : d %| y => d %| x * y.
proof.
by rewrite -!mem_idgen1_dvd => ?; apply/(@idealMl (idgen [d])).
qed.

lemma dvdr_mulr d x y : d %| x => d %| x * y.
proof. by move=> dx; rewrite mulrC dvdr_mull. qed.

lemma dvdr_trans : transitive (%|).
proof.
move=> z x y; rewrite !le_idgen1_dvd => h1 h2.
by apply: (subpred_trans _ _ _ h2 h1).
qed.

lemma dvdr0 x : x %| zeror.
proof. by exists zeror; rewrite mul0r. qed.

lemma dvd0r x : (zeror %| x) <=> (x = zeror).
proof.
split=> [|->]; last by exists zeror; rewrite mulr0.
by case=> ?; rewrite mulr0.
qed.

lemma eqmodP x y : (x %= y) <=> (exists u, unit u /\ x = u * y).
proof.
split=> [[dxy dyx]|[u [invu ->]]]; last first.
- rewrite /(%=) dvdr_mull 1:dvdrr /=; apply/dvdrP.
  by exists (invr u); rewrite mulrA mulVr // mul1r. (* FIXME *)
case: (y = zeror) => [->>|nz_y].
- rewrite (_ : x = zeror) 1:-dvd0r //.
  by exists oner; rewrite mul1r /= unitr1.
case/dvdrP: dyx=> u xE; exists u; rewrite xE eq_refl /=.
apply/unitrP; case/dvdrP: dxy=> v yE; exists v.
by apply: (mulIf y) => //; rewrite mul1r -mulrA -xE yE.
qed.

lemma idgen_mulVl x y : unit x => idgen [x * y] = idgen [y].
proof.
move=> invx; apply/fun_ext=> z; apply/eq_iff.
apply: subpred_eqP z => /=; split.
- by apply/le_idgen1_dvd/dvdr_mull/dvdrr.
move=> z /mem_idgen1[c ->]; apply/mem_idgen1.
by exists (c * invr x); rewrite !mulrA mulrVK.
qed.

lemma eqmod_idP x y : (x %= y) <=> (idgen [x] = idgen [y]).
proof.
split; first by case/eqmodP=> [u [invu ->]]; rewrite idgen_mulVl.
move=> eq; have: idgen[x] <= idgen[y] /\ idgen[y] <= idgen[x].
- by apply/subpred_eqP=> z; rewrite eq.
by case=> /le_idgen1_dvd dyx /le_idgen1_dvd dxy.
qed.

(* -------------------------------------------------------------------- *)
lemma eqp_refl x : x %= x.
proof. by rewrite eqmod_idP. qed.

lemma eqp_sym x y : x %= y => y %= x.
proof. by rewrite !eqmod_idP eq_sym. qed.

lemma eqp_trans y x z : x %= y => y %= z => x %= z.
proof. by rewrite !eqmod_idP => <-. qed.

lemma eqp0P x : (x %= zeror) <=> (x = zeror).
proof.
split=> [/eqmodP[u [_ ->]]|]; first by rewrite mulr0.
by move=> ->; apply/eqp_refl.
qed.

(* -------------------------------------------------------------------- *)
op sth : t -> int.

op (%/) : t -> t -> t.
op (%%) : t -> t -> t.

axiom sth0     : sth zeror = 0.
axiom gt0_sth  : forall x, x <> zeror => 0 < sth x.
axiom mono_sth : forall x y, y <> zeror => sth y <= sth (x * y).

axiom divr0 : forall x, x %/ zeror = zeror.
axiom divr1 : forall x, x %/ oner = x.
axiom modr0 : forall x, x %% zeror = x.

axiom euclide :
  forall x y, y <> zeror =>
    x = (x %/ y) * y + x %% y /\ sth (x %% y) < sth y.

(* -------------------------------------------------------------------- *)
lemma ge0_sth (x : t) : 0 <= sth x.
proof.
by case: (x = zeror) => [->|?]; [rewrite sth0 | rewrite ltrW gt0_sth].
qed.

(* -------------------------------------------------------------------- *)
lemma divr_eq x y : x = x %/ y * y + x %% y.
proof.
case: (y = zeror) => [->|nz_y]; first by rewrite mulr0 modr0 add0r.
by have [xE _] := euclide x y nz_y.
qed.

lemma modrE x y : x %% y = x - x %/ y * y.
proof. by rewrite {2}(divr_eq x y) addrAC subrr add0r. (* FIXME *) qed.

lemma divrE x y : x %/ y * y = x - x %% y.
proof. by rewrite modrE opprB addrCA subrr addr0. qed. (* FIXME *)

(* -------------------------------------------------------------------- *)
lemma ideal_principal I : ideal I => principal I.
proof.
move=> iI; pose P x := x <> zeror /\ I x; case: (exists x, P x); last first.
- rewrite negb_exists /= => zI; suff ->: I = id0 by apply/principal_id0.
  apply/fun_ext=> x; apply/eq_iff; rewrite mem_id0; split.
  - by apply: contraLR => nz_x; have := zI x; rewrite /P nz_x.
  - by move=> ->; apply: ideal0.
case=> x Px; have: exists x, P x /\ forall y, P y => sth x <= sth y.
- exists (fmin sth P); have := fminP sth P _.
  - by exists x; rewrite ge0_sth.
  by move=> [#] _ -> /= + y Py; apply=> //; apply/ge0_sth.
case=> @/P b /= [#] nz_b Ib min_b; exists b => a; split; last first.
- by case=> ? ->; apply/idealMl/Ib.
move=> Ia; have [aE le_sth] := euclide a b nz_b.
case: (a %% b = zeror) => [z_ab|nz_ab].
- by rewrite aE z_ab addr0; exists (a %/ b).
have Iab: I (a %% b) by rewrite modrE idealB // idealMl.
by have @/P := min_b (a %% b); rewrite nz_ab Iab /= lerNgt.
qed.

(* -------------------------------------------------------------------- *)
op gcd (x y : t) = fun (d : t) =>
     (d %| x /\ d %| y)
  /\ (forall d', d' %| x => d' %| y => d' %| d).

lemma gcd_eqmod x y d1 d2 : gcd x y d1 => gcd x y d2 => d1 %= d2.
proof.
case=> [# d1x d1y max1] [] [# d2x d2y max2] @/(%=).
by split; [apply: max2 | apply: max1].
qed.

lemma Bachet_Bezout x y d : gcd x y d =>
  exists u v, u * x + v * y = d.
proof.
move=> gcd_xy; pose I := idD (idgen [x]) (idgen [y]).
have: principal I by apply/ideal_principal/ideal_idD; apply/ideal_idgen.
case/principalP=> d' IE; have gcd'_xy: gcd x y d'; first do! split.
- by rewrite -mem_idgen1_dvd -IE /I mem_idDl ?mem_idgen1_gen ideal_idgen.
- by rewrite -mem_idgen1_dvd -IE /I mem_idDr ?mem_idgen1_gen ideal_idgen.
- move=> e dex dey; suff: I <= idgen [e] by rewrite IE le_idgen1_dvd.
  by apply: le_idDl; (try by apply: ideal_idgen); apply: le_idgen1_dvd.
have: I d' by rewrite IE mem_idgen1_gen.
case=> ?? [#] /mem_idgen1[u ->>] /mem_idgen1[v ->>] d'E.
have /eqmodP[c [invc ->]] := gcd_eqmod _ _ _ _ gcd_xy gcd'_xy.
by exists (c * u) (c * v); rewrite d'E mulrDr !mulrA.
qed.

(* FIXME: rework *)
lemma gcdP (x y d : t) : (gcd x y d) <=> (idgen [x; y] = idgen [d]).
proof.
split=> [Hgcd|iE].
- apply/fun_ext=> z; apply/eq_iff; split.
  - case/idgenP => cs /= [_ ->]; apply mem_idgen1_dvd.
    rewrite BAdd.big_ltn //= BAdd.big_ltn //= BAdd.big_geq //= addr0.
    move: Hgcd => [[[cx ->] [cy ->]] _]; rewrite !mulrA -mulrDl.
    by rewrite dvdr_mull; exists oner; rewrite mul1r.
  move/mem_idgen1_dvd; case: (Bachet_Bezout _ _ _ Hgcd) => u v <- [c] ->.
  rewrite mulrDr !mulrA; exists [c * u; c * v].
  rewrite BAdd.big_ltn //= BAdd.big_ltn //= BAdd.big_geq //= addr0 //.
do! split.
- by rewrite -mem_idgen1_dvd -iE in_idgen_mem.
- by rewrite -mem_idgen1_dvd -iE in_idgen_mem.
move=> d' [cx xE] [cy yE]; apply/mem_idgen1_dvd.
have: idgen [x; y] d by rewrite iE mem_idgen1_gen.
case=> cs /=; rewrite 2?BAdd.big_ltn // BAdd.big_geq //= => ->.
rewrite xE yE addr0 !mulrA -mulrDl.
by pose c' := (_ + _)%Domain; apply/mem_idgen1; exists c'.
qed.

lemma gcd_exists (x y : t) :
  exists d , gcd x y d.
proof.
have := ideal_principal _ (ideal_idgen [x; y]).
by case/principalP=> d iE; exists d; apply/gcdP.
qed.

lemma gcd_sym (x y d : t):
  gcd x y d => gcd y x d.
proof.
  by move => [[divdx divdy] Hd]; split => // d' divd'x divd'y; apply Hd.
qed.

lemma eqmod_gcd x y d1 d2 : gcd x y d1 => d1 %= d2 => gcd x y d2.
proof.
case=> [# d1x d1y max1] [d12 d21].
do!split => [ | |d ddx ddy]; apply (dvdr_trans d1) => //.
by apply max1.
qed.

lemma gcd_mulr (x y z d dy dz : t) :
  gcd x y dy =>
  gcd x z dz =>
  gcd x (y * z) d =>
  d %| dy * dz.
proof.
move=> gcdxydy gcdxzdz /gcdP idgxyzd.
case: (Bachet_Bezout _ _ _ gcdxydy) => uy vy <<-.
case: (Bachet_Bezout _ _ _ gcdxzdz) => uz vz <<-.
rewrite mulrDr (mulrDl _ _ (vz * z)) (mulrC (uy * x)) !addrA !mulrA.
rewrite -(mulrDl _ _ x) -(mulrA vy y vz) (mulrC y vz) mulrA -(mulrA _ y z).
apply le_idgen1_dvd; move: idgxyzd => <- {d} a.
case => /= cs ->>; rewrite BAdd.big_ltn // BAdd.big_geq //= addr0.
rewrite mulrDr !(mulrA cs.[0]).
exists ([cs.[0] * ((uy * x + vy * y) * uz + vz * z * uy); cs.[0] * (vy * vz)]).
rewrite 2?BAdd.big_ltn // BAdd.big_geq //= addr0.
by rewrite mulrDr !mulrA.
qed.

op coprime (x y : t) = gcd x y oner.

lemma coprime_sym (x y : t) :
  coprime x y =>
  coprime y x.
proof. by apply gcd_sym. qed.

lemma dvd1r (x : t) : oner %| x.
proof. by exists x; rewrite mulr1. qed.

lemma dvdr1P (x : t) : x %| oner <=> unit x.
proof.
have ->: x %| oner <=> x %= oner by rewrite /(%=) dvd1r.
split.
- by rewrite eqmodP => -[u [invu ->]]; rewrite mulr1.
- by move=> invx; apply/eqmodP; exists x; rewrite mulr1.
qed.

lemma coprime_mulr (x y z : t) :
  coprime x y =>
  coprime x z =>
  coprime x (y * z).
proof.
  move => Hcpxy Hcpxz.
  case: (gcd_exists x (y * z)) => d Hgcd.
  have:= (gcd_mulr _ _ _ _ _ _ Hcpxy Hcpxz Hgcd).
  rewrite mulr1 => Hunit.
  apply (eqmod_gcd _ _ _ _ Hgcd).
  by split => //; rewrite dvd1r.
qed.

op coprime_with (x : t) (xs : t list) =
  (forall i, 0 <= i < size xs => coprime x xs.[i]).

op coprimes (xs : t list) =
  forall i j, 0 <= i < size xs => 0 <= j < size xs => i <> j =>
    coprime xs.[i] xs.[j].

lemma coprimes_cons (x : t) (xs : t list):
  coprimes (x :: xs) =>
  coprime_with x xs /\
  coprimes xs.
proof.
  move => Hcps; split.
  + move => i [le0i ltisxs].
    move: (Hcps 0 (i+1)) => /=.
    have Hneqi:= (addz1_neqC0 _ le0i).
    have ->: (i + 1 <> 0) by smt().
    move => /= -> //; smt().
  move => i j [le0i ltisxs] [le0j ltjsxs] neqij.
  move: (Hcps (i+1) (j+1)) => /=.
  have Hneqi:= (addz1_neqC0 _ le0i).
  have ->: (i + 1 <> 0) by smt().
  have Hneqj:= (addz1_neqC0 _ le0j).
  have ->: (j + 1 <> 0) by smt().
  move => /= -> //; smt().
qed.

lemma coprimes_big (x : t) (xs : t list) :
  coprime_with x xs =>
  coprime x (BMul.big predT idfun xs).
proof.
  elim: xs => [_|hxs txs IHxs Hcpw].
  + by rewrite BMul.big_nil; do!split => //; apply dvd1r.
  rewrite BMul.big_consT /idfun; apply coprime_mulr.
  + have /= cphxsc:= (Hcpw 0); apply: cphxsc.
    by apply ltzE; rewrite addzC lez_addl; apply size_ge0.
  apply IHxs => i [le0i ltistxs]; have /=:= (Hcpw (i + 1)).
  rewrite (addz1_neq0 _ le0i) /= => cpxtxsi; apply cpxtxsi.
  by split; smt().
qed.

lemma diagonal_ind ['a 'b] (P : 'a list -> 'b list -> bool) :
  (forall cs, P [] cs) =>
  (forall x c xs cs , P xs cs => P (x :: xs) (c :: cs)) =>
  forall xs cs, size xs <= size cs => P xs cs.
proof.
move=> h0 hS; elim=> [|x xs ih] cs lesz; first by apply: h0.
case: cs lesz => [|c cs] lesz; first smt(size_ge0).
by apply/hS/ih => /#.
qed.

op crt_solution (xs : t list) (cs : t list) Y =
  forall i, 0 <= i < size xs =>
    Y %% xs.[i] %= cs.[i] %% xs.[i].

op eq_csol n (cs1 cs2 : t list) =
  forall i, 0 <= i < n => cs1.[i] = cs2.[i].

lemma eq_sol xs cs1 cs2 Y :
     eq_csol (size xs) cs1 cs2
  => crt_solution xs cs1 Y
  => crt_solution xs cs2 Y.
proof. by move=> eq sol i rgi; rewrite -eq // &(sol). qed.

op norm n (cs : t list) =
  mkseq (fun i => cs.[i]) n.

lemma size_norm n cs : 0 <= n => size (norm n cs) = n.
proof. by move=> ge0_n; rewrite size_mkseq ler_maxr. qed.

lemma normK n cs : norm n (norm n cs) = norm n cs.
proof.
case: (0 <= n) => [ge0_n|/ltrNge lt0_n]; last first.
- by rewrite /norm !mkseq0_le // ltrW.
apply/(eq_from_nth zeror); first by rewrite !size_norm.
by rewrite size_norm // => i rgi @/norm; rewrite nth_mkseq.
qed.

lemma norm_crt_solution (xs : t list) (cs : t list) Y :
  crt_solution xs cs Y => crt_solution xs (norm (size xs) cs) Y.
proof. by move=> sol i rgi @/norm; rewrite nth_mkseq //= &(sol). qed.

lemma dvdr_prod ['a] P F r y :
  (exists x, (x \in r /\ P x /\ y %| F x)) => y %| BMul.big<:'a> P F r.
proof.
case=> x [# /perm_to_rem xr Px dvd_y_Fx].
rewrite (BMul.eq_big_perm _ _ _ _ xr) BMul.big_cons.
by rewrite Px /= dvdr_mulr.
qed.

lemma modP (x y d : t) : (x %% d %= y %% d) <=> (d %| (x - y)).
proof.
admitted.

lemma crt_solution_cons (Y x c : t) (xs cs : t list) :
  crt_solution (x :: xs) (c :: cs) Y <=>
  (Y %% x %= c %% x) /\ (crt_solution xs cs Y).
proof.
split => [crtsolcons|[crtsolx crtsolxs] i [le0i ltisxxs] /=].
- split.
  - by apply (crtsolcons 0) => /=; rewrite addzC -(addz0 0); apply ler_lt_add => //; apply size_ge0.
  move => i [le0i ltisxs].
  move: (crtsolcons (1 + i)) => /=.
  have -> /=: (1 + i <> 0)  by smt().
  by move => -> //; split; smt().
case: (i = 0) => // neq0i.
by apply crtsolxs; split; smt().
qed.

lemma dvd_add (x y d : t) : d %| x => d %| y => d %| (x + y).
proof.
by move => [cx ->>] [cy ->>]; rewrite -mulrDl; exists (cx + cy).
qed.

lemma dvd_big (xs : t list) : forall i , xs.[i] %| (BMul.big predT idfun xs).
proof.
admitted.

lemma crt_exists (xs : t list) :
  coprimes xs => forall cs, exists Y, crt_solution xs cs Y.
proof.
move => Hcps cs; wlog: cs / (size xs = size cs).
- move=> wlog; case: (wlog (norm (size xs) cs) _).
  - by rewrite size_norm // size_ge0.
  move=> Y sol; exists Y; apply: eq_sol sol.
  by move=> i rgi; rewrite nth_mkseq.
rewrite eqr_le => -[h _]; move: h Hcps.
apply: diagonal_ind xs cs.
- move => cs _; exists zeror => i /=.
  have:= (StdOrder.IntOrder.ler_lt_asym 0 i).
  smt().
move => x c xs cs IHxscs Hcps.
move: (coprimes_cons _ _ Hcps) => [{Hcps} Hcpw Hcps].
case: (IHxscs Hcps) => Y Hcrtsol.
(*Why not working?*)
have [u v equv] := Bachet_Bezout x (BMul.big predT idfun xs) oner _.
- by apply/coprimes_big.
exists (Y + (c - Y) * (v * (BMul.big predT idfun xs))).
apply crt_solution_cons; split.
- have ->: (v * (BMul.big predT idfun xs) = oner - u * x).
  - by rewrite -equv addrAC subrr add0r. (* FIXME: ring *)
  apply modP; rewrite mulrDr mulr1 !addrA (addrC Y) addrK (addrC c) .
  by rewrite -(addrA _ c) subrr addr0 -mulNr mulrA dvdr_mull dvdrr.
move => i Hi; apply modP; rewrite (addrC Y (_ * _)%Domain) -(addrA _ Y).
apply dvd_add; last by move: (Hcrtsol i Hi) => /modP.
by rewrite mulrA dvdr_mull; apply dvd_big.
qed.

lemma dvd_sub (x y d : t) : d %| x => d %| y => d %| (x - y).
proof.
by move => [cx ->>] [cy ->>]; rewrite -mulNr -mulrDl; exists (cx - cy).
qed.

lemma dvd_mul_coprime (x d1 d2 : t) : coprime d1 d2 => d1 %| x => d2 %| x => (d1 * d2) %| x.
proof.
admitted.

lemma crt_unicity (xs cs : t list) (Y1 Y2 : t) :
  let M = BMul.big predT idfun xs in
     coprimes xs
  => crt_solution xs cs Y1
  => crt_solution xs cs Y2
  => Y1 %% M %= Y2 %% M.
proof.
move => /= Hcps; wlog: cs / (size xs = size cs).
- move=> wlog crtsol1 crtsol2.
  apply (wlog (norm (size xs) cs)).
  - by rewrite size_norm // size_ge0.
  - by apply norm_crt_solution.
  by apply norm_crt_solution.
move => Hsize crtsol1 crtsol2; apply modP; move: Hsize Hcps crtsol1 crtsol2.
rewrite eqr_le => -[h _]; move: h.
apply: diagonal_ind xs cs => /=.
- by move => cs _ _ _; rewrite BMul.big_nil dvd1r.
move => x c xs cs IHxscs; case/coprimes_cons => Hcpw Hcps.
move => /crt_solution_cons [/modP dvdx1 crtsol1] /crt_solution_cons [/modP dvdx2 crtsol2].
rewrite BMul.big_consT {1}/idfun.
apply dvd_mul_coprime.
- by apply coprimes_big.
- by move: (dvd_sub _ _ _ dvdx1 dvdx2); rewrite subr_add2r.
by apply IHxscs.
qed.

lemma crt_additive (xs cs cs1 cs2 : t list) (Y Y1 Y2 : t) :
  let M = BMul.big predT idfun xs in
     coprimes xs
  => crt_solution xs cs  Y
  => crt_solution cs cs1 Y1
  => crt_solution cs cs2 Y2
  =>

      Y %% M = (Y1 + Y2) %% M
  <=> (forall i, 0 <= i < size xs =>
         cs.[i] %% M = (cs1.[i] + cs2.[i]) %% M).
proof.
move => /= Hcps; wlog: cs cs1 cs2 / (size xs = size cs /\ size cs = size cs1 /\ size cs = size cs2).
- move=> wlog crtsol crtsol1 crtsol2.
  move: (wlog (norm (size xs) cs) (norm (size xs) cs1) (norm (size xs) cs2) _ _ _ _).
  - by rewrite !size_norm // size_ge0.
  - by apply norm_crt_solution.
qed.

lemma crt_multiplicative (xs cs cs1 cs2 : t list) (Y Y1 Y2 : t) :
  let M = BMul.big predT idfun xs in
     coprimes xs
  => crt_solution xs cs  Y
  => crt_solution cs cs1 Y1
  => crt_solution cs cs2 Y2
  =>

      Y %% M = (Y1 + Y2) %% M
  <=> (forall i, 0 <= i < size xs =>
         cs.[i] %% M = (cs1.[i] * cs2.[i]) %% M).
proof. admitted.

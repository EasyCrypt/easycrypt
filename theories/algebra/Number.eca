(* --------------------------------------------------------------------
 * Copyright (c) - 2012--2015 - IMDEA Software Institute
 * Copyright (c) - 2012--2015 - Inria
 * 
 * Distributed under the terms of the CeCILL-B-V1 license
 * -------------------------------------------------------------------- *)

(* -------------------------------------------------------------------- *)
require import Int Fun Pred.
require Ring.

pragma +implicits.

(* -------------------------------------------------------------------- *)
pred homo2 ['a 'b] (op_ : 'a -> 'b) (aR : 'a rel) (rR : 'b rel) =
  forall x y, aR x y => rR (op_ x) (op_ y).

pred mono2 ['a 'b] (op_ : 'a -> 'b) (aR : 'a rel) (rR : 'b rel) =
  forall x y, rR (op_ x) (op_ y) <=> aR x y.

lemma mono2W f (aR : 'a rel) (rR : 'b rel) :
  mono2 f aR rR => homo2 f aR rR.
proof. by move=> + x y - ->. qed.

lemma monoLR ['a 'b] f g (aR : 'a rel) (rR : 'b rel) :
  cancel g f => mono2 f aR rR => forall x y,
    rR (f x) y <=> aR x (g y).
proof. by move=> can_gf mf x y; rewrite -{1}can_gf mf. qed.

lemma monoRL ['a 'b] f g (aR : 'a rel) (rR : 'b rel) :
  cancel g f => mono2 f aR rR => forall x y,
    rR x (f y) <=> aR (g x) y.
proof. by move=> can_gf mf x y; rewrite -{1}can_gf mf. qed.

(* -------------------------------------------------------------------- *)
type t.

clone import Ring.IDomain as Domain with type t <- t.

op "`|_|" : t -> t.
op ( <= ) : t -> t -> bool.
op ( <  ) : t -> t -> bool.

theory Axioms.
  axiom nosmt ler_norm_add (x y : t): `|x + y| <= `|x| + `|y|.
  axiom nosmt addr_gt0     (x y : t): zeror < x => zeror < y => zeror < (x + y).
  axiom nosmt norm_eq0     (x   : t): `|x| = zeror => x = zeror.
  axiom nosmt ger_leVge    (x y : t): zeror <= x => zeror <= y => (x <= y) \/ (y <= x).
  axiom nosmt normrM       (x y : t): `|x * y| = `|x| * `|y|.
  axiom nosmt ler_def      (x y : t): x <= y <=> `|y - x| = y - x.
  axiom nosmt ltr_def      (x y : t): x < y <=> (y <> x) /\ x <= y.
end Axioms.

lemma nosmt ler_norm_add (x y : t): `|x + y| <= `|x| + `|y|.
proof. by apply/Axioms.ler_norm_add. qed.

lemma nosmt addr_gt0 (x y : t): zeror < x => zeror < y => zeror < x + y.
proof. by apply/Axioms.addr_gt0. qed.

lemma nosmt normr0_eq0 (x : t): `|x| = zeror => x = zeror.
proof. by apply/Axioms.norm_eq0. qed.

lemma nosmt ger_leVge (x y : t):
  zeror <= x => zeror <= y => (x <= y) \/ (y <= x).
proof. by apply/Axioms.ger_leVge. qed.

lemma nosmt normrM (x y : t): `|x * y| = `|x| * `|y|.
proof. by apply/Axioms.normrM. qed.

lemma nosmt ler_def (x y : t): (x <= y) <=> (`|y - x| = y - x).
proof. by apply/Axioms.ler_def. qed.

lemma nosmt ltr_def (x y : t): (x < y) <=> (y <> x) /\ (x <= y).
proof. by apply/ Axioms.ltr_def. qed.

lemma ger0_def (x : t): (zeror <= x) <=> (`|x| = x).
proof. by rewrite ler_def subr0. qed.

lemma subr_ge0 (x y : t): (zeror <= x - y) <=> (y <= x).
proof. by rewrite ger0_def -ler_def. qed.

lemma oppr_ge0 (x : t): (zeror <= -x) <=> (x <= zeror).
proof. by rewrite -sub0r subr_ge0. qed.

lemma ler01: zeror <= oner.
proof.                        (* FIXME: anomaly with (inj_eq mulfI) *)
have n1_nz: `|oner| <> zeror by apply/(contraNneq _ oner_neq0) => /normr0_eq0->.
rewrite ger0_def; have /inj_eq <- := mulfI _ n1_nz.
by rewrite -normrM !mulr1.
qed.

lemma ltr01: zeror < oner.
proof. by rewrite ltr_def oner_neq0 ler01. qed.

lemma ltrW (x y : t): x < y => x <= y.
proof. by rewrite ltr_def. qed.

lemma nosmt lerr (x : t): x <= x.
proof.
have n2: `|ofint 2| = (ofint 2).
  rewrite -ger0_def @(ofintS 1) // ofint1 ltrW //.
  by rewrite addr_gt0 ?ltr01.
rewrite ler_def subrr -(inj_eq (addrI `|zeror|)) /= addr0.
by rewrite -mulr2z -mulr_intr -n2 -normrM mul0r.
qed.

lemma nosmt ltrr (x : t): !(x < x).
proof. by rewrite ltr_def. qed.

lemma nosmt ltr_neqAle (x y : t):
  (x < y) <=> (x <> y) /\ (x <= y).
proof. by rewrite ltr_def eq_sym. qed.

lemma nosmt ler_eqVlt (x y : t):
  (x <= y) <=> (x = y) \/ (x < y).
proof. by rewrite ltr_neqAle; case: (x = y)=> // ->; rewrite lerr. qed.

lemma nosmt lt0r (x : t):
  (zeror < x) <=> (x <> zeror) /\ (zeror <= x).
proof. by rewrite ltr_def. qed.

lemma nosmt le0r (x : t):
  (zeror <= x) <=> (x = zeror) \/ (zeror < x).
proof. by rewrite ler_eqVlt eq_sym. qed.

lemma nosmt addr_ge0 (x y : t):
  zeror <= x => zeror <= y => zeror <= x + y.
proof.
rewrite le0r; case=> [->|gt0x]; rewrite ?add0r // le0r.
by case=> [->|gt0y]; rewrite ltrW ?addr0 ?addr_gt0.
qed.

lemma nosmt lt0r_neq0 (x : t):
  zeror < x => (x <> zeror).
proof. by rewrite lt0r; case (_ = _). qed.

lemma nosmt ltr0_neq0 (x : t):
  zeror < x => (x <> zeror).
proof. by rewrite lt0r; case: (_ = _). qed.

lemma nosmt gtr_eqF (x y : t):
  y < x => (x <> y).
proof. by rewrite ltr_def => []. qed.

lemma nosmt ltr_eqF (x y : t):
  x < y => (x <> y).
proof. by rewrite eq_sym=> /gtr_eqF ->. qed.

lemma ler0n n : 0 <= n => zeror <= ofint n.
proof.
elim: n => [|n ih h]; first by rewrite mulr0z lerr.
by rewrite ofintS // addr_ge0 // ?ler01.
qed.

lemma ltr0Sn n : 0 <= n => zeror < ofint (n + 1).
proof.
elim: n=> /= [|n ge0n ih]; first by rewrite ofint1 ltr01.
by rewrite ofintS // ?(addz_ge0, addr_gt0) // ltr01.
qed.

lemma ltr0n n : 0 <= n => (zeror < ofint n) = (0 < n).
proof.
elim: n => [|n ge0n _]; first by rewrite mulr0z ltrr.
by rewrite ltr0Sn // ltz_def addz_ge0 ?addz1_neq0.
qed.

lemma pnatr_eq0 n : 0 <= n => (ofint n = zeror) <=> (n = 0).
proof.
elim: n => [|n ge0n _]; rewrite ?mulr0z // gtr_eqF.
  by rewrite ltr0Sn. by rewrite addz1_neq0.
qed.

lemma nosmt pmulr_rgt0 (x y : t):
  zeror < x => (zeror < x * y) <=> (zeror < y).
proof.
rewrite !ltr_def !ger0_def normrM mulf_eq0 -nor.
by case=> ^nz_x -> -> /=; have /inj_eq -> := mulfI _ nz_x.
qed.

lemma nosmt pmulr_rge0 (x y : t):
  zeror < x => (zeror <= x * y) <=> (zeror <= y).
proof.
rewrite !le0r mulf_eq0; case: (y = _) => //= ^lt0x.
by move/lt0r_neq0=> -> /=; apply/pmulr_rgt0.
qed.

lemma nosmt normr_idP (x : t): (`|x| = x) <=> (zeror <= x).
proof. by rewrite ger0_def. qed.

lemma nosmt ger0_norm (x : t): zeror <= x => `|x| = x.
proof. by apply/normr_idP. qed.

lemma nosmt normr0: `|zeror| = zeror.
proof. by apply/ger0_norm/lerr. qed.

lemma nosmt normr1: `|oner| = oner.
proof. by apply/ger0_norm/ler01. qed.

lemma nosmt normr0P (x : t): (`|x| = zeror) <=> (x = zeror).
proof. by split=> [/normr0_eq0|->] //; rewrite normr0. qed.

lemma nosmt normrN1: `|-oner| = oner.
proof.
(*
have: `|-1| ^+ 2 == 1 :> R by rewrite -normrX -signr_odd normr1.
rewrite sqrf_eq1 => /orP[/eqP //|]; rewrite -ger0_def le0r oppr_eq0 oner_eq0.
by move/(addr_gt0 ltr01); rewrite subrr ltrr.
*)
admitted.

lemma nosmt normrN (x : t): `|- x| = `|x|.
proof. by rewrite -mulN1r normrM normrN1 mul1r. qed.

lemma nosmt distrC (x y : t): `|x - y| = `|y - x|.
proof. by rewrite -opprB normrN. qed.

lemma nosmt ler0_def (x : t): (x <= zeror) <=> (`|x| = - x).
proof. by rewrite ler_def sub0r normrN. qed.

lemma nosmt normr_id (x : t): `| `|x| | = `|x|.
proof.
(*
have nz2: 2%:R != 0 :> R by rewrite pnatr_eq0.
apply: (mulfI nz2); rewrite -{1}normr_nat -normrM mulr_natl mulr2n ger0_norm //.
by rewrite -{2}normrN -normr0 -(subrr x) ler_norm_add.
*)
admitted.

lemma nosmt normr_ge0 (x : t): zeror <= `|x|.
proof. by rewrite ger0_def normr_id. qed.

lemma nosmt ler0_norm (x : t): x <= zeror => `|x| = - x.
proof.
move=> x_le0; rewrite eq_sym -@(ger0_norm (-x)).
  by rewrite oppr_ge0. by rewrite normrN.
qed.

lemma nosmt gtr0_norm (x : t): zeror < x => `|x| = x.
proof. by move/ltrW/ger0_norm. qed.

lemma nosmt ltr0_norm (x : t): x < zeror => `|x| = - x.
proof. by move/ltrW/ler0_norm. qed.

lemma nosmt subr_gt0 (x y : t): (zeror < y - x) <=> (x < y).
proof. by rewrite !ltr_def subr_eq0 subr_ge0. qed.

lemma nosmt subr_le0 (x y : t): (y - x <= zeror) <=> (y <= x).
proof. by rewrite -subr_ge0 subrE opprB add0r subr_ge0. qed.

lemma nosmt subr_lt0 (x y : t): (y - x < zeror) <=> (y < x).
proof. by rewrite -subr_gt0 subrE opprB add0r subr_gt0. qed.

lemma nosmt ler_asym (x y : t): x <= y <= x => x = y.
proof.
rewrite !ler_def distrC -opprB -addr_eq0 => [->].
by rewrite -mulr2z -mulr_intl mulf_eq0 subr_eq0 pnatr_eq0.
qed.

lemma nosmt eqr_le (x y : t): (x = y) <=> (x <= y <= x).
proof. by split=> [->|/ler_asym]; rewrite ?lerr. qed.

lemma nosmt ltr_trans (y x z : t): x < y => y < z => x < z.
proof.
move=> le_xy le_yz; rewrite -subr_gt0 -@(subrK z y).
by rewrite !subrE -addrA addr_gt0 -?subrE ?subr_gt0.
qed.

lemma nosmt ler_lt_trans (y x z : t): x <= y => y < z => x < z.
proof. by rewrite !ler_eqVlt => [-> //|/ltr_trans h]; apply/h. qed.

lemma nosmt ltr_le_trans (y x z : t): x < y => y <= z => x < z.
proof. by rewrite !ler_eqVlt => lxy [<- //|lyz]; apply @(ltr_trans y). qed.

lemma nosmt ler_trans (y x z : t): x <= y => y <= z => x <= z.
proof.
rewrite !ler_eqVlt => [-> //|lxy] [<-|].
  by rewrite lxy. by move/(ltr_trans _ _ _ lxy) => ->.
qed.

lemma nosmt ltr_asym (x y : t): ! (x < y < x).
proof. by apply/negP=> -[/ltr_trans hyx /hyx]; rewrite ltrr. qed.

lemma ler_anti (x y : t): x <= y <= x => x = y.
proof. by rewrite -eqr_le. qed.

lemma nosmt ltr_le_asym (x y : t): ! (x < y <= x).
proof. admit. qed.

lemma nosmt ler_lt_asym (x y : t):
  ! (x <= y < x).
proof. by rewrite anda_and andC -anda_and ltr_le_asym. qed.

lemma nosmt ltr_geF (x y : t): x < y => ! (y <= x).
proof. by move=> xy; apply/negP => /(ltr_le_trans _ _ _ xy); rewrite ltrr. qed.

lemma nosmt ler_gtF (x y : t): x <= y => ! (y < x).
proof. by move=> le_xy; apply/negP=> /ltr_geF. qed.

lemma nosmt ltr_gtF (x y : t): x < y => ! (y < x).
proof. by move/ltrW/ler_gtF. qed.

lemma nosmt normr_le0 (x : t): (`|x| <= zeror) <=> (x = zeror).
proof. by rewrite -normr0P eqr_le normr_ge0. qed.

lemma nosmt normr_lt0 (x : t): ! (`|x| < zeror).
proof. by rewrite ltr_neqAle normr_le0 normr0P; case: (_ = _). qed.

lemma nosmt normr_gt0 (x : t): (zeror < `|x|) <=> (x <> zeror).
proof. by rewrite ltr_def normr0P normr_ge0; case: (_ = _). qed.

(* -------------------------------------------------------------------- *)
lemma nosmt mono_inj f : mono2 f (<=) (<=) => injective f.
proof. by move=> mf x y; rewrite eqr_le !mf -eqr_le. qed.

lemma nosmt nmono_inj f : mono2 f (fun y x => x <= y) (<=) => injective f.
proof. by move=> mf x y; rewrite eqr_le !mf -eqr_le. qed.

lemma nosmt lerW_mono f : mono2 f (<=) (<=) => mono2 f (<) (<).
proof.
move=> mf x y; rewrite !ltr_neqAle mf.
by rewrite inj_eq //; apply/mono_inj.
qed.

lemma nosmt lerW_nmono f : mono2 f (fun y x => x <= y) (<=) =>
  mono2 f (fun y x => x < y) (<).
proof.
move=> mf x y; rewrite !ltr_neqAle mf eq_sym.
by rewrite inj_eq //; apply/nmono_inj.
qed.

(* -------------------------------------------------------------------- *)
lemma nosmt ler_opp2 (x y : t): (-x <= -y) <=> (y <= x).
proof. by rewrite -subr_ge0 subrE opprK addrC -subrE subr_ge0. qed.

lemma nosmt ltr_opp2 (x y : t): (-x < -y) <=> (y < x).
proof. by rewrite lerW_nmono //; apply/ler_opp2. qed.

lemma nosmt ler_oppr (x y : t): (x <= - y) <=> (y <= - x).
proof. by rewrite (monoRL opprK ler_opp2). qed.

hint rewrite lter_opp2 : ler_opp2 ltr_opp2.

lemma nosmt ltr_oppr (x y : t): (x < - y) <=> (y < - x).
proof.                          (* FIXME *)
by apply/@(monoRL _ _ (fun y x => x < y) (<) opprK)/lerW_nmono/ler_opp2.
qed.

lemma nosmt ler_oppl (x y : t):
  (- x <= y) <=> (- y <= x).
proof. by rewrite (monoLR opprK ler_opp2). qed.

lemma nosmt ltr_oppl (x y : t):
  (- x < y) <=> (- y < x).
proof.                          (* FIXME *)
by apply/@(monoLR _ _ (fun y x => x < y) (<) opprK)/lerW_nmono/ler_opp2.
qed.

lemma nosmt oppr_gt0 (x : t): (zeror < - x) <=> (x < zeror).
proof. by rewrite ltr_oppr oppr0. qed.

lemma nosmt oppr_le0 (x : t): (- x <= zeror) <=> (zeror <= x).
proof. by rewrite ler_oppl oppr0. qed.

lemma nosmt oppr_lt0 (x : t): (- x < zeror) <=> (zeror < x).
proof. by rewrite ltr_oppl oppr0. qed.

hint rewrite oppr_gte0 : oppr_ge0 oppr_gt0.
hint rewrite oppr_lte0 : oppr_le0 oppr_lt0.
hint rewrite oppr_cp0  : oppr_ge0 oppr_gt0 oppr_le0 oppr_lt0.
hint rewrite lter_oppE : oppr_le0 oppr_lt0 oppr_ge0 oppr_gt0.
hint rewrite lter_oppE : ler_opp2 ltr_opp2.

(* -------------------------------------------------------------------- *)
lemma nosmt ler_leVge (x y : t):
  x <= zeror => y <= zeror => (x <= y) \/ (y <= x).
proof. by rewrite -!oppr_ge0 => /(ger_leVge _) h /h; rewrite !ler_opp2 orbC. qed.

lemma ler_add2l (x y z : t) : (z + x <= z + y) <=> (x <= y).
proof. by rewrite -subr_ge0 subrE opprD addrAC addNKr addrC -subrE subr_ge0. qed.

lemma ler_add2r (x y z : t) : (x + z <= y + z) <=> (x <= y).
proof. by rewrite !@(addrC _ z) ler_add2l. qed.

lemma nosmt ltr_add2r (z x y : t): (x + z < y + z) <=> (x < y).
proof.                          (* FIXME *)
by apply/@(lerW_mono (fun t => t + z))=> {x y} x y; apply ler_add2r.
qed.

lemma nosmt ltr_add2l (z x y : t): (z + x < z + y) <=> (x < y).
proof.
by apply/@(lerW_mono ((+) z)) => {x y} x y; apply ler_add2l.
qed.

hint rewrite ler_add2  : ler_add2l ler_add2r.
hint rewrite ltr_add2  : ltr_add2l ltr_add2r.
hint rewrite lter_add2 : ler_add2l ler_add2r ltr_add2l ltr_add2r.

lemma nosmt ler_add (x y z t : t):
  x <= y => z <= t => x + z <= y + t.
proof. by move=> xy zt; rewrite @(ler_trans (y + z)) ?lter_add2. qed.

lemma nosmt ler_lt_add (x y z t : t):
  x <= y => z < t => x + z < y + t.
proof. by move=> xy zt; rewrite @(ler_lt_trans (y + z)) ?lter_add2. qed.

lemma nosmt ltr_le_add (x y z t : t):
  x < y => z <= t => x + z < y + t.
proof. by move=> xy zt; rewrite @(ltr_le_trans (y + z)) ?lter_add2. qed.

lemma nosmt ltr_add (x y z t : t): x < y => z < t => x + z < y + t.
proof. by move=> xy zt; rewrite ltr_le_add // ltrW. qed.

lemma nosmt ler_sub (x y z t : t):
  x <= y => t <= z => x - z <= y - t.
proof. by move=> xy tz; rewrite !subrE ler_add ?lter_opp2. qed.

lemma nosmt ler_lt_sub (x y z t : t):
  x <= y => t < z => x - z < y - t.
proof. by move=> xy zt; rewrite !subrE ler_lt_add ?lter_opp2. qed.

lemma nosmt ltr_le_sub (x y z t : t):
  x < y => t <= z => x - z < y - t.
proof. by move=> xy zt; rewrite !subrE ltr_le_add ?lter_opp2. qed.

lemma nosmt ltr_sub (x y z t : t):
  x < y => t < z => x - z < y - t.
proof. by move=> xy tz; rewrite !subrE ltr_add ?lter_opp2. qed.

lemma nosmt ler_subl_addr (x y z : t):
  (x - y <= z) <=> (x <= z + y).
proof. admit. qed.

lemma nosmt ltr_subl_addr (x y z : t):
  (x - y < z) <=> (x < z + y).
proof. admit. qed.

lemma nosmt ler_subr_addr (x y z : t):
  (x <= y - z) <=> (x + z <= y).
proof. admit. qed.

lemma nosmt ltr_subr_addr (x y z : t):
  (x < y - z) <=> (x + z < y).
proof. admit. qed.

hint rewrite ler_sub_addr  : ler_subl_addr ler_subr_addr.
hint rewrite ltr_sub_addr  : ltr_subl_addr ltr_subr_addr.
hint rewrite lter_sub_addr : ler_subl_addr ler_subr_addr.
hint rewrite lter_sub_addr : ltr_subl_addr ltr_subr_addr.

lemma nosmt ler_subl_addl (x y z : t):
  (x - y <= z) <=> (x <= y + z).
proof. by rewrite lter_sub_addr addrC. qed.

lemma nosmt ltr_subl_addl (x y z : t):
  (x - y < z) <=> (x < y + z).
proof. by rewrite lter_sub_addr addrC. qed.

lemma nosmt ler_subr_addl (x y z : t):
  (x <= y - z) <=> (z + x <= y).
proof. by rewrite lter_sub_addr addrC. qed.

lemma nosmt ltr_subr_addl (x y z : t):
  (x < y - z) <=> (z + x < y).
proof. by rewrite lter_sub_addr addrC. qed.

hint rewrite ler_sub_addl  : ler_subl_addl ler_subr_addl.
hint rewrite ltr_sub_addl  : ltr_subl_addl ltr_subr_addl.
hint rewrite lter_sub_addl : ler_subl_addl ler_subr_addl.
hint rewrite lter_sub_addl : ltr_subl_addl ltr_subr_addl.

lemma nosmt ler_addl (x y : t): (x <= x + y) <=> (zeror <= y).
proof. by rewrite -{1}@(addr0 x) lter_add2. qed.

lemma nosmt ltr_addl (x y : t): (x < x + y) <=> (zeror < y).
proof. by rewrite -{1}@(addr0 x) lter_add2. qed.

lemma nosmt ler_addr (x y : t): (x <= y + x) <=> (zeror <= y).
proof. by rewrite -{1}@(add0r x) lter_add2. qed.

lemma nosmt ltr_addr (x y : t): (x < y + x) <=> (zeror < y).
proof. by rewrite -{1}@(add0r x) lter_add2. qed.

lemma nosmt ger_addl (x y : t): (x + y <= x) <=> (y <= zeror).
proof. by rewrite -{2}@(addr0 x) lter_add2. qed.

lemma nosmt gtr_addl (x y : t): (x + y < x) <=> (y < zeror).
proof. by rewrite -{2}@(addr0 x) lter_add2. qed.

lemma nosmt ger_addr (x y : t): (y + x <= x) <=> (y <= zeror).
proof. by rewrite -{2}@(add0r x) lter_add2. qed.

lemma nosmt gtr_addr (x y : t): (y + x < x) <=> (y < zeror).
proof. by rewrite -{2}@(add0r x) lter_add2. qed.

hint rewrite cpr_add : ler_addl ler_addr ger_addl ger_addl.
hint rewrite cpr_add : ltr_addl ltr_addr gtr_addl gtr_addl.

lemma nosmt ler_paddl (y x z : t):
  zeror <= x => y <= z => y <= x + z.
proof. by move=> ??; rewrite -@(add0r y) ler_add. qed.

lemma nosmt ltr_paddl (y x z : t):
  zeror <= x => y < z => y < x + z.
proof. by move=> ??; rewrite -@(add0r y) ler_lt_add. qed.

lemma nosmt ltr_spaddl (y x z : t):
  zeror < x => y <= z => y < x + z.
proof. by move=> ??; rewrite -@(add0r y) ltr_le_add. qed.

lemma nosmt ltr_spsaddl (y x z : t):
  zeror < x => y < z => y < x + z.
proof. by move=> ??; rewrite -@(add0r y) ltr_add. qed.

lemma nosmt ler_naddl (y x z : t):
  x <= zeror => y <= z => x + y <= z.
proof. by move=> ??; rewrite -@(add0r z) ler_add. qed.

lemma nosmt ltr_naddl (y x z : t):
  x <= zeror => y < z => x + y < z.
proof. by move=> ??; rewrite -@(add0r z) ler_lt_add. qed.

lemma nosmt ltr_snaddl (y x z : t):
  x < zeror => y <= z => x + y < z.
proof. by move=> ??; rewrite -@(add0r z) ltr_le_add. qed.

lemma nosmt ltr_snsaddl (y x z : t):
  x < zeror => y < z => x + y < z.
proof. by move=> ??; rewrite -@(add0r z) ltr_add. qed.

lemma nosmt ler_paddr (y x z : t):
  zeror <= x => y <= z => y <= z + x.
proof. by move=> ??; rewrite @(addrC _ x) ler_paddl. qed.

lemma nosmt ltr_paddr (y x z : t):
  zeror <= x => y < z => y < z + x.
proof. by move=> ??; rewrite @(addrC _ x) ltr_paddl. qed.

lemma nosmt ltr_spaddr (y x z : t):
  zeror < x => y <= z => y < z + x.
proof. by move=> ??; rewrite @(addrC _ x) ltr_spaddl. qed.

lemma nosmt ltr_spsaddr (y x z : t):
  zeror < x => y < z => y < z + x.
proof. by move=> ??; rewrite @(addrC _ x) ltr_spsaddl. qed.

lemma nosmt ler_naddr (y x z : t):
  x <= zeror => y <= z => y + x <= z.
proof. by move=> ??; rewrite @(addrC _ x) ler_naddl. qed.

lemma nosmt ltr_naddr (y x z : t):
  x <= zeror => y < z => y + x < z.
proof. by move=> ??; rewrite @(addrC _ x) ltr_naddl. qed.

lemma nosmt ltr_snaddr (y x z : t):
  x < zeror => y <= z => y + x < z.
proof. by move=> ??; rewrite @(addrC _ x) ltr_snaddl. qed.

lemma nosmt ltr_snsaddr (y x z : t):
  x < zeror => y < z => y + x < z.
proof. by move=> ??; rewrite @(addrC _ x) ltr_snsaddl. qed.

(* -------------------------------------------------------------------- *)
lemma nosmt paddr_eq0 (x y : t):
  zeror <= x => zeror <= y => (x + y = zeror) <=> (x = zeror) /\ (y = zeror).
proof. admit. qed.

lemma nosmt naddr_eq0 (x y : t):
  x <= zeror => y <= zeror => (x + y = zeror) <=> (x = zeror) /\ (y = zeror).
proof. admit. qed.

lemma nosmt addr_ss_eq0 (x y : t):
        (zeror <= x    ) /\ (zeror <= y    )
     \/ (x     <= zeror) /\ (y     <= zeror)
  => (x + y = zeror) <=> (x = zeror) /\ (y = zeror).
proof. admit. qed.

(* -------------------------------------------------------------------- *)
lemma nosmt ler_pmul2l x :
  zeror < x => forall y z, (x * y <= x * z) <=> (y <= z).
proof.
move=> x_gt0 y z /=; rewrite -subr_ge0 -mulrBr.
by rewrite pmulr_rge0 // subr_ge0.
qed.

lemma nosmt ltr_pmul2l x :
  zeror < x => forall y z, (x * y < x * z) <=> (y < z).
proof. admit. qed.

hint rewrite lter_pmul2l : ler_pmul2l ltr_pmul2l.

lemma nosmt ler_pmul2r x : zeror < x => forall y z, (y <= z) <=> (y * x <= z * x).
proof. by move=> x_gt0 y z /=; rewrite !@(mulrC _ x) ler_pmul2l. qed.

lemma nosmt ltr_pmul2r x : zeror < x => forall y z, (y < z) <=> (y * x < z * x).
proof. admit. qed.

hint rewrite lter_pmul2r : ler_pmul2r ltr_pmul2r.

lemma nosmt ler_nmul2l x :
  x < zeror => forall y z, (x * z <= x * y) <=> (y <= z).
proof. by move=> x_lt0 y z /=; rewrite -ler_opp2 -!mulNr ler_pmul2l ?oppr_gt0. qed.

lemma nosmt ltr_nmul2l x :
  x < zeror => forall y z, (x * z < x * y) <=> (y < z).
proof. admit. qed.

hint rewrite lter_nmul2l : ler_nmul2l ltr_nmul2l.

lemma nosmt ler_nmul2r x :
  x < zeror => forall y z, (z * x <= y * x) <=> (y <= z).
proof. by move=> x_lt0 y z /=; rewrite !@(mulrC _ x) ler_nmul2l. qed.

lemma nosmt ltr_nmul2r x :
  x < zeror => forall y z, (z * x < y * x) <=> (y < z).
proof. admit. qed.

hint rewrite lter_nmul2r : ler_nmul2r ltr_nmul2r.

(* -------------------------------------------------------------------- *)
lemma nosmt ler_wpmul2l x :
  zeror <= x => forall y z, y <= z => x * y <= x * z.
proof. admit. qed.

lemma nosmt ler_wpmul2r x :
  zeror <= x => forall y z, y <= z => y * x <= z * x.
proof. admit. qed.

lemma nosmt ler_wnmul2l x :
  x <= zeror => forall y z, z <= y => x * y <= x * z.
proof. admit. qed.

lemma nosmt ler_wnmul2r x :
  x <= zeror => forall y z, z <= y => y * x <= z * x.
proof. admit. qed.

(* -------------------------------------------------------------------- *)
lemma nosmt ler_pmul (x1 y1 x2 y2 : t):
  zeror <= x1 => zeror <= x2 => x1 <= y1 => x2 <= y2 => x1 * x2 <= y1 * y2.
proof. admit. qed.

lemma nosmt ltr_pmul (x1 y1 x2 y2 : t):
  zeror <= x1 => zeror <= x2 => x1 < y1 => x2 < y2 => x1 * x2 < y1 * y2.
proof. admit. qed.

lemma nosmt ltrNge (x y : t): (x < y) <=> !(y <= x).
proof. admit. qed.

(* -------------------------------------------------------------------- *)
lemma nosmt ltrN10: -oner < zeror.
proof. by rewrite oppr_lt0 ltr01. qed.

lemma nosmt lerN10: -oner <= zeror.
proof. by rewrite oppr_le0 ler01. qed.

lemma nosmt ltr0N1: !(zeror < -oner).
proof. by rewrite ler_gtF // lerN10. qed.

lemma nosmt ler0N1: !(zeror <= -oner).
proof. by rewrite ltr_geF // ltrN10. qed.

lemma nosmt pmulr_rlt0 (x y : t):
  zeror < x => (x * y < zeror) <=> (y < zeror).
proof.
by move=> x_gt0; rewrite -oppr_gt0 -mulrN pmulr_rgt0 // oppr_gt0.
qed.

lemma nosmt pmulr_rle0 (x y : t):
  zeror < x => (x * y <= zeror) <=> (y <= zeror).
proof.
by move=> x_gt0; rewrite -oppr_ge0 -mulrN pmulr_rge0 // oppr_ge0.
qed.

lemma nosmt pmulr_lgt0 (x y : t):
  zeror < x => (zeror < y * x) <=> (zeror < y).
proof. by move=> x_gt0; rewrite mulrC pmulr_rgt0. qed.

lemma nosmt pmulr_lge0 (x y : t):
  zeror < x => (zeror <= y * x) <=> (zeror <= y).
proof. by move=> x_gt0; rewrite mulrC pmulr_rge0. qed.

lemma nosmt pmulr_llt0 (x y : t):
  zeror < x => (y * x < zeror) <=> (y < zeror).
proof. by move=> x_gt0; rewrite mulrC pmulr_rlt0. qed.

lemma nosmt pmulr_lle0 (x y : t):
  zeror < x => (y * x <= zeror) <=> (y <= zeror).
proof. by move=> x_gt0; rewrite mulrC pmulr_rle0. qed.

lemma nosmt nmulr_rgt0 (x y : t):
  x < zeror => (zeror < x * y) <=> (y < zeror).
proof. by move=> x_lt0; rewrite -mulrNN pmulr_rgt0 lter_oppE. qed.

lemma nosmt nmulr_rge0 (x y : t):
  x < zeror => (zeror <= x * y) <=> (y <= zeror).
proof. by move=> x_lt0; rewrite -mulrNN pmulr_rge0 lter_oppE. qed.

lemma nosmt nmulr_rlt0 (x y : t):
  x < zeror => (x * y < zeror) <=> (zeror < y).
proof. by move=> x_lt0; rewrite -mulrNN pmulr_rlt0 lter_oppE. qed.

lemma nosmt nmulr_rle0 (x y : t):
  x < zeror => (x * y <= zeror) <=> (zeror <= y).
proof. by move=> x_lt0; rewrite -mulrNN pmulr_rle0 lter_oppE. qed.

lemma nosmt nmulr_lgt0 (x y : t):
  x < zeror => (zeror < y * x) <=> (y < zeror).
proof. by move=> x_lt0; rewrite mulrC nmulr_rgt0. qed.

lemma nosmt nmulr_lge0 (x y : t):
  x < zeror => (zeror <= y * x) <=> (y <= zeror).
proof. by move=> x_lt0; rewrite mulrC nmulr_rge0. qed.

lemma nosmt nmulr_llt0 (x y : t):
  x < zeror => (y * x < zeror) <=> (zeror < y).
proof. by move=> x_lt0; rewrite mulrC nmulr_rlt0. qed.

lemma nosmt nmulr_lle0 (x y : t):
  x < zeror => (y * x <= zeror) <=> (zeror <= y).
proof. by move=> x_lt0; rewrite mulrC nmulr_rle0. qed.

lemma nosmt mulr_ge0 (x y : t):
  zeror <= x => zeror <= y => zeror <= x * y.
proof. by move=> x_ge0 y_ge0; rewrite -(mulr0 x) ler_wpmul2l. qed.

lemma nosmt mulr_le0 (x y : t):
  x <= zeror => y <= zeror => zeror <= x * y.
proof. by move=> x_le0 y_le0; rewrite -(mulr0 x) ler_wnmul2l. qed.

lemma nosmt mulr_ge0_le0 (x y : t):
  zeror <= x => y <= zeror => x * y <= zeror.
proof. by move=> x_le0 y_le0; rewrite -(mulr0 x) ler_wpmul2l. qed.

lemma nosmt mulr_le0_ge0 (x y : t):
  x <= zeror => zeror <= y => x * y <= zeror.
proof. by move=> x_le0 y_le0; rewrite -(mulr0 x) ler_wnmul2l. qed.

lemma nosmt mulr_gt0 (x y : t):
  zeror < x => zeror < y => zeror < x * y.
proof. by move=> x_gt0 y_gt0; rewrite pmulr_rgt0. qed.

(* -------------------------------------------------------------------- *)
lemma nosmt ger_pmull x y : zeror < y => (x * y <= y) <=> (x <= oner).
proof. by move=> hy; rewrite -{2}(mul1r y) -ler_pmul2r. qed.

lemma nosmt gtr_pmull x y : zeror < y => (x * y < y) <=> (x < oner).
proof. by move=> hy; rewrite -{2}(mul1r y) -ltr_pmul2r. qed.

lemma nosmt ger_pmulr x y : zeror < y => (y * x <= y) <=> (x <= oner).
proof. by move=> hy; rewrite -{2}(mulr1 y) ler_pmul2l. qed.

lemma nosmt gtr_pmulr x y : zeror < y => (y * x < y) <=> (x < oner).
proof. by move=> hy; rewrite -{2}(mulr1 y); rewrite ltr_pmul2l. qed.

lemma nosmt ler_pmull x y : zeror < y => (y <= x * y) <=> (oner <= x).
proof. by move=> hy; rewrite -{1}(mul1r y) -ler_pmul2r. qed.

lemma nosmt ltr_pmull x y : zeror < y => (y < x * y) <=>(oner < x).
proof. by move=> hy; rewrite -{1}(mul1r y) -ltr_pmul2r. qed.

lemma nosmt ler_pmulr x y : zeror < y => (y <= y * x) <=>(oner <= x).
proof. by move=> hy; rewrite -{1}(mulr1 y) ler_pmul2l. qed.

lemma nosmt ltr_pmulr x y : zeror < y => (y < y * x) <=>(oner < x).
proof. by move=> hy; rewrite -{1}(mulr1 y) ltr_pmul2l. qed.

lemma nosmt ger_nmull x y : y < zeror => (x * y <= y) = (oner <= x).
proof. by move=> hy; rewrite -{2}(mul1r y)ler_nmul2r. qed.

lemma nosmt gtr_nmull x y : y < zeror => (x * y < y) = (oner < x).
proof. by move=> hy; rewrite -{2}(mul1r y) ltr_nmul2r. qed.

lemma nosmt ger_nmulr x y : y < zeror => (y * x <= y) = (oner <= x).
proof. by move=> hy; rewrite -{2}(mulr1 y) ler_nmul2l. qed.

lemma nosmt gtr_nmulr x y : y < zeror => (y * x < y) = (oner < x).
proof. by move=> hy; rewrite -{2}(mulr1 y) ltr_nmul2l. qed.

lemma nosmt ler_nmull x y : y < zeror => (y <= x * y) <=> (x <= oner).
proof. by move=> hy; rewrite -{1}(mul1r y) ler_nmul2r. qed.

lemma nosmt ltr_nmull x y : y < zeror => (y < x * y) <=> (x < oner).
proof. by move=> hy; rewrite -{1}(mul1r y) ltr_nmul2r. qed.

lemma nosmt ler_nmulr x y : y < zeror => (y <= y * x) <=> (x <= oner).
proof. by move=> hy; rewrite -{1}(mulr1 y) ler_nmul2l. qed.

lemma nosmt ltr_nmulr x y : y < zeror => (y < y * x) <=> (x < oner).
proof. by move=> hy; rewrite -{1}(mulr1 y) ltr_nmul2l. qed.

(* -------------------------------------------------------------------- *)
lemma ler_pemull x y : zeror <= y => oner <= x => y <= x * y.
proof. by move=> hy hx; rewrite -{1}(mul1r y) ler_wpmul2r. qed.

lemma ler_nemull x y : y <= zeror => oner <= x => x * y <= y.
proof. by move=> hy hx; rewrite -{2}(mul1r y) ler_wnmul2r. qed.

lemma ler_pemulr x y : zeror <= y => oner <= x => y <= y * x.
proof. by move=> hy hx; rewrite -{1}(mulr1 y) ler_wpmul2l. qed.

lemma ler_nemulr x y : y <= zeror => oner <= x => y * x <= y.
proof. by move=> hy hx; rewrite -{2}(mulr1 y) ler_wnmul2l. qed.

lemma nosmt ler_pimull x y : zeror <= y => x <= oner => x * y <= y.
proof. by move=> hy hx; rewrite -{2}(mul1r y) ler_wpmul2r. qed.

lemma nosmt ler_nimull x y : y <= zeror => x <= oner => y <= x * y.
proof. by move=> hy hx; rewrite -{1}(mul1r y) ler_wnmul2r. qed.

lemma nosmt ler_pimulr x y : zeror <= y => x <= oner => y * x <= y.
proof. by move=> hy hx; rewrite -{2}(mulr1 y) ler_wpmul2l. qed.

lemma nosmt ler_nimulr x y : y <= zeror => x <= oner => y <= y * x.
proof. by move=> hx hy; rewrite -{1}(mulr1 y) ler_wnmul2l. qed.

(* -------------------------------------------------------------------- *)
lemma nosmt mulr_ile1 (x y : t):
  zeror <= x => zeror <= y => x <= oner => y <= oner => x * y <= oner.
proof. by move=> ????; rewrite @(ler_trans y) ?ler_pimull. qed.

lemma nosmt mulr_ilt1 (x y : t):
  zeror <= x => zeror <= y => x < oner => y < oner => x * y < oner.
proof. by move=> ????; rewrite @(ler_lt_trans y) ?ler_pimull // ?ltrW. qed.

hint rewrite mulr_ilte1 : mulr_ile1 mulr_ilt1.
hint rewrite mulr_cp1   : mulr_ile1 mulr_ilt1.

(* -------------------------------------------------------------------- *)
lemma mulr_ege1 x y : oner <= x => oner <= y => oner <= x * y.
proof.
by move=> le1x le1y; rewrite @(ler_trans y) ?ler_pemull // (ler_trans ler01).
qed.

lemma mulr_egt1 x y : oner < x => oner < y => oner < x * y.
proof.
by move=> le1x lt1y; rewrite @(ltr_trans y) // ltr_pmull // (ltr_trans ltr01).
qed.

hint rewrite mulr_egte1 : mulr_ege1  mulr_egt1.
hint rewrite mulr_cp1   : mulr_ege1  mulr_egt1.

(* -------------------------------------------------------------------- *)
lemma nosmt invr_gt0 x : (zeror < invr x) <=> (zeror < x).
proof.
case: (unit x) => [ux|nux]; last by rewrite invr_out.
by split=> /ltr_pmul2r ->; rewrite mul0r (mulrV, mulVr) ?ltr01.
qed.

lemma nosmt invr_ge0 x : (zeror <= invr x) <=> (zeror <= x).
proof. by rewrite !le0r invr_gt0 invr_eq0. qed.

lemma nosmt invr_lt0 x : (invr x < zeror) <=> (x < zeror).
proof. by rewrite -oppr_cp0 -invrN invr_gt0 oppr_cp0. qed.

lemma nosmt invr_le0 x : (invr x <= zeror) <=> (x <= zeror).
proof. by rewrite -oppr_cp0 -invrN invr_ge0 oppr_cp0. qed.

(* -------------------------------------------------------------------- *)
lemma nosmt divr_ge0 x y : zeror <= x => zeror <= y => zeror <= x / y.
proof. by move=> x_ge0 y_ge0; rewrite divrE mulr_ge0 ?invr_ge0. qed.

lemma nosmt divr_gt0 x y : zeror < x => zeror < y => zeror < x / y.
proof. by move=> x_gt0 y_gt0; rewrite divrE pmulr_rgt0 ?invr_gt0. qed.

(* -------------------------------------------------------------------- *)
lemma nosmt ler_norm_sub (x y : t):
  `|x - y| <= `|x| + `|y|.
proof. admit. qed.

lemma nosmt ler_dist_add (z x y : t):
  `|x - y| <= `|x - z| + `|z - y|.
proof. admit. qed.

lemma nosmt ler_sub_norm_add (x y : t):
  `|x| - `|y| <= `|x + y|.
proof. admit. qed.

lemma nosmt ler_sub_dist (x y : t):
  `|x| - `|y| <= `|x - y|.
proof. admit. qed.

lemma nosmt ler_dist_dist (x y : t):
  `| `|x| - `|y| | <= `|x - y|.
proof. admit. qed.

lemma nosmt ler_dist_norm_add (x y : t):
  `| `|x| - `|y| | <= `|x + y|.
proof. by rewrite -@(opprK y) normrN -subrE ler_dist_dist. qed.

lemma nosmt ler_nnorml (x y : t): y < zeror => ! (`|x| <= y).
proof. by move=> y_lt0; rewrite ltr_geF // (ltr_le_trans y_lt0) ?normr_ge0. qed.

lemma nosmt ltr_nnorml (x y : t): y <= zeror => ! (`|x| < y).
proof. by move=> y_le0; rewrite ler_gtF // (ler_trans y_le0) ?normr_ge0. qed.

lemma nosmt eqr_norm_id (x : t): (`|x| = x) <=> (zeror <= x).
proof. by rewrite ger0_def. qed.

lemma nosmt eqr_normN (x : t): (`|x| = - x) <=> (x <= zeror).
proof. by rewrite ler0_def. qed.

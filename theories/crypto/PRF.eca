require import AllCore Distr FSet.

pragma +implicits.

(** A PRF is a family of functions F from domain D to finite range R
    indexed by a keyspace K equipped with a (lossless) distribution dK. *)
type D, R.

module type PRF = {
  proc init(): unit
  proc f(_ : D): R
}.

module type PRF_Oracles = {
  proc f(_: D): R
}.

(** We generalize over distinguishers to allow some flexibility.
    In general, we'd expect d_in_t to be unit, and d_out_t to be bool **)
type d_in_t, d_out_t.

module type Distinguisher (F : PRF_Oracles) = {
  proc distinguish(_ : d_in_t): d_out_t
}.

module IND (F : PRF) (D : Distinguisher) = {
  proc main(x : d_in_t): d_out_t = {
    var r;

         F.init();
    r <@ D(F).distinguish(x);
    return r;
  }
}.

(* -------------------------------------------------------------------- *)
abstract theory RF.
require import SmtMap.

op dR: { D -> R distr | forall x, is_lossless (dR x) } as dR_ll.

module RF = {
  var m : (D,R) fmap

  proc init(): unit = {
    m  <- empty;
  }

  proc f(x:D): R = {
    var r;

    r <$ dR x;
    if (x \notin m) {
      m.[x]  <- r;
    }
    return (oget m.[x]);
  }
}.
end RF.

(* -------------------------------------------------------------------- *)
abstract theory PseudoRF.
type K.

op dK: { K distr | is_lossless dK } as dK_ll.

op F : K -> D -> R.

module type PseudoRF = {
  proc keygen(): K
  proc f(_ : K * D): R
}.

module PseudoRF = {
  proc keygen() = {
    var k;

    k <$ dK;
    return k;
  }

  proc f(k, x) = { return F k x; }
}.

module PRF = {
  var k : K

  proc init()  = { k <$ dK; }
  proc f(x: D) = { return F k x; }
}.
end PseudoRF.
